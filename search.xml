<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[YINXS]]></title>
    <url>%2F2018%2F06%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[信息github https://github.com/Hughendman 微信 : wxid_reb7kk3h8om122 qq : 1490853857]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo高级使用]]></title>
    <url>%2F2018%2F06%2F12%2FHexo%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[添加新的页面$ hexo new page about 配置目录在next下的_config.yml 12345678910menu: home: / || home archives: /archives || archive tags: /tags || tags message: /message || comment about: /about || user# Enable/Disable menu icons.menu_icons: enable: true 给一篇文章加入各种属性1234567891011121314151617---title: 在vue中使用lessdate: 2018-06-11 11:15:00categories : VUEtags: VUEkeywords : VUE------title: 自学编程成功概率有多少可能date: 2017-05-26 19:57:47tags: [编程,感悟]categories: 技术--- 本地添加搜索菜单（功能）1npm install hexo-generator-searchdb --save 打开 站点配置文件 找到Extensions在下面添加 12345search: path: search.xml field: post format: html limit: 10000 添加字数统计、阅读时长、友情链接 第一步：安装word_count插件，在博客根目录下打开终端:npm install hexo-wordcount –save 第二步：在主题配置文件(themes\next\config.yml)中打开wordcount 统计功能 123456# Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true wordcount: true min2read: true 第三步： themes\next\layout_macro\post.swig将“字”、“分钟” 字样添加到如下位置即可。 12345678&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; ...&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 分类和标签123在该功能下的index.md中添加type: "categories"]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>构建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[启动和关闭项目脚本]]></title>
    <url>%2F2018%2F06%2F12%2F%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[代码qality.sh1234567#!/bin/bashpIDa=`/usr/sbin/lsof -i :8081|grep -v "PID" | awk '&#123;print $2&#125;'`;if [ "$pIDa" != "" ];then kill -9 $(lsof -i:1900 |awk '&#123;print $2&#125;' | tail -n 2);else /usr/local/nginx/sbin/nginx;fi 注意： 如果实在windows上面写的需要进行一次转换 dos2unix quality.sh nginx配置前台启动1234#user nobody;worker_processes 1;# 主要加下面这句话daemon off;]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHubPages + Hexo+Next构建你自己的博客]]></title>
    <url>%2F2018%2F06%2F11%2FGitHubPages%20%2B%20Hexo%2BNext%E6%9E%84%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[github准备新建一个项目：你的用户名.github.io（项目名称） Hexo 安装node npm install hexo-cli -g hexo init 你的用户名.github.io // 尽量和Github仓库使用同一个名称 cd 你的用户名.github.io hexo s 打开http://localhost:4000/ Next主题安装 Next主题是iissnan所创作的一个Hexo主题，以简洁为主 cd xxx.github.io git clone https://github.com/iissnan/hexo-theme-next themes/next _config.yml站点配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: 最晚的开始 #站点名称 subtitle: 所有的为时已晚都是开始的最好时候 #副标题 #个人描述 description: My goal is not write code.if we could ship products and make all this money without writing any code,we could.Your job is ship products EXACTLY on time.It doesn’t matter whether you are a developer,tester,program manager,product manager whatever.Everybody’s job is the same. author: Jack_lin #作者 language: zh-Hans #语言 timezone: # URL #绑定域名后，要创建 sitemap.xml 时再配置该项 ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/' url: http://yoursite.com root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory #目录不用修改 source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing # 文章布局、写作格式的定义，不修改 new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format #时间格式不用修改 ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination #每页显示文章数，可以自行定义 ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page # Extensions #配置站点时，所使用的主题和插件，切换主题可以在这里设置 ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next //在这里切换主题 # theme: landscape # 头像， 在xxx.github.io/source 下相对路径，若source文件夹下没有uploads，就新建一个名为uploads文件夹，具体见下面截图 avatar: /uploads/images/avatar.png # Deployment #这里是部署到Github上的设置 ## Docs: https://hexo.io/docs/deployment.html deploy: type: git #git提交 repo: https://github.com/123sunxiaolin/123sunxiaolin.github.io.git #已创建的Github仓库 branch: master #提交到的分支 如果报错: ERROR Deployer not found: git npm install –save hexo-deployer-git 部署 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 打包的项目在public中]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>构建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中自定义指令]]></title>
    <url>%2F2018%2F06%2F11%2Fvue%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[12345678// 注册一个全局自定义指令 `v-focus`Vue.directive('focus', &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 1&lt;input v-focus&gt; 这里举一个高深的例子 1&lt;div id="hook-arguments-example" v-demo:foo.a.b="message"&gt;&lt;/div&gt; 12345678910111213141516171819Vue.directive('demo', &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') &#125;&#125;)new Vue(&#123; el: '#hook-arguments-example', data: &#123; message: 'hello!' &#125;&#125;) 简写模式 1234Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 接收数据 1&lt;div v-demo="&#123; color: 'white', text: 'hello!' &#125;"&gt;&lt;/div&gt; 1234Vue.directive('demo', function (el, binding) &#123; console.log(binding.value.color) // =&gt; "white" console.log(binding.value.text) // =&gt; "hello!"&#125;)]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eslint语法解决]]></title>
    <url>%2F2018%2F06%2F11%2Feslint%E8%AF%AD%E6%B3%95%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[12345678910111213141516在webpack.base.conf.js里面删掉下面:preLoaders: [ &#123; test: /\.vue$/, loader: 'eslint', include: projectRoot, exclude: [/node_modules/, /ignore_lib/] &#125;, &#123; test: /\.js$/, loader: 'eslint', include: projectRoot, exclude: [/node_modules/, /ignore_lib/] &#125; ] 1234567891011删除以下代码就可以&#123; test: /\.(js|vue)$/, loader: 'eslint-loader', enforce: 'pre', include: [resolve('src'), resolve('test')], options: &#123; formatter: require('eslint-friendly-formatter') &#125; 然后需要重新编辑生效]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3基础语法]]></title>
    <url>%2F2018%2F06%2F11%2FPython3%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[条件判断1234567age = 3if age &gt;= 18: print('adult')elif age &gt;= 6: print('teenager')else: print('kid') 循环语句123for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + xprint(sum) 123456sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) 1234567n = 1while n &lt;= 100: if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1print('END') 123456n = 0while n &lt; 10: n = n + 1 if n % 2 == 0: # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print(n) dict(字典)12d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;d['Michael'] get()12d.get("Michael");#key不存在返回None，或者自己指定的value pop(key)123d.pop('Bob')# 要删除一个key，用pop(key)方法，对应的value也会从dict中删除： 请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。 和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是用空间来换取时间的一种方法。 dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。 这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。 要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key set set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 123&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125; add(key) 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果： 123456&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125; remove(key) 通过remove(key)方法可以删除元素： 123&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s&#123;1, 2, 3&#125; set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： 123456&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125; set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。 数据类型转换int()函数可以把其他数据类型转换为整数1234567891011121314&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float('12.34')12.34&gt;&gt;&gt; str(1.23)'1.23'&gt;&gt;&gt; str(100)'100'&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool('')False]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python2.7执行excel]]></title>
    <url>%2F2018%2F06%2F11%2Fpython2.7%E6%89%A7%E8%A1%8Cexcel%2F</url>
    <content type="text"><![CDATA[安装xlrd、xlwt、xlutilsxlrd：是python从excel读数据的第三方控件；xlwt：是python从excel写数据的第三方控件；xlutils：是python使用xlrd、xlwt的工具箱。若安装不成功，可能原因是需要安装setuptools。 [root@vm4 python]# pip install xlrd [root@vm4 python]# pip install xlwt [root@vm4 python]# pip install xlutils]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 函数]]></title>
    <url>%2F2018%2F06%2F11%2Fpython%20%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[定义函数12345def my_abs(x): if x &gt;= 0: return x else: return -x 调用函数1my_abs(-99) 函数的参数默认参数123456def enroll(name, gender, age=6, city='Beijing'): print('name:', name) print('gender:', gender) print('age:', age) print('city:', city) 递归函数1234def fact(n): if n==1: return 1 return n * fact(n - 1)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用富文本编辑器]]></title>
    <url>%2F2018%2F06%2F11%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[安装 cnpm install vue-quill-editor –save 引入 import { quillEditor } from ‘vue-quill-editor’]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python高级特性]]></title>
    <url>%2F2018%2F06%2F11%2Fpython%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[切片12345678910L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']# 取前三个元素r = []n = 3for i in range(n): r.append(L[i]) # &gt;&gt;&gt; r# ['Michael', 'Sarah', 'Tracy'] 也可以用一行代码实现 123456789101112131415161718192021222324&gt;&gt;&gt; L[0:3]['Michael', 'Sarah', 'Tracy']# 0 也可以省略&gt;&gt;&gt; L[:3]['Michael', 'Sarah', 'Tracy']# 也可以从索引1开始&gt;&gt;&gt; L[1:3]['Sarah', 'Tracy']# 也可以倒着取&gt;&gt;&gt; L[-2:]['Bob', 'Jack']&gt;&gt;&gt; L[-2:-1]['Bob']# 每五个取一个&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]# 也可以隔着取，每两个取一个&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8] 注：字符串也可以看成一种list 迭代123456&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:... print(x, y)...1 12 43 9 列表生成式12345678910111213141516&gt;&gt;&gt; list(range(1, 11))[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# 生成[1x1, 2x2, 3x3, ..., 10x10]&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)...&gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]# 上面的简写&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]#还可以这么写&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 生成器(generator)12345678&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;# 可以通过next()函数获得generator的下一个返回值 generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。 当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象： 1234567891011121314&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; for n in g:... print(n)... 0149162536496481 断点》》》》》》》》》》》》》》》》》]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用sass]]></title>
    <url>%2F2018%2F06%2F11%2Fvue%E4%B8%AD%E4%BD%BF%E7%94%A8sass%2F</url>
    <content type="text"><![CDATA[安装12npm install node-sass --save-devnpm install sass-loader --save-dev 配置 打开webpack.base.config.js在loaders里面加上 module – rules 123456789101112131415161718192021222324252627282930313233rules: [ &#123; test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; test: /\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test')] &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', query: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.scss$/, loaders: ["style", "css", "sass"] &#125;,//这里这里看这里，主要引入这一段 &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', query: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中操作DOM]]></title>
    <url>%2F2018%2F06%2F11%2Fvue%E4%B8%AD%E6%93%8D%E4%BD%9CDOM%2F</url>
    <content type="text"><![CDATA[方案1 可以在mounted中挂载12345mounted:function()&#123; this.$nextTick(function()&#123; //this.$nextTick是在下次DOM更新循环结束时调用延迟回调函数。异步函数 this.loadData(); //DOM加载就绪，后调用loadData方法进行数据更新&lt;br&gt; //想要更新后的获取dom //此时若获取更新后dom数据将会报错，数据为undefined； &#125;) &#125; 方案2123456789101112if(document.addEventListener)&#123; document.addEventListener('DOMMouseScroll',()=&gt;&#123; &#125;,false); &#125;//W3C window.onmousewheel=document.onmousewheel=()=&gt;&#123; let top = document.getElementById("bottoms").scrollTop; console.log(top); this.$refs.add.style.marginTop = top + 10 + "px"; // document.getElementById("rights").style.marginTop = top+"px"; console.log(this.$refs.add.style); &#125;;//IE/Opera/Chrome]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动补全私有前缀]]></title>
    <url>%2F2018%2F06%2F11%2F%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E7%A7%81%E6%9C%89%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[vue-cli 生成的项目里样式插件是自动插入的， 在 build/utils.js 里 autoprefixer 配置在 .postcssrc.js]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[element-ui]]></title>
    <url>%2F2018%2F06%2F11%2Felement-ui%2F</url>
    <content type="text"><![CDATA[安装1cnpm i element-ui --save 引入 在main.js 中 123456789101112import Vue from 'vue'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import App from './App.vue'Vue.use(ElementUI)new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;) 使用菜单导航123456&lt;el-menu :router="true" :default-active="$route.path" class="el-menu-demo" mode="horizontal" @select="handleSelect"&gt; &lt;el-menu-item index="/table"&gt;表格&lt;/el-menu-item&gt; &lt;el-menu-item index="/form"&gt;表单&lt;/el-menu-item&gt; &lt;el-menu-item index="/graph"&gt;图形&lt;/el-menu-item&gt; &lt;/el-menu&gt; index里面添加路由， router是使用路由模式为true 但是还会发现一个新的问题，它不默认选中了，所以这里要修改一下 12345&lt;el-menu :router="true" :default-active="$route.path" class="el-menu-demo" mode="horizontal" @select="handleSelect"&gt; &lt;el-menu-item index="/table"&gt;表格&lt;/el-menu-item&gt; &lt;el-menu-item index="/form"&gt;表单&lt;/el-menu-item&gt; &lt;el-menu-item index="/graph"&gt;图形&lt;/el-menu-item&gt; &lt;/el-menu&gt; elementUI关于树状图的增删改查，局部刷新问题链接在这里 elementUI关于tree的使用getCheckedKeys不能获取父节点的key]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue全局拦截前端错误（前端异常监控系统+ng4）]]></title>
    <url>%2F2018%2F06%2F11%2Fvue%E5%85%A8%E5%B1%80%E6%8B%A6%E6%88%AA%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%EF%BC%88%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%2Bng4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[errorHandler 一般来讲，前端的异常处理使用的是try catch 和window.onerror 但是在框架中就不可以了，三大前端框架只有react可以这么使用，vue中有自己的errorHandler，ng也有自己的属性可以这么用 这里面我们用errorHandler来进行错误拦截 12345Vue.config.errorHandler = function (err, vm, info) &#123; // handle error // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 // 只在 2.2.0+ 可用&#125; 123456789101112131415161718//具体报错信息ReferenceError: i is not defined //err at VueComponent.created (bigdata.vue?1536:26) at callHook (vue.esm.js?5425:2895) at VueComponent.Vue._init (vue.esm.js?5425:4560) at new VueComponent (vue.esm.js?5425:4728) at createComponentInstanceForVnode (vue.esm.js?5425:4242) at init (vue.esm.js?5425:4059) at createComponent (vue.esm.js?5425:5512) at createElm (vue.esm.js?5425:5460) at createChildren (vue.esm.js?5425:5586) at createElm (vue.esm.js?5425:5488)VueComponent &#123;_uid: 4, _isVue: true, $options: &#123;…&#125;, //vm _renderProxy: Proxy, _self: VueComponent, …&#125;created hook //info vue2.0参考这里 ng4参考这里 接口形式同埋点上传（利用一个gif的形式传递数据）这是我以前写的关于如何进行埋点上传的文章(代码不是我写的)]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的路由（route）]]></title>
    <url>%2F2018%2F06%2F11%2Fvue%E7%9A%84%E8%B7%AF%E7%94%B1%EF%BC%88route%EF%BC%89%2F</url>
    <content type="text"><![CDATA[vue的路由 注意： component后面的值不要有引号，父级不要有名字name属性 12345678910111213141516[ &#123; path: '/', component: Bigdata, children: [ &#123; path: '', redirect: &#123; name: 'Table' &#125; &#125;,&#123; path: 'table', name: 'Table' , component: Table &#125; ] &#125; ]]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反向代理+axios]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2Baxios%2F</url>
    <content type="text"><![CDATA[反向代理 代理有两种一种是正向代理，一种是反向代理，正向代理代理的书客户端，反向代理代理的是服务端。 听过一个有意思的解释，凶手&gt;&gt; 毛利叔叔 &gt;&gt; 柯南，这里面毛利叔叔就是反向代理。也就是说真正的服务端是不可见的。]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue中使用Echarts（vue）]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8Echarts%EF%BC%88vue%EF%BC%89%2F</url>
    <content type="text"><![CDATA[安装 cnpm install echarts –save 引入 import echarts from ‘echarts’ Vue.prototype.$echarts = echarts]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目移植报错]]></title>
    <url>%2F2018%2F06%2F11%2Fvue%E9%A1%B9%E7%9B%AE%E7%A7%BB%E6%A4%8D%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[按照这个文章解决的 npm intall sass-loader –save; npm install node-sass –save; 然后运行npm run start就可以 关于vueTreeDrag这个项目vueTreeDrag 使用的node版本是v8.8.1 删除当前的node_modules 然后cnpm i重新下载]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue中使用less]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8less%2F</url>
    <content type="text"><![CDATA[安装 cnpm install less less-loader –save 在webpack.base.config.js在loaders里面加上 12345678&#123;test: /\.less$/,loader: "style-loader!css-loader!less-loader",&#125;,]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速构建vue项目（vue-cli）]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAvue%E9%A1%B9%E7%9B%AE%EF%BC%88vue-cli%EF%BC%89%2F</url>
    <content type="text"><![CDATA[全局安装1npm i -g vue-cli 创建项目(项目名称叫muses)1vue init webpack muses 启动(默认的是80端)1npm run dev 详细讲解 与ng4 的cli 不同 ，vue的cli比较复杂 ，但是实际上只要一直回车对后面没有影响，注意最后一项要选择npm的那个选项 build文件里面是一些操作文件,执行 npm run * 时执行的就是这里的文件 config 文件是配置文件 src 是资源文件，组件等都放在这里 assets 资源文件，同ng4 类似，放的是公共的资源，例如图片 打包1npm run build 注意 如果你是用的编辑器是webstorm 那么需要在setting中的Language选项里面的JavaScript设置为ECMAScript 6，这样才可以使用，如果还有问题，那么需要在script标签中标注type为es6]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue中创建局部组件]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%9C%A8vue%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在main.js中写入12import sideBar from './components/public/sideBar.vue';Vue.component('side-bar', sideBar); 在使用的时候直接写入]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex（关于vue的状态管理模式）]]></title>
    <url>%2F2018%2F06%2F11%2FVuex%EF%BC%88%E5%85%B3%E4%BA%8Evue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[介绍vuex vuex是一个为了vue开发的状态管理模式，它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化， 这篇文章不错 状态管理模式123456789101112131415161718new Vue(&#123; // state data () &#123; return &#123; count: 0 &#125; &#125;, // view template: ` &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; `, // actions methods: &#123; increment () &#123; this.count++ &#125; &#125;&#125;) 如上所示 state为驱动应用的数据源，view以声明的方式将state映射到视图，actions为响应在view上的用户输入导致的状态变化 单向数据流 1234graph LR; Actions--&gt;State; State--&gt;View; View--&gt;Actions; 如上所示为单向数据流，但是当我们有多个组件共享状态时，单向数据流的简洁性很容易被破坏。 这时会有两个需求多个视图依赖于同一状态，来自不同视图的行为需要变更同一状态。 为了方便我们把组件的共享状态抽取出来，以一个全局单例模式管理（Vuex） 安装1npm i vuex --save 引入1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 使用]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在vue中引入jquery]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%A6%82%E4%BD%95%E5%9C%A8vue%E4%B8%AD%E5%BC%95%E5%85%A5jquery%2F</url>
    <content type="text"><![CDATA[安装 在package.json里的dependencies加入”jquery” : “^2.2.3”，然后install 或者直接安装也可以 12345678910111213141516在webpack.base.conf.js里加入var webpack = require("webpack")在module.exports的最后加入plugins: [new webpack.ProvidePlugin(&#123;jQuery: "jquery",$: "jquery"&#125;)]然后一定要重新 run dev在main.js 引入就ok了import $ from 'jquery']]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可维护性代码]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[可维护性代码有一些特征 可理解性： 其他人接手代码并理解它的意图和一般途径，而无需原开发人员的完整解释 直观性： 代码中的东西一看就能明白，不管其操作过程多么复杂 可适应性： 代码以一种数据上的变化不要求完全重写的方法撰写 可扩展性： 在代码架构上已考虑到在未来允许对核心功能进行扩展 可调试性： 当有地方出错时，代码可以给与你足够的信息来进可能直接确定问题所在]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程]]></title>
    <url>%2F2018%2F06%2F10%2F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[尊重对象所有权 避免全局变量 避免与null进行比较 12345678910111213function sortSArray(values)&#123; if(values != null)&#123; //这是不可取的 &#125;&#125;//修改function sortArray(values)&#123; if(values instanceof Array)&#123; //这是可取的 &#125;&#125; 使用常量 123456789101112var time = &#123; time1: 12, time2: 13&#125;console.log(time.time1);console.log(time.time2);//而不是使用console.log(12);console.log(13);//关键在于重复值，用户界面字符串，URLs，任意可能会更改的值 避免全局查找（document等等）]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码规范]]></title>
    <url>%2F2018%2F06%2F10%2F%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617SUCCESS: 0, URL_INVALID: 1001, //请求地址无效 AUTH_FAIL: 1002, //鉴权失败 NO_PERMISSION: 1003, //无此权限 PARAM_INVALID: 1004, //参数无效 SMS_SEND_FAIL: 1005, //短信发送失败 ACT_CODE_INVALID: 1006, //验证码无效 ACCOUNT_INVALID: 1007, //帐号或密码错误 SESSION_TIMEOUT: 1009, //未登录或登录超时 DATA_EXIST: 1011, //数据已存在 DATA_INEXIST: 1012, //数据不存在 DATA_INEXIST_ON_CURR_CONDITIONS: 1013, //当前条件下数据不存在 DB_OPER: 9001, //数据库操作异常 DB_CONN: 9002, //数据库连接异常 UNKNOW: 9999 //未知异常]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2018%2F06%2F09%2Fredis%2F</url>
    <content type="text"><![CDATA[下载需要下载一个redis，或者是连接的那个服务器有redis cnpm i redis 我的本机安装目录C:\Program Files\Redis 执行：redis-server.exe 1234567891011121314151617//使用redis，用来缓存数据const redis = require('redis');const client = redis.createClient(&#123;host:'192.168.14.6', port: 6379,no_ready_check:true&#125;);client.on("error", function (err) &#123; console.log("redis client连接失败",err);&#125;);client.on('ready', function (res) &#123; console.log('client ready');&#125;);client.on('connect', function () &#123; client.set("var_2", "var_2_val", function () &#123; var read_var_2=client.get("var_2"); console.log("第二次读取到的值："+read_var_2); &#125;); client.quit();&#125;); 这个里面设置了过期时间使用的redis.expire12345678910router.get('/', function (ctx, next) &#123; let render = null; render = tableData.tableData(tableJson); render.count = render.data.length; render.num = 10; redis.set('var_2', JSON.stringify(render)); redis.expire('var_2', 300); render.data = render.data.slice(0,9); ctx.body = render;&#125;);]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
