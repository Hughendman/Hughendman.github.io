<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[开发流程]]></title>
    <url>%2Fpost%2F56b47d41.html</url>
    <content type="text"><![CDATA[发现现在的项目开发流程有好多问题。我从网上找了几篇文章，总结一些，关于如何更加高效率、高产出、高效益的方法 web应用开发标准流程（来自慕课网Python_Quant）1234567891011121314151617181920graph LRweb应用开发标准流程--&gt;产品分析产品分析--&gt;用户需求产品分析--&gt;竞品分析产品分析--&gt;市场调研web应用开发标准流程--&gt;技术选型技术选型--&gt;前端技术选型技术选型--&gt;后端技术选型技术选型--&gt;数据库技术选型--&gt;业务框架hadoop等web应用开发标准流程--&gt;开发实现开发实现--&gt;前后端开发开发实现--&gt;前后端部署开发实现--&gt;前后端升级开发实现--&gt;业务框架大数据展现web应用开发标准流程--&gt;生产上线生产上线--&gt;部署升级生产上线--&gt;峰值处理生产上线--&gt;成本优化生产上线--&gt;警报处理 敏捷开发（阿里-何勉-阿里技术）敏捷开发业务目标这里提交一个概念-瀑布开发（需求批量地在一起进行设计，然后是批量地开发，批量地测试、交付等等。批量让价值交付延迟，所有需求在最后的阶段才能交付，价值交付比较晚。越迟交付的价值也是越低的价值）。与之相对的就是敏捷开发 从业务视角看敏捷的目标更快（早）的交付价值更快（早）的交付价值。所以敏捷开发的第一个目标就是更快的交付价值（更早的交付）。敏捷提出了迭代交付。我们把开发分成迭代，每个迭代交付一部分价值，更早交付的价值往往意味着更多的价值。 有效学习和灵活响应变化面对不确定的技术、市场环境，传统开发模式（项目中的大部分决策在项目开始的时刻做出）已无法适应要求，敏捷的对策是迭代。开始时做一些初始的决策，只是定义了大致的方向。在整个开发过程，我们迭代交付需求，获取市场的反馈和最新的信息，并基于这些反馈和信息，积累和修正对产品的认知，增量地决策和调整。 从能力角度敏捷的核心是持续交付价值的能力，以及持续交付为基础的快速反馈学习能力 度量：123456789101112131415graph LR持续交付能力--&gt;持续发布能力持续发布能力--&gt;发布频率持续发布能力--&gt;发布前置时间持续交付能力--&gt;需求响应周期需求响应周期--&gt;客户周期时间需求响应周期--&gt;开发周期时间持续交付能力--&gt;交付吞吐率交付吞吐率--&gt;单位时间交付用户需求数量持续交付能力--&gt;内建质量能力内建质量能力--&gt;缺陷创建和修复时间分布内建质量能力--&gt;缺陷库存持续交付能力--&gt;交付质量交付质量--&gt;单位时间问题数目交付质量--&gt;线上问题解决时长 上面5组指标，分别从响应能力、效率和质量三个方面提供一个完整的故事。其中，持续发布能力和需求响应周期这两组指标反映的是响应能力，也就是价值的流动效率；交付吞吐率这一指标反映的是团队效率，也就是资源的产出效率；内建质量的能力和对外交付质量这两组指标是质量指标。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探索superset源码（深度汉化）]]></title>
    <url>%2Fpost%2Fdd3da07a.html</url>
    <content type="text"><![CDATA[如何开发使用虚拟环境12345678910111213141516171819202122232425262728pip install virtualenvvirtualenv -p python3 venvcd venv/Scripts.\activatepip install supersetpip install "markdown&lt;3.0.0" superset# Create an admin user (you will be prompted to set username, first and last name before setting a password)fabmanager create-admin --app supersetcd venv/Scripts# Initialize the databasepython superset db upgrade# Load some data to play withpython superset load_examples# Create default roles and permissionspython superset init# To start a development web server on port 8088, use -p to bind to another portpython superset runserver -d 导入 venv\Lib\site-packages\superset 进行开发 配置数据库切换mysql1SQLALCHEMY_DATABASE_URI = 'mysql://root:abcd234@localhost/superset?Charset=utf8' sqlite数据库位置 1~/.superset/superset.db 默认中文config.py1BABEL_DEFAULT_LOCALE = 'zh' 前端超时1SUPERSET_WEBSERVER_TIMEOUT = 60 # deprecated 密钥1SECRET_KEY = '\2\1thisismyscretkey\1\2\e\y\y\h' # noqa 前端代码前端使用react + redux 打包入口1superset/static/assets/webpack.config.js 打包1superset/static/assets 安装依赖 123cnpm install -g webpackcnpm install -g yarnyarn install 测试 1npm run dev 打包 1npm run prod 注：window下会报错：NODE_ENV不是内部或外部命令,也不是可运行的程序 1234yarn add cross-env --devcross-env NODE_ENV=xxxxxxx 深度汉化后台py文件汉化12cd translations\zh\LC_MESSAGES修改messages.po文件 1pybabel compile -d translations 后台修改完成 前台react汉化12cd translations\zh\LC_MESSAGES修改messages.json文件 将其放在初始化的位置 注意：旧版本的react和新版本的react目录结构不同 旧版本：\superset\assets\javascript 新版本：\superset\static\assets\src 修改\superset\static\assets\src\i18n.jsx 123import Jed from 'jed';const DEFAULT_LANGUAGE_PACK = "替换这个值" 打包1npm run build 深度汉化git深度汉化git-点击]]></content>
      <categories>
        <category>superset</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>superset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟环境的使用(5)]]></title>
    <url>%2Fpost%2F4ed14714.html</url>
    <content type="text"><![CDATA[安装123456pip install virtualenvmkdir virtualenvcd virtualenvvirtualenv venv 创建虚拟环境指定解释器123virtualenv -p python3 venvvirtualenv -p python2 venv 激活虚拟环境12cd venv/Scripts.\activate Win10下提示权限错误。错误信息：.\activate : 无法加载文件 H:\envproject\venv\Scripts\activate.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。所在位置 行:1 字符: 1解决办法：1.以管理员身份打开PowerShell2.执行命令set-executionpolicy remotesigned 退出1deactivate]]></content>
      <categories>
        <category>flask</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask appbuilder的使用(4)]]></title>
    <url>%2Fpost%2F93fb4cf0.html</url>
    <content type="text"><![CDATA[介绍简单快速的应用开发框架，构建在Flask之上。包括详细的安全，自动CRUD生成模型，谷歌图表等等。广泛的配置，所有功能，易于集成与Flask/Jinja2开发。 依赖12345678flaskclickcoloramaflask-sqlalchemyflask-loginflask-openidflask-wtformflask-Babel 安装1pip install Flask-AppBuilder 使用快速构建项目1fabmanager create-app 然后继续往下输出 创建管理用户1fabmanager create-admin 运行脚本1fabmanager run 或者 1python run.py 端口号修改run.py 1app.run(host='0.0.0.0', port=8080, debug=True) 修改port 后 执行python run.py(只适用这种方式执行) 基本配置数据库配置config.py 1234SQLALCHEMY_DATABASE_URI = 'sqlite:///' + os.path.join(basedir, 'app.db')#SQLALCHEMY_DATABASE_URI = 'mysql://myapp@localhost/myapp'#SQLALCHEMY_DATABASE_URI = 'postgresql://root:password@localhost/myapp' 目录结构1234567| - projectName | - app | - babel | - app.db | - config.py | - README.rst | - run.py app目录下存放我们Web应用的相关脚本文件 babel存放国际化相关配置和导出的翻译字符串 根目录下则存放着Web应用的配置脚本和主脚本文件 修改名字config.py 1APP_NAME = "My App Name" 主题配置config.py 12345678910111213#APP_THEME = "bootstrap-theme.css" # default bootstrap#APP_THEME = "cerulean.css"#APP_THEME = "amelia.css"#APP_THEME = "cosmo.css"#APP_THEME = "cyborg.css" #APP_THEME = "flatly.css"#APP_THEME = "journal.css"#APP_THEME = "readable.css"#APP_THEME = "simplex.css"#APP_THEME = "slate.css" #APP_THEME = "spacelab.css"#APP_THEME = "united.css"#APP_THEME = "yeti.css" 修改首页app/index.py 123from flask_appbuilder import IndexViewclass MyIndexView(IndexView): index_template = 'new_index.html' templates/new_index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello appbuilder&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; app/iniy.py指定indexview的值 12from app.index import MyIndexViewappbuilder = AppBuilder(app, db.session, indexview=MyIndexView) BaseViewapp/views.py 12345678from flask_appbuilder import AppBuilder,expose,BaseViewclass indexView(BaseView): # 相对路径的url route_base = '/index' @expose('/hello') def hello(self): return 'Hello World'appbuilder.add_view_no_menu(indexView()) 添加权限@has_access必须登录 123456789101112from flask_appbuilder import ModelView,AppBuilder,expose,BaseView,has_accessclass indexView(BaseView): route_base = '/index' @expose('/hello') def hello(self): return 'Hello World' @expose('/message/&lt;string:msg&gt;') @has_access def message(self,msg): msg = 'Hello' + msg return msgappbuilder.add_view_no_menu(indexView()) 添加视图到菜单app/templates/index.html123456&#123;% extends "appbuilder/base.html" %&#125;&#123;% block content %&#125; &lt;h1&gt;Welcome&lt;/h1&gt; &lt;h2&gt;Hello World&lt;/h2&gt; &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt;&#123;% endblock %&#125; app/views.py 123456789101112131415class indexView(BaseView): route_base = '/index' default_view = 'hello' @expose('/hello') def hello(self): return 'Hello World' @expose('/message/&lt;string:msg&gt;') @has_access def message(self,msg): msg = 'Hello ' + msg return self.render_template('index.html',msg=msg)# 在菜单中生成访问的链接appbuilder.add_view(indexView,'Hello',category='My View')appbuilder.add_link('message',href='/index/message/user',category='My View')appbuilder.add_link('welcome',href='/index/hello',category='My View') ModelViewapp/models.py 12345678910111213141516171819202122232425from sqlalchemy import Column, Integer, String, ForeignKey, Datefrom sqlalchemy.orm import relationshipfrom flask_appbuilder import Model class ContactGroup(Model): id = Column(Integer, primary_key=True) name = Column(String(50), unique=True, nullable=False) def __repr__(self): return self.nameclass Contact(Model): id = Column(Integer, primary_key=True) name = Column(String(150), unique=True, nullable=False) address = Column(String(564)) birthday = Column(Date) personal_phone = Column(String(20)) personal_cellphone = Column(String(20)) contact_group_id = Column(Integer, ForeignKey('contact_group.id')) contact_group = relationship("ContactGroup") def __repr__(self): return self.name app/views.py 123456789101112131415161718192021222324252627282930313233343536373839from flask_appbuilder import ModelViewfrom flask_appbuilder.models.sqla.interface import SQLAInterfacefrom .models import ContactGroup, Contactfrom app import appbuilder, db class ContactModelView(ModelView): datamodel = SQLAInterface(Contact) label_columns = &#123;'contact_group':'Contacts Group'&#125; list_columns = ['name','personal_cellphone','birthday','contact_group'] show_fieldsets = [ ( 'Summary', &#123;'fields':['name','address','contact_group']&#125; ), ( 'Personal Info', &#123;'fields':['birthday','personal_phone','personal_cellphone'],'expanded':False&#125; ), ]# 在联系人组视图中，我们使用related_views来关联联系人视图，F.A.B.将自动处理他们之间的关系。class GroupModelView(ModelView): datamodel = SQLAInterface(ContactGroup) related_views = [ContactModelView] # 现在我们就差最后一步工作就要完成本次实验了。# 首先使用db.create_all()根据数据库模型创建表，然后再将视图添加到菜单。 db.create_all()appbuilder.add_view(GroupModelView, "List Groups", icon = "fa-address-book-o", category = "Contacts", category_icon = "fa-envelope")appbuilder.add_view(ContactModelView, "List Contacts", icon = "fa-address-card-o", category = "Contacts") 参考Flask-AppBuilder教程 利用Flask-AppBuilder 快速构建Web后台管理应用]]></content>
      <categories>
        <category>flask</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask插件（3）]]></title>
    <url>%2Fpost%2Fd70bcc7a.html</url>
    <content type="text"><![CDATA[Flask-appbuilder介绍简单快速的应用开发框架，构建在Flask之上。包括详细的安全，自动CRUD生成您的模型。 安装1pip install flask-appbuilder Flask-login介绍Flask- login为Flask提供用户会话管理。它处理登录、注销和在较长时间内记住用户会话的常见任务。 安装1pip install flask-login Flask-sqlalchemy介绍向flask应用程序添加SQLAlchemy支持。 安装1pip install Flask-SQLAlchemy flask-openid介绍Adds OpenID support to Flask. 安装1pip install Flask-OpenID flask-babel介绍Adds i18n/l10n support to Flask applications with the help of the Babel library. 安装1pip install Flask-Babel Flask-WTF介绍Flask和WTForms的简单集成，包括CSRF、文件上传和reCAPTCHA。 安装1pip install Flask-WTF flask-Script介绍终端运行解析器 安装1pip install flask-script 使用123456789from flask_script import Managerfrom flask import Flaskapp = Flask(__name__)manager = Manager(app)# 启动实例if __name__ == '__main__': manager.run() 运行 12python manage.py runserverpython manage.py runserver -d -r --thread 启动参数123456-?,--help # 查看启动设置帮助 -h,--host # 指定主机 -p,--port # 指定端口 --thread # 启动多线程 -d # 开启调试模式 -r # 代码修改后自动加载 flask-bootstrap介绍bootstrap 是twitter开发的一个开源框架，在程序中集成bootstrap就要用的这个插件flask-bootstrap 安装1pip install flask_bootstrap 使用12from flask.ext.bootstrap import Bootstrapbootstrap = Bootstrap(app) 123456789101112131415161718192021222324252627282930313233&#123;%extends "bootstrap/base.html"%&#125;&#123;%block title %&#125;Flask&#123;% endblock %&#125;&#123;%block navbar %&#125;&lt;div class="navbar navbar-inverse" role="navigation"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="/"&gt;Flasky&lt;/a&gt; &lt;/div&gt; &lt;div class="navbar-collapse collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li&gt;&lt;a href="/"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125;&#123;% block content %&#125;&lt;div class="container"&gt; &lt;div class="page-header"&gt; &lt;h1&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/h1&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endblock %&#125; Flask-Mail介绍安装1pip install flask-mail Flask-Moment介绍本地化时间 安装12pip install flask-moment 使用123456789101112# 导入类库 from flask_moment import Moment from datetime import datetime, timedelta # 创建对象 moment = Moment(app) @app.route('/moment/') def mom(): current_time = datetime.utcnow() + timedelta(seconds=-3600) return render_template('moment.html', current_time=current_time) 1234567891011121314151617181920&#123;# 简单的格式化显示 #&#125; &lt;div&gt;时间：&#123;&#123; moment(current_time).format('LLLL') &#125;&#125;&lt;/div&gt; &lt;div&gt;时间：&#123;&#123; moment(current_time).format('LLL') &#125;&#125;&lt;/div&gt; &lt;div&gt;时间：&#123;&#123; moment(current_time).format('LL') &#125;&#125;&lt;/div&gt; &lt;div&gt;时间：&#123;&#123; moment(current_time).format('L') &#125;&#125;&lt;/div&gt; &#123;# 自定义格式化显示 #&#125; &lt;div&gt;自定义显示：&#123;&#123; moment(current_time).format('YYYY-MM-DD') &#125;&#125;&lt;/div&gt; &#123;# 时间差值显示 #&#125; &lt;div&gt;发表于：&#123;&#123; moment(current_time).fromNow() &#125;&#125;&lt;/div&gt; &#123;# 加载jQuery，因为moment.js依赖，使用bootstrap时可以省略 #&#125; &#123;&#123; moment.include_jquery() &#125;&#125; &#123;# 加载moment.js #&#125; &#123;&#123; moment.include_moment() &#125;&#125; &#123;# 设置中文显示 #&#125; &#123;&#123; moment.locale('zh-CN') &#125;&#125; Flask-Uploads介绍上传文件 安装1pip install flask-uploads 自动生成依赖包1pip freeze &gt; requirements.txt 安装依赖包1pip install -r Requirements.txt 没有使用方法的插件将在其他文档中说明参考Flask常用扩展]]></content>
      <categories>
        <category>flask</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask连接数据库(2)]]></title>
    <url>%2Fpost%2Fb65ff4ad.html</url>
    <content type="text"><![CDATA[数据库类型 数据库 命令 MySQL pip install PyMySQL Postgres pip install psycopg2 Presto pip install pyhive Oracle pip install cx_Oracle sqlite 短文本 Redshift pip install sqlalchemy-redshift MSSQL pip install pymssql Impala pip install impyla SparkSQL pip install pyhive mysqlpip install PyMySQL 1234567891011121314151617181920#!/usr/bin/python3 import pymysql # 打开数据库连接db = pymysql.connect("localhost","testuser","test123","TESTDB" ) # 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor() # 使用 execute() 方法执行 SQL 查询 cursor.execute("SELECT VERSION()") # 使用 fetchone() 方法获取单条数据.data = cursor.fetchone() print ("Database version : %s " % data) # 关闭数据库连接db.close() 插入1234567891011121314151617181920212223242526#!/usr/bin/python3 import pymysql # 打开数据库连接db = pymysql.connect("localhost","testuser","test123","TESTDB" ) # 使用cursor()方法获取操作游标 cursor = db.cursor() # SQL 插入语句sql = """INSERT INTO EMPLOYEE(FIRST_NAME, LAST_NAME, AGE, SEX, INCOME) VALUES ('Mac', 'Mohan', 20, 'M', 2000)"""try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # 如果发生错误则回滚 db.rollback() # 关闭数据库连接db.close() 查询 1234567891011121314151617181920212223242526272829303132#!/usr/bin/python3 import pymysql # 打开数据库连接db = pymysql.connect("localhost","testuser","test123","TESTDB" ) # 使用cursor()方法获取操作游标 cursor = db.cursor() # SQL 查询语句sql = "SELECT * FROM EMPLOYEE \ WHERE INCOME &gt; '%d'" % (1000)try: # 执行SQL语句 cursor.execute(sql) # 获取所有记录列表 results = cursor.fetchall() for row in results: fname = row[0] lname = row[1] age = row[2] sex = row[3] income = row[4] # 打印结果 print ("fname=%s,lname=%s,age=%d,sex=%s,income=%d" % \ (fname, lname, age, sex, income ))except: print ("Error: unable to fetch data") # 关闭数据库连接db.close() Postgres123456789101112import psycopg2import psycopg2.extrasconn = psycopg2.connect(host=’localhost’, port=port, user=’root’, password=’abcd234’, database=’database’)cursor = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)#执行SQL脚本 cursor.execute(‘SELECT * FROM test WHERE id &gt; %s;’, (5,)) #查看生成的sql脚本cursor.mogrify(‘SELECT * FROM test WHERE a = %s AND b = %s;’, (‘a’, ‘b’))#插入数据cursor.execute(‘INSERT INTO test (a, b) VALUES (%s, %s) RETURNING id;’, (‘a’, ‘b’))item = cursor.fetchone()print item[0] #这里就是刚才插入的记录的ID flask-sqlalchemyFlask拥有丰富的扩展组件，数据库管理方面Flask-SQLAlchemy简化了数据库管理的操作 1pip install flask-sqlalchemy 在以后的文章中我还会继续介绍]]></content>
      <categories>
        <category>flask</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask搭建REST应用(1)]]></title>
    <url>%2Fpost%2Fadd72f50.html</url>
    <content type="text"><![CDATA[安装1py -3 -m pip install flask 第一个服务first.py123456789from flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run(host='0.0.0.0', port=9033, debug=True) 执行： python3 first.py 注： host=’0.0.0.0’是为了让操作系统监听所有公网 IP，port为监听的端口号，debug启用调试模式注意，他们是可以分开的,在生产环境中不要使用 变量规则给URL添加变量 12345678910@app.route('/user/&lt;username&gt;')def show_user_profile(username): # show the user profile for that user return 'User %s' % username@app.route('/post/&lt;int:post_id&gt;')def show_post(post_id): # show the post with the given id, the id is an integer return 'Post %d' % post_id HTTP请求方式默认为get方式1from flask import Flask,request 12345def do_the_login(): return 'do_the_login'def show_the_login_form(): return 'show_the_login_form' 123456@app.route('/login', methods=['GET', 'POST'])def login(): if request.method == 'POST': return do_the_login() else: return show_the_login_form() 静态文件1from flask import render_template 1234@app.route('/hello/')@app.route('/hello/&lt;name&gt;')def hello(name=None): return render_template('hello.html', name=name) Flask 会在 templates 文件夹里寻找模板。所以，如果你的应用是个模块，这个文件夹应该与模块同级；如果它是一个包，那么这个文件夹作为包的子目录 模板引擎采用jinja21234567&lt;!doctype html&gt;&lt;title&gt;Hello from Flask&lt;/title&gt;&#123;% if name %&#125; &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/h1&gt;&#123;% else %&#125; &lt;h1&gt;Hello World!&lt;/h1&gt;&#123;% endif %&#125; 重定向和错误12345678910from flask import abort, redirect, url_for@app.route('/')def index(): return redirect(url_for('login'))@app.route('/login')def login(): abort(401) this_is_never_executed() 123@app.errorhandler(404)def page_not_found(error): return render_template('page_not_found.html'), 404]]></content>
      <categories>
        <category>flask</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask 项目目录结构(0)]]></title>
    <url>%2Fpost%2F16b57b0d.html</url>
    <content type="text"><![CDATA[flask 目录架构git地址1https://github.com/Hughendman/flask-program 目录结构123456789101112131415161718| - projectName | - app //程序包 | - templates //jinjia2模板 |- static //css,js 图片等静态文件 | - main //py程序包 ，可以有多个这种包，每个对应不同的功能 | - __init__.py |- errors.py |- __init__.py | - models //数据库模型 | - __init__.py |- models.py | - tests //单元测试 |- __init__.py |- test*.py //单元测试程序，可以包含多个对应不同的功能点测试 |- venv //虚拟环境 |- requirements.txt //列出了所有依赖包以及版本号，方便在其他位置生成相同的虚拟环境以及依赖 |- config.py //全局配置文件，配置全局变量 |- manage.py //启动程序 启动命令1python manage.py runserver -p 9033 自动生成Sqlalchemy的models文件安装sqlacodegen1pip install sqlacodegen 使用1sqlacodegen mysql://root:abcd234@localhost:3306/superset_board?charset=utf8mb4 &gt; models.py 开发文档开发接口1234567891011121314151617181920| - projectName | - app | - templates |- static | - main | - __init__.py |- errors.py | - auth //接口文件 | - __init__.py |- users.py |- __init__.py | - models | - __init__.py |- models.py | - tests |- __init__.py |- test*.py |- requirements.txt |- config.py |- manage.py auth/init.py12345from flask import Blueprintauth = Blueprint('auth', __name__)from .users import * auth/users.py 123456789101112131415from flask import jsonifyfrom app.models import *from app.auth import auth@auth.route('/user', methods=['GET', 'POST'])def user(): jsonResponse = dict(name="yinxs", auth="admin") response = jsonify(jsonResponse) return response@auth.route('/module', methods=['GET', 'POST'])def module(): authPermission = AuthPermission.query.all() auth = json.dumps(authPermission, cls=AlchemyEncoder) return auth app/init.py 123# 增加auth蓝本 from .auth import auth as auth_blueprint app.register_blueprint(auth_blueprint, url_prefix='/auth') 数据库配置config.py1234class DevelopmentConfig(Config): DEBUG = True SQLALCHEMY_DATABASE_URI = 'mysql://root:abcd234@localhost:3306/superset_board?charset=utf8mb4' SQLALCHEMY_TRACK_MODIFICATIONS = True 采用的SQLAlchemy，处理jsonmodels/models.py12345678910111213141516171819202122232425def default(self, obj): if isinstance(obj.__class__, DeclarativeMeta): # an SQLAlchemy class fields = &#123;&#125; for field in [x for x in dir(obj) if not x.startswith('_') and x != 'metadata']: data = obj.__getattribute__(field) try: json.dumps(data) # this will fail on non-encodable values, like other classes fields[field] = data except TypeError: if isinstance(data, datetime.datetime): fields[field] = data.isoformat() elif isinstance(data, datetime.date): fields[field] = data.isoformat() elif isinstance(data, datetime.timedelta): fields[field] = (datetime.datetime.min + data).time().isoformat() else: fields[field] = None if "query" in fields: del fields["query"] if "query_class" in fields: del fields["query_class"] # a json-encodable dict return fields return json.JSONEncoder.default(self, obj) 跨域处理安装使用12from flask_cors import CORSCORS(app,supports_credentials=True) 集成前端123456app = Flask(__name__, static_folder = "./dist/static", template_folder = "./dist")@app.route('/')def index(): return render_template("index.html") 自动生成依赖包1pip freeze &gt; requirements.txt 安装依赖包1pip install -r Requirements.txt 版本10-18 first commit10-22 mysqldb commit]]></content>
      <categories>
        <category>flask</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker + Superset]]></title>
    <url>%2Fpost%2F4fbb2b9c.html</url>
    <content type="text"><![CDATA[安装docker123yum install epel-releaseyum install docker-io 启动doker1service docker start 安装superset12345678910111213141516171819202122232425262728293031#查找镜像docker search superset #拉取镜像docker pull amancevice/superset:0.27.0 #查看镜像docker images # 创建容器docker run -d -p 9300:8088 -v /dockersuperset:/home/superset amancevice/superset:0.27.0#获取CONTAINER IDdocker ps #以下步骤为superset初始化步骤docker exec -it CONTAINER ID fabmanager create-admin --app supersetdocker exec -it CONTAINER ID superset db upgradesuperset load_examplesdocker exec -it CONTAINER ID superset initdocker exec -it CONTAINER ID superset runserver 访问：http://localhost:9033/superset/welcome]]></content>
      <categories>
        <category>Superset</category>
      </categories>
      <tags>
        <tag>Superset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API接口加密策略]]></title>
    <url>%2Fpost%2Fbc72157a.html</url>
    <content type="text"><![CDATA[转载-Api接口加密策略接口安全需求：1.防伪装攻击（案例：在公共网络环境中，第三方 有意或恶意 的调用我们的接口） 2.防篡改攻击（案例：在公共网络环境中，请求头/查询字符串/内容 在传输过程被修改） 3.防重放攻击（案例：在公共网络环境中，请求被截获，稍后被重放或多次重放） 4.防数据信息泄漏（案例：截获用户登录请求，截获到账号、密码等） 设计原则 轻量级 适合于异构系统（跨操作系统、多语言简易实现） 易于开发 易于测试 易于部署 满足接口安全需求（满足接口安全1,2,3），无过度设计。 其它：接口安全要求防数据信息泄漏部分，主要针对目前用户中心的登录接口 设计原则是：使用HTTPS安全协议 或 传输内容使用非对称加密，目前我们采用的后者。 参数_appid:调用方身份ID，接口提供方用此来识别不同的用户（API公共规范） _sign:一次接口调用的签名值（防伪装请求/篡改/重发） _timestamp:时间戳 签名算法过程：1.对除签名外的所有请求参数按key做的升序排列,value无需编码。（假设当前时间的时间戳是12345678）例如：有c=3,b=2,a=1 三个参，另加上时间戳后， 按key排序后为：a=1，b=2，c=3，_timestamp=12345678。 2 把参数名和参数值连接成字符串，得到拼装字符：a1b2c3_timestamp12345678 3 用申请到的appkey 连接到接拼装字符串头部和尾部，然后进行32位MD5加密，最后将到得MD5加密摘要转化成大写。 示例：假设appkey=test，md5(testa1b2c3_timestamp12345678test)，取得MD5摘要值 C5F3EB5D7DC2748AED89E90AF00081E6 。 常见的加密方式DES加密算法：DES加密算法是一种分组密码，以64位为分组对数据加密，它的密钥长度是56位，加密解密用同一算法。DES加密算法是对密钥进行保密，而公开算法，包括加密和解密算法。这样，只有掌握了和发送方相同密钥的人才能解读由DES加密算法加密的密文数据。因此，破译DES加密算法实际上就是搜索密钥的编码。对于56位长度的密钥来说，如果用穷举法来进行搜索的话，其运算次数为256。 随着计算机系统能力的不断发展，DES的安全性比它刚出现时会弱得多，然而从非关键性质的实际出发，仍可以认为它是足够的。不过，DES现在仅用于旧系统的鉴定，而更多地选择新的加密标准。 AES加密算法：ES加密算法是密码学中的高级加密标准，该加密算法采用对称分组密码体制，密钥长度的最少支持为128、192、256，分组长度128位，算法应易于各种硬件和软件实现。这种加密算法是美国联邦政府采用的区块加密标准，这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。 AES加密算法被设计为支持128／192／256位（/32=nb)数据块大小（即分组长度）；支持128／192／256位（/32=nk)密码长度，，在10进制里，对应34×1038、62×1057、1.1×1077个密钥。 RSA加密算法：RSA加密算法是目前最有影响力的公钥加密算法，并且被普遍认为是目前最优秀的公钥方案之一。RSA是第一个能同时用于加密和数字签名的算法，它能够抵抗到目前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。RSA加密算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。 Base64加密算法：Base64加密算法是网络上最常见的用于传输8bit字节代码的编码方式之一，Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在JAVAPERSISTENCE系统HIBEMATE中，采用了Base64来将一个较长的唯一标识符编码为一个字符串，用作HTTP表单和HTTPGETURL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到。 MD5加密算法：MD5为计算机安全领域广泛使用的一种散列函数，用以提供消息的完整性保护。对MD5加密算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成—个128位散列值。 MD5被广泛用于各种软件的密码认证和钥匙识别上。MD5用的是哈希函数，它的典型应用是对一段信息产生信息摘要，以防止被篡改。MD5的典型应用是对一段Message产生fingerprin指纹，以防止被“篡改”。如果再有—个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。MD5还广泛用于操作系统的登陆认证上，如UNIX、各类BSD系统登录密码、数字签名等诸多方]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Superset搭建及其简单使用]]></title>
    <url>%2Fpost%2F24650887.html</url>
    <content type="text"><![CDATA[安装1234567891011121314151617181920212223242526#安装Superset pip install superset export PYTHONPATH=/usr/local/lib/python3.5/site-packages:$PYTHONPATH #创建管理员用户名和密码 fabmanager create-admin --app superset #初始化Superset superset db upgrade #装载初始化样例数据 superset load_examples #创建默认角色和权限 superset init #启动Superset superset runserver (window)C:\Users\admin\AppData\Local\Programs\Python\Python35\Lib\site-packages\superset-0.27.0-py3.5.egg\superset\binpython superset runserver -d 汉化1superset-0.17.1-py3.5.egg/superset/config.py 123456789101112131415161718# ---------------------------------------------------# Babel config for translations# ---------------------------------------------------# Setup default languageBABEL_DEFAULT_LOCALE = 'zh'# Your application default translation pathBABEL_DEFAULT_FOLDER = 'superset/translations'# The allowed translation for you appLANGUAGES = &#123; 'en': &#123;'flag': 'us', 'name': 'English'&#125;, 'it': &#123;'flag': 'it', 'name': 'Italian'&#125;, 'fr': &#123;'flag': 'fr', 'name': 'French'&#125;, 'zh': &#123;'flag': 'cn', 'name': 'Chinese'&#125;, 'ja': &#123;'flag': 'jp', 'name': 'Japanese'&#125;, 'de': &#123;'flag': 'de', 'name': 'German'&#125;, 'pt_BR': &#123;'flag': 'br', 'name': 'Brazilian Portuguese'&#125;, 'ru': &#123;'flag': 'ru', 'name': 'Russian'&#125;,&#125; 使用配置数据源Sources &gt;&gt; Databases 在Database中添加名字 在SQLALCHEMY URI中添加下面格式1mysql+mysqldb://用户名:密码@IP:端口号/数据库名称?charset=utf8 选择在sql工具箱公开这个数据库 SQL LabSQL Lab &gt;&gt; SQL Editor 选择规格的数据库，可以编写sql了 查询后点击可视化 可视化配置完成后，保存 登录问题步骤： 1.通过iframe引用superset的图表。 2.找到superset项目内的 config.py文件，PUBLIC_ROLE_LIKE_GAMMA = False， 把它设置为True 3.进入superset，导航内找到 security ，点击list roles，看到public，点击edit。 4.最后在permissions里把以下三个加上 123can explore on Supersetcan explore json on Supersetall database access on all_database_access 5.保存，退出登陆。]]></content>
      <categories>
        <category>Superset</category>
      </categories>
      <tags>
        <tag>Superset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 文章转载]]></title>
    <url>%2Fpost%2F6722e70.html</url>
    <content type="text"><![CDATA[转载自 Table of Contents Python语言特性 1 Python的函数参数传递 2 Python中的元类(metaclass) 3 @staticmethod和@classmethod 4 类变量和实例变量 5 Python自省 6 字典推导式 7 Python中单下划线和双下划线 8 字符串格式化:\x和.format 9 迭代器和生成器 10 *args and **kwargs 11 面向切面编程AOP和装饰器 12 鸭子类型 13 Python中重载 14 新式类和旧式类 15 new和init的区别 16 单例模式 1 使用new方法 2 共享属性 3 装饰器版本 4 import方法 17 Python中的作用域 18 GIL线程全局锁 19 协程 20 闭包 21 lambda函数 22 Python函数式编程 23 Python里的拷贝 24 Python垃圾回收机制 1 引用计数 2 标记-清除机制 3 分代技术 25 Python的List 26 Python的is 27 read,readline和readlines 28 Python2和3的区别 29 super init 30 range and xrange 操作系统 1 select,poll和epoll 2 调度算法 3 死锁 4 程序编译与链接 1 预处理 2 编译 3 汇编 4 链接 5 静态链接和动态链接 6 虚拟内存技术 7 分页和分段 分页与分段的主要区别 8 页面置换算法 9 边沿触发和水平触发 数据库 1 事务 2 数据库索引 3 Redis原理 Redis是什么？ Redis数据库 Redis缺点 4 乐观锁和悲观锁 5 MVCC MySQL的innodb引擎是如何实现MVCC的 6 MyISAM和InnoDB 网络 1 三次握手 2 四次挥手 3 ARP协议 4 urllib和urllib2的区别 5 Post和Get 6 Cookie和Session 7 apache和nginx的区别 8 网站用户密码保存 9 HTTP和HTTPS 10 XSRF和XSS 11 幂等 Idempotence 12 RESTful架构(SOAP,RPC) 13 SOAP 14 RPC 15 CGI和WSGI 16 中间人攻击 17 c10k问题 18 socket 19 浏览器缓存 20 HTTP1.0和HTTP1.1 21 Ajax *NIX unix进程间通信方式(IPC) 数据结构 1 红黑树 编程题 1 台阶问题/斐波那契 2 变态台阶问题 3 矩形覆盖 4 杨氏矩阵查找 5 去除列表中的重复元素 6 链表成对调换 7 创建字典的方法 1 直接创建 2 工厂方法 3 fromkeys()方法 8 合并两个有序列表 9 交叉链表求交点 10 二分查找 11 快排 12 找零问题 13 广度遍历和深度遍历二叉树 17 前中后序遍历 18 求最大树深 19 求两棵树是否相同 20 前序中序求后序 21 单链表逆置 22 两个字符串是否是变位词 23 动态规划问题 Python语言特性1 Python的函数参数传递看两个例子: 12345a = 1def fun(a): a = 2fun(a)print a # 1 12345a = []def fun(a): a.append(1)fun(a)print a # [1] 所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。 通过id来看引用a的内存地址可以比较理解： 12345678a = 1def fun(a): print "func_in",id(a) # func_in 41322472 a = 2 print "re-point",id(a), id(2) # re-point 41322448 41322448print "func_out",id(a), id(1) # func_out 41322472 41322472fun(a)print a # 1 注：具体的值在不同电脑上运行时可能不同。 可以看到，在执行完a = 2之后，a引用中保存的值，即内存地址发生变化，由原来1对象的所在的地址变成了2这个实体对象的内存地址。 而第2个例子a引用保存的内存值就不会发生变化： 1234567a = []def fun(a): print "func_in",id(a) # func_in 53629256 a.append(1)print "func_out",id(a) # func_out 53629256fun(a)print a # [1] 这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而 list, dict, set 等则是可以修改的对象。(这就是这个问题的重点) 当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改. 如果还不明白的话,这里有更好的解释: http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference 2 Python中的元类(metaclass)这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看:http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python 3 @staticmethod和@classmethodPython其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下: 12345678910111213141516def foo(x): print "executing foo(%s)"%(x)class A(object): def foo(self,x): print "executing foo(%s,%s)"%(self,x) @classmethod def class_foo(cls,x): print "executing class_foo(%s,%s)"%(cls,x) @staticmethod def static_foo(x): print "executing static_foo(%s)"%xa=A() 这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用foo(x),这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是foo(self, x),为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的a.foo(x)(其实是foo(a, x)).类方法一样,只不过它传递的是类而不是实例,A.class_foo(x).注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好. 对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用a.static_foo(x)或者A.static_foo(x)来调用. \ 实例方法 类方法 静态方法 a = A() a.foo(x) a.class_foo(x) a.static_foo(x) A 不可用 A.class_foo(x) A.static_foo(x) 更多关于这个问题: http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python https://realpython.com/blog/python/instance-class-and-static-methods-demystified/4 类变量和实例变量 类变量： ​ 是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。 实例变量： 实例化之后，每个实例单独拥有的变量。 12345678910111213class Test(object): num_of_instance = 0 def __init__(self, name): self.name = name Test.num_of_instance += 1 if __name__ == '__main__': print Test.num_of_instance # 0 t1 = Test('jack') print Test.num_of_instance # 1 t2 = Test('lucy') print t1.name , t1.num_of_instance # jack 2 print t2.name , t2.num_of_instance # lucy 2 补充的例子 123456789class Person: name="aaa"p1=Person()p2=Person()p1.name="bbb"print p1.name # bbbprint p2.name # aaaprint Person.name # aaa 这里p1.name=&quot;bbb&quot;是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,p1.name一开始是指向的类变量name=&quot;aaa&quot;,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了. 可以看看下面的例子: 123456789class Person: name=[]p1=Person()p2=Person()p1.name.append(1)print p1.name # [1]print p2.name # [1]print Person.name # [1] 参考:http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block 5 Python自省这个也是python彪悍的特性. 自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance(). 12345a = [1,2,3]b = &#123;'a':1,'b':2,'c':3&#125;c = Trueprint type(a),type(b),type(c) # &lt;type 'list'&gt; &lt;type 'dict'&gt; &lt;type 'bool'&gt;print isinstance(a,list) # True 6 字典推导式可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的: 1d = &#123;key: value for (key, value) in iterable&#125; 7 Python中单下划线和双下划线1234567891011121314&gt;&gt;&gt; class MyClass():... def __init__(self):... self.__superprivate = "Hello"... self._semiprivate = ", world!"...&gt;&gt;&gt; mc = MyClass()&gt;&gt;&gt; print mc.__superprivateTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: myClass instance has no attribute '__superprivate'&gt;&gt;&gt; print mc._semiprivate, world!&gt;&gt;&gt; print mc.__dict__&#123;'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'&#125; __foo__:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如__init__(),__del__(),__call__()这些特殊方法 _foo:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问； __foo:这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问. 详情见:http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python 或者: http://www.zhihu.com/question/19754941 8 字符串格式化:%和.format.format在许多方面看起来更便利.对于%最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题: 1"hi there %s" % name 但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做: 1"hi there %s" % (name,) # 提供一个单元素的数组而不是一个参数 但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了. 你为什么不用它? 不知道它(在读这个之前) 为了和Python2.5兼容(譬如logging库建议使用%(issue #4)) http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format 9 迭代器和生成器这个是stackoverflow里python排名第一的问题,值得一看: http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python 这是中文版: http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html 这里有个关于生成器的创建问题面试官有考：问： 将列表生成式中[]改成() 之后数据结构是否改变？答案：是，从列表变为生成器 123456&gt;&gt;&gt; L = [x*x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x*x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x0000028F8B774200&gt; 通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—&gt;generator 10 *args and **kwargs用*args和**kwargs只是为了方便并没有强制使用它们. 当你不确定你的函数里将要传递多少参数时你可以用*args.例如,它可以传递任意数量的参数: 12345678&gt;&gt;&gt; def print_everything(*args): for count, thing in enumerate(args):... print '&#123;0&#125;. &#123;1&#125;'.format(count, thing)...&gt;&gt;&gt; print_everything('apple', 'banana', 'cabbage')0. apple1. banana2. cabbage 相似的,**kwargs允许你使用没有事先定义的参数名: 1234567&gt;&gt;&gt; def table_things(**kwargs):... for name, value in kwargs.items():... print '&#123;0&#125; = &#123;1&#125;'.format(name, value)...&gt;&gt;&gt; table_things(apple = 'fruit', cabbage = 'vegetable')cabbage = vegetableapple = fruit 你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给*args和**kwargs.命名参数在列表的最前端.例如: 1def table_things(titlestring, **kwargs) *args和**kwargs可以同时在函数的定义中,但是*args必须在**kwargs前面. 当调用函数时你也可以用*和**语法.例如: 1234567&gt;&gt;&gt; def print_three_things(a, b, c):... print 'a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;'.format(a,b,c)...&gt;&gt;&gt; mylist = ['aardvark', 'baboon', 'cat']&gt;&gt;&gt; print_three_things(*mylist)a = aardvark, b = baboon, c = cat 就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*. http://stackoverflow.com/questions/3394835/args-and-kwargs 11 面向切面编程AOP和装饰器这个AOP一听起来有点懵,同学面阿里的时候就被问懵了… 装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 这个问题比较大,推荐: http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python 中文: http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html 12 鸭子类型“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。 比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。 又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等. 鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。 13 Python中重载引自知乎:http://www.zhihu.com/question/20053359 函数重载主要是为了解决两个问题。 可变参数类型。 可变参数个数。 另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。 好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。 那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。 好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。 14 新式类和旧式类这个面试官问了,我说了老半天,不知道他问的真正意图是什么. stackoverflow 这篇文章很好的介绍了新式类的特性: http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html 新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类是广度优先,旧式类是深度优先),&lt;Python核心编程&gt;里讲的也很多. 一个旧式类的深度优先的例子 12345678910111213141516class A(): def foo1(self): print "A"class B(A): def foo2(self): passclass C(A): def foo1(self): print "C"class D(B, C): passd = D()d.foo1()# A 按照经典类的查找顺序从左到右深度优先的规则，在访问d.foo1()的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过 15 __new__和__init__的区别这个__new__确实很少见到,先做了解吧. __new__是一个静态方法,而__init__是一个实例方法. __new__方法会返回一个创建的实例,而__init__什么都不返回. 只有在__new__返回一个cls的实例时后面的__init__才能被调用. 当创建一个新实例时调用__new__,初始化一个实例时用__init__. stackoverflow ps: __metaclass__是创建类时起作用.所以我们可以分别使用__metaclass__,__new__和__init__来分别在类创建,实例创建和实例初始化的时候做一些小手脚. 16 单例模式 ​ 单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。 __new__()在__init__()之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的. 1 使用__new__方法123456789class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, '_instance'): orig = super(Singleton, cls) cls._instance = orig.__new__(cls, *args, **kw) return cls._instanceclass MyClass(Singleton): a = 1 2 共享属性创建实例时把所有实例的__dict__指向同一个字典,这样它们具有相同的属性和方法. 12345678910class Borg(object): _state = &#123;&#125; def __new__(cls, *args, **kw): ob = super(Borg, cls).__new__(cls, *args, **kw) ob.__dict__ = cls._state return obclass MyClass2(Borg): a = 1 3 装饰器版本1234567891011def singleton(cls): instances = &#123;&#125; def getinstance(*args, **kw): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return getinstance@singletonclass MyClass: ... 4 import方法作为python的模块是天然的单例模式 1234567891011# mysingleton.pyclass My_Singleton(object): def foo(self): passmy_singleton = My_Singleton()# to usefrom mysingleton import my_singletonmy_singleton.foo() 单例模式伯乐在线详细解释 17 Python中的作用域Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。 当 Python 遇到一个变量的话他会按照这样的顺序进行搜索： 本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in） 18 GIL线程全局锁线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。 见Python 最难的问题 解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能). 19 协程知乎被问到了,呵呵哒,跪了 简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态. Python里最常见的yield就是协程的思想!可以查看第九个问题. 20 闭包闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。 当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点: 必须有一个内嵌函数 内嵌函数必须引用外部函数中的变量 外部函数的返回值必须是内嵌函数 感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料. 重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上. 闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样. 21 lambda函数其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关. 推荐: 知乎 22 Python函数式编程这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用. 推荐: 酷壳 python中函数式编程支持: filter 函数的功能相当于过滤器。调用一个布尔函数bool_func来迭代遍历每个seq中的元素；返回一个使bool_seq返回值为true的元素的序列。 1234&gt;&gt;&gt;a = [1,2,3,4,5,6,7]&gt;&gt;&gt;b = filter(lambda x: x &gt; 5, a)&gt;&gt;&gt;print b&gt;&gt;&gt;[6,7] map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2： 123&gt;&gt;&gt; a = map(lambda x:x*2,[1,2,3])&gt;&gt;&gt; list(a)[2, 4, 6] reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘： 12&gt;&gt;&gt; reduce(lambda x,y:x*y,range(1,4))6 23 Python里的拷贝引用和copy(),deepcopy()的区别 1234567891011121314151617181920import copya = [1, 2, 3, 4, ['a', 'b']] #原始对象b = a #赋值，传对象的引用c = copy.copy(a) #对象拷贝，浅拷贝d = copy.deepcopy(a) #对象拷贝，深拷贝a.append(5) #修改对象aa[4].append('c') #修改对象a中的['a', 'b']数组对象print 'a = ', aprint 'b = ', bprint 'c = ', cprint 'd = ', d输出结果：a = [1, 2, 3, 4, ['a', 'b', 'c'], 5]b = [1, 2, 3, 4, ['a', 'b', 'c'], 5]c = [1, 2, 3, 4, ['a', 'b', 'c']]d = [1, 2, 3, 4, ['a', 'b']] 24 Python垃圾回收机制Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。 1 引用计数PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。 优点: 简单 实时性 缺点: 维护引用计数消耗资源 循环引用 2 标记-清除机制基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。 3 分代技术分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。 Python默认定义了三代对象集合，索引数越大，对象存活时间越长。 举例：当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。 25 Python的List推荐: http://www.jianshu.com/p/J4U6rR 26 Python的isis是对比地址,==是对比值 27 read,readline和readlines read 读取整个文件 readline 读取下一行,使用生成器方法 readlines 读取整个文件到一个迭代器以供我们遍历 28 Python2和3的区别推荐：Python 2.7.x 与 Python 3.x 的主要差异 29 super initsuper() lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven’t already. Note that the syntax changed in Python 3.0: you can just say super().__init__() instead of super(ChildB, self).__init__() which IMO is quite a bit nicer. http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods Python2.7中的super方法浅见 30 range and xrange都在循环时使用，xrange内存性能更好。for i in range(0, 20):for i in xrange(0, 20):What is the difference between range and xrange functions in Python 2.X? range creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements. xrange is a sequence object that evaluates lazily. http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x 操作系统1 select,poll和epoll其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了. 这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的. selec,poll和epoll区别总结 基本上select有3个缺点: 连接数受限 查找配对速度慢 数据由内核拷贝到用户态 poll改善了第一个缺点 epoll改了三个缺点. 关于epoll的: http://www.cnblogs.com/my_life/articles/3968782.html 2 调度算法 先来先服务(FCFS, First Come First Serve) 短作业优先(SJF, Shortest Job First) 最高优先权调度(Priority Scheduling) 时间片轮转(RR, Round Robin) 多级反馈队列调度(multilevel feedback queue scheduling) 常见的调度算法总结:http://www.jianshu.com/p/6edf8174c1eb 实时调度算法: 最早截至时间优先 EDF 最低松弛度优先 LLF 3 死锁原因: 竞争资源 程序推进顺序不当 必要条件: 互斥条件 请求和保持条件 不剥夺条件 环路等待条件 处理死锁基本方法: 预防死锁(摒弃除1以外的条件) 避免死锁(银行家算法) 检测死锁(资源分配图) 解除死锁 剥夺资源 撤销进程 死锁概念处理策略详细介绍:https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html 4 程序编译与链接推荐: http://www.ruanyifeng.com/blog/2014/11/compiler.html Bulid过程可以分解为4个步骤:预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking) 以c语言为例: 1 预处理预编译过程主要处理那些源文件中的以“#”开始的预编译指令，主要处理规则有： 将所有的“#define”删除，并展开所用的宏定义 处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif” 处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归进行的 删除所有注释 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号 保留所有的#pragma编译器指令。 2 编译编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。 3 汇编汇编器是将汇编代码转化成机器可以执行的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件(Object File) 4 链接链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。链接的主要过程包块 地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。 5 静态链接和动态链接静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库 动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序 6 虚拟内存技术虚拟存储器是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储系统. 7 分页和分段分页: 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。 分段: 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。 分页与分段的主要区别 页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要. 页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分. 分页的作业地址空间是一维的.分段的地址空间是二维的. 8 页面置换算法 最佳置换算法OPT:不可能实现 先进先出FIFO 最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换. clock算法 9 边沿触发和水平触发边缘触发是指每当状态变化时发生一个 io 事件，条件触发是只要满足条件就发生一个 io 事件 数据库1 事务数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。彻底理解数据库事务: http://www.hollischuang.com/archives/898 2 数据库索引推荐: http://tech.meituan.com/mysql-index.html MySQL索引背后的数据结构及算法原理 聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理 3 Redis原理Redis是什么？ 是一个完全开源免费的key-value内存数据库 通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets Redis数据库 ​ 通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用来处理高并发的数据库操作 速度快：使用标准C写，所有数据都在内存中完成，读写速度分别达到10万/20万 持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof) 自动操作：对不同数据类型的操作都是自动的，很安全 快速的主–从复制，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。 Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。 Redis缺点 是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。 4 乐观锁和悲观锁悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁与悲观锁的具体区别: http://www.cnblogs.com/Bob-FD/p/3352216.html 5 MVCC ​ 全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。 MySQL的innodb引擎是如何实现MVCC的innodb会为每一行添加两个字段，分别表示该行创建的版本和删除的版本，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（事务的隔离级别请看这篇文章）下，具体各种数据库操作的实现： select：满足以下两个条件innodb会返回该行数据： 该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。 该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。 insert：将新插入的行的创建版本号设置为当前系统的版本号。 delete：将要删除的行的删除版本号设置为当前系统的版本号。 update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。 其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。 ​ 由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。 通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。 参考：MVCC浅析 6 MyISAM和InnoDBMyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。 InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。 mysql 数据库引擎: http://www.cnblogs.com/0201zcr/p/5296843.htmlMySQL存储引擎－－MyISAM与InnoDB区别: https://segmentfault.com/a/1190000008227211 网络1 三次握手 客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。 服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。 最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。 2 四次挥手注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然. 客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据. 服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息. 服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文. 客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接. 图解: http://blog.csdn.net/whuslei/article/details/6667471 3 ARP协议地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。 4 urllib和urllib2的区别这个面试官确实问过,当时答的urllib2可以Post而urllib不可以. urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。 urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。 5 Post和GetGET和POST有什么区别？及为什么网上的多数答案都是错的知乎回答 get: RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1post: RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1 6 Cookie和Session Cookie Session 储存位置 客户端 服务器端 目的 跟踪会话，也可以保存用户偏好设置或者保存用户名密码等 跟踪会话 安全性 不安全 安全 session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。 7 apache和nginx的区别nginx 相对 apache 的优点： 轻量级，同样起web 服务，比apache 占用更少的内存及资源 抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能 配置简洁 高度模块化的设计，编写模块相对简单 社区活跃 apache 相对nginx 的优点： rewrite ，比nginx 的rewrite 强大 模块超多，基本想到的都可以找到 少bug ，nginx 的bug 相对较多 超稳定 8 网站用户密码保存 明文保存 明文hash后保存,如md5 MD5+Salt方式,这个salt可以随机 知乎使用了Bcrypy(好像)加密 9 HTTP和HTTPS 状态码 定义 1xx 报告 接收到请求，继续进程 2xx 成功 步骤成功接收，被理解，并被接受 3xx 重定向 为了完成请求,必须采取进一步措施 4xx 客户端出错 请求包括错的顺序或不能完成 5xx 服务器出错 服务器无法完成显然有效的请求 403: Forbidden404: Not Found HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA 10 XSRF和XSS CSRF(Cross-site request forgery)跨站请求伪造 XSS(Cross Site Scripting)跨站脚本攻击 CSRF重点在请求,XSS重点在脚本 11 幂等 IdempotenceHTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。(注意是副作用) GET http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。 DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：DELETE http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。 POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。 PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。 12 RESTful架构(SOAP,RPC)推荐: http://www.ruanyifeng.com/blog/2011/09/restful.html 13 SOAPSOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。 14 RPCRPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了. 进化的顺序: RPC -&gt; SOAP -&gt; RESTful 15 CGI和WSGICGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。 WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。 官方说明：PEP-3333 16 中间人攻击在GFW里屡见不鲜的,呵呵. 中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。 17 c10k问题所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。推荐: https://my.oschina.net/xianggao/blog/664275 18 socket推荐: http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml Socket=Ip address+ TCP/UDP + port 19 浏览器缓存推荐: http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html 304 Not Modified 20 HTTP1.0和HTTP1.1推荐: http://blog.csdn.net/elifefly/article/details/3964766 请求头Host字段,一个服务器多个网站 长链接 文件断点续传 身份认证,状态管理,Cache缓存 HTTP请求8种方法介绍HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。 GET GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。 GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。 HEAD HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。 POST POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。 PUT PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。 DELETE DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。 CONNECT CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。 OPTIONS OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许 TRACE TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。 HTTP/1.1之后增加的方法 在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法： PATCH PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同： 但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。 21 AjaxAJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。 *NIXunix进程间通信方式(IPC) 管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。 命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。 消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。 内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。 数据结构1 红黑树红黑树与AVL的比较： AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多； 红黑是用非严格的平衡来换取增删节点时候旋转次数的降低； 所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。 红黑树详解: https://xieguanglei.github.io/blog/post/red-black-tree.html 教你透彻了解红黑树: https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md 编程题1 台阶问题/斐波那契一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 1fib = lambda n: n if n &lt;= 2 else fib(n - 1) + fib(n - 2) 第二种记忆方法 1234567891011121314def memo(func): cache = &#123;&#125; def wrap(*args): if args not in cache: cache[args] = func(*args) return cache[args] return wrap@memodef fib(i): if i &lt; 2: return 1 return fib(i-1) + fib(i-2) 第三种方法 12345def fib(n): a, b = 0, 1 for _ in xrange(n): a, b = b, a + b return b 2 变态台阶问题一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 1fib = lambda n: n if n &lt; 2 else 2 * fib(n - 1) 3 矩形覆盖我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 第2*n个矩形的覆盖方法等于第2*(n-1)加上第2*(n-2)的方法。 1f = lambda n: 1 if n &lt; 2 else f(n - 1) + f(n - 2) 4 杨氏矩阵查找在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 使用Step-wise线性搜索。 1234567891011121314151617def get_value(l, r, c): return l[r][c]def find(l, x): m = len(l) - 1 n = len(l[0]) - 1 r = 0 c = n while c &gt;= 0 and r &lt;= m: value = get_value(l, r, c) if value == x: return True elif value &gt; x: c = c - 1 elif value &lt; x: r = r + 1 return False 5 去除列表中的重复元素用集合 1list(set(l)) 用字典 123l1 = ['b','c','d','b','c','a','a']l2 = &#123;&#125;.fromkeys(l1).keys()print l2 用字典并保持顺序 1234l1 = ['b','c','d','b','c','a','a']l2 = list(set(l1))l2.sort(key=l1.index)print l2 列表推导式 123l1 = ['b','c','d','b','c','a','a']l2 = [][l2.append(i) for i in l1 if not i in l2] sorted排序并且用列表推导式. l = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’][single.append(i) for i in sorted(l) if i not in single]print single 6 链表成对调换1-&gt;2-&gt;3-&gt;4转换成2-&gt;1-&gt;4-&gt;3. 123456789101112131415class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: # @param a ListNode # @return a ListNode def swapPairs(self, head): if head != None and head.next != None: next = head.next head.next = self.swapPairs(next.next) next.next = head return next return head 7 创建字典的方法1 直接创建1dict = &#123;'name':'earth', 'port':'80'&#125; 2 工厂方法123items=[('name','earth'),('port','80')]dict2=dict(items)dict1=dict((['name','earth'],['port','80'])) 3 fromkeys()方法1234dict1=&#123;&#125;.fromkeys(('x','y'),-1)dict=&#123;'x':-1,'y':-1&#125;dict2=&#123;&#125;.fromkeys(('x','y'))dict2=&#123;'x':None, 'y':None&#125; 8 合并两个有序列表知乎远程面试要求编程 尾递归 12345678910111213141516def _recursion_merge_sort2(l1, l2, tmp): if len(l1) == 0 or len(l2) == 0: tmp.extend(l1) tmp.extend(l2) return tmp else: if l1[0] &lt; l2[0]: tmp.append(l1[0]) del l1[0] else: tmp.append(l2[0]) del l2[0] return _recursion_merge_sort2(l1, l2, tmp)def recursion_merge_sort2(l1, l2): return _recursion_merge_sort2(l1, l2, []) 循环算法 思路： 定义一个新的空列表 比较两个列表的首个元素 小的就插入到新列表里 把已经插入新列表的元素从旧列表删除 直到两个旧列表有一个为空 再把旧列表加到新列表后面 123456789101112def loop_merge_sort(l1, l2): tmp = [] while len(l1) &gt; 0 and len(l2) &gt; 0: if l1[0] &lt; l2[0]: tmp.append(l1[0]) del l1[0] else: tmp.append(l2[0]) del l2[0] tmp.extend(l1) tmp.extend(l2) return tmp pop弹出 12345678910111213141516a = [1,2,3,7]b = [3,4,5]def merge_sortedlist(a,b): c = [] while a and b: if a[0] &gt;= b[0]: c.append(b.pop(0)) else: c.append(a.pop(0)) while a: c.append(a.pop(0)) while b: c.append(b.pop(0)) return cprint merge_sortedlist(a,b) 9 交叉链表求交点 其实思想可以按照从尾开始比较两个链表，如果相交，则从尾开始必然一致，只要从尾开始比较，直至不一致的地方即为交叉点，如图所示 1234567891011121314# 使用a,b两个list来模拟链表，可以看出交叉点是 7这个节点a = [1,2,3,7,9,1,5]b = [4,5,7,9,1,5]for i in range(1,min(len(a),len(b))): if i==1 and (a[-1] != b[-1]): print "No" break else: if a[-i] != b[-i]: print "交叉节点：",a[-i+1] break else: pass 另外一种比较正规的方法，构造链表类 1234567891011121314151617181920212223242526class ListNode: def __init__(self, x): self.val = x self.next = Nonedef node(l1, l2): length1, lenth2 = 0, 0 # 求两个链表长度 while l1.next: l1 = l1.next length1 += 1 while l2.next: l2 = l2.next length2 += 1 # 长的链表先走 if length1 &gt; lenth2: for _ in range(length1 - length2): l1 = l1.next else: for _ in range(length2 - length1): l2 = l2.next while l1 and l2: if l1.next == l2.next: return l1.next else: l1 = l1.next l2 = l2.next 修改了一下: 123456789101112131415161718192021222324252627282930#coding:utf-8class ListNode: def __init__(self, x): self.val = x self.next = Nonedef node(l1, l2): length1, length2 = 0, 0 # 求两个链表长度 while l1.next: l1 = l1.next#尾节点 length1 += 1 while l2.next: l2 = l2.next#尾节点 length2 += 1 #如果相交 if l1.next == l2.next: # 长的链表先走 if length1 &gt; length2: for _ in range(length1 - length2): l1 = l1.next return l1#返回交点 else: for _ in range(length2 - length1): l2 = l2.next return l2#返回交点 # 如果不相交 else: return 思路: http://humaoli.blog.163.com/blog/static/13346651820141125102125995/ 10 二分查找1234567891011121314151617#coding:utf-8def binary_search(list,item): low = 0 high = len(list)-1 while low&lt;=high: mid = (low+high)/2 guess = list[mid] if guess&gt;item: high = mid-1 elif guess&lt;item: low = mid+1 else: return mid return Nonemylist = [1,3,5,7,9]print binary_search(mylist,3) 参考: http://blog.csdn.net/u013205877/article/details/76411718 11 快排123456789101112#coding:utf-8def quicksort(list): if len(list)&lt;2: return list else: midpivot = list[0] lessbeforemidpivot = [i for i in list[1:] if i&lt;=midpivot] biggerafterpivot = [i for i in list[1:] if i &gt; midpivot] finallylist = quicksort(lessbeforemidpivot)+[midpivot]+quicksort(biggerafterpivot) return finallylistprint quicksort([2,4,6,7,1,2,5]) 更多排序问题可见：数据结构与算法-排序篇-Python描述 12 找零问题12345678910111213141516171819#coding:utf-8#values是硬币的面值values = [ 25, 21, 10, 5, 1]#valuesCounts 钱币对应的种类数#money 找出来的总钱数#coinsUsed 对应于目前钱币总数i所使用的硬币数目def coinChange(values,valuesCounts,money,coinsUsed): #遍历出从1到money所有的钱数可能 for cents in range(1,money+1): minCoins = cents #把所有的硬币面值遍历出来和钱数做对比 for kind in range(0,valuesCounts): if (values[kind] &lt;= cents): temp = coinsUsed[cents - values[kind]] +1 if (temp &lt; minCoins): minCoins = temp coinsUsed[cents] = minCoins print ('面值:&#123;0&#125;的最少硬币使用数为:&#123;1&#125;'.format(cents, coinsUsed[cents])) 思路: http://blog.csdn.net/wdxin1322/article/details/9501163 方法: http://www.cnblogs.com/ChenxofHit/archive/2011/03/18/1988431.html 13 广度遍历和深度遍历二叉树给定一个数组，构建二叉树，并且按层次打印这个二叉树 14 二叉树节点12345678class Node(object): def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = righttree = Node(1, Node(3, Node(7, Node(0)), Node(6)), Node(2, Node(5), Node(4))) 15 层次遍历123456def lookup(root): row = [root] while row: print(row) row = [kid for item in row for kid in (item.left, item.right) if kid] 16 深度遍历1234567891011def deep(root): if not root: return print root.data deep(root.left) deep(root.right)if __name__ == '__main__': lookup(tree) deep(tree) 17 前中后序遍历深度遍历改变顺序就OK了 12345678910111213141516171819202122232425262728293031323334353637#coding:utf-8#二叉树的遍历#简单的二叉树节点类class Node(object): def __init__(self,value,left,right): self.value = value self.left = left self.right = right#中序遍历:遍历左子树,访问当前节点,遍历右子树def mid_travelsal(root): if root.left is None: mid_travelsal(root.left) #访问当前节点 print(root.value) if root.right is not None: mid_travelsal(root.right)#前序遍历:访问当前节点,遍历左子树,遍历右子树def pre_travelsal(root): print (root.value) if root.left is not None: pre_travelsal(root.left) if root.right is not None: pre_travelsal(root.right)#后续遍历:遍历左子树,遍历右子树,访问当前节点def post_trvelsal(root): if root.left is not None: post_trvelsal(root.left) if root.right is not None: post_trvelsal(root.right) print (root.value) 18 求最大树深1234def maxDepth(root): if not root: return 0 return max(maxDepth(root.left), maxDepth(root.right)) + 1 19 求两棵树是否相同1234567def isSameTree(p, q): if p == None and q == None: return True elif p and q : return p.val == q.val and isSameTree(p.left,q.left) and isSameTree(p.right,q.right) else : return False 20 前序中序求后序推荐: http://blog.csdn.net/hinyunsin/article/details/6315502 123456789101112131415def rebuild(pre, center): if not pre: return cur = Node(pre[0]) index = center.index(pre[0]) cur.left = rebuild(pre[1:index + 1], center[:index]) cur.right = rebuild(pre[index + 1:], center[index + 1:]) return curdef deep(root): if not root: return deep(root.left) deep(root.right) print root.data 21 单链表逆置12345678910111213141516171819202122class Node(object): def __init__(self, data=None, next=None): self.data = data self.next = nextlink = Node(1, Node(2, Node(3, Node(4, Node(5, Node(6, Node(7, Node(8, Node(9)))))))))def rev(link): pre = link cur = link.next pre.next = None while cur: tmp = cur.next cur.next = pre pre = cur cur = tmp return preroot = rev(link)while root: print root.data root = root.next 思路: http://blog.csdn.net/feliciafay/article/details/6841115 方法: http://www.xuebuyuan.com/2066385.html?mobile=1 22 两个字符串是否是变位词12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Anagram: """ @:param s1: The first string @:param s2: The second string @:return true or false """ def Solution1(s1,s2): alist = list(s2) pos1 = 0 stillOK = True while pos1 &lt; len(s1) and stillOK: pos2 = 0 found = False while pos2 &lt; len(alist) and not found: if s1[pos1] == alist[pos2]: found = True else: pos2 = pos2 + 1 if found: alist[pos2] = None else: stillOK = False pos1 = pos1 + 1 return stillOK print(Solution1('abcd','dcba')) def Solution2(s1,s2): alist1 = list(s1) alist2 = list(s2) alist1.sort() alist2.sort() pos = 0 matches = True while pos &lt; len(s1) and matches: if alist1[pos] == alist2[pos]: pos = pos + 1 else: matches = False return matches print(Solution2('abcde','edcbg')) def Solution3(s1,s2): c1 = [0]*26 c2 = [0]*26 for i in range(len(s1)): pos = ord(s1[i])-ord('a') c1[pos] = c1[pos] + 1 for i in range(len(s2)): pos = ord(s2[i])-ord('a') c2[pos] = c2[pos] + 1 j = 0 stillOK = True while j&lt;26 and stillOK: if c1[j] == c2[j]: j = j + 1 else: stillOK = False return stillOK print(Solution3('apple','pleap')) 23 动态规划问题 可参考：动态规划(DP)的整理-Python描述]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 操作数据库的增删改查]]></title>
    <url>%2Fpost%2F9ed051d.html</url>
    <content type="text"><![CDATA[创建应用创建一个应用vacation1python3 manage.py startapp vacation 在setting.py下添加&apos;vacation.apps.VacationConfig&apos; 123456789101112131415INSTALLED_APPS = [ 'polls.apps.PollsConfig', 'vacation.apps.VacationConfig', 'person.apps.PersonConfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'rest_framework', 'snippets.apps.SnippetsConfig',] 在vacation下的model.py下添加12345678910111213from django.db import models# Create your models here.class Snippet(models.Model): created = models.DateTimeField(auto_now_add=True) title = models.CharField(max_length=100, blank=True, default='') area = models.TextField() count = models.BooleanField(default=False) class Meta: ordering = ('created',) 执行： 12python3 manage.py makemigrations vacationpython3 manage.py migrate 创建序列化类在vacation下创建serializers.py 12345678910111213141516171819202122from rest_framework import serializersfrom vacation.models import Snippetclass VacationSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(required=False, allow_blank=True, max_length=100) # 利用字段标志控制序列化器渲染到HTML页面时的的显示模板 area = serializers.CharField(style=&#123;'base_template': 'textarea.html'&#125;) count = serializers.BooleanField(required=False) # 给定经过验证的数据，创建并返回一个新的 Snippet 实例 def create(self, validated_data): return Snippet.objects.create(**validated_data) # 给定经过验证的数据，更新并返回一个已经存在的 Snippet 实例 def update(self, instance, validated_data): instance.title = validated_data.get('title', instance.title) instance.area = validated_data.get('area', instance.area) instance.count = validated_data.get('count', instance.count) instance.save() return instance 编写视图vacation/views.py1234567891011121314151617181920212223242526272829from django.shortcuts import render# Create your views here.from django.http import HttpResponse, JsonResponsefrom django.views.decorators.csrf import csrf_exemptfrom rest_framework.renderers import JSONRendererfrom rest_framework.parsers import JSONParserfrom vacation.models import Snippetfrom vacation.serializers import VacationSerializer# Create your views here.@csrf_exemptdef vacation_list(request): """ 列出所有已经存在的vacation """ if request.method == 'GET': snippets = Snippet.objects.all() serializer = VacationSerializer(snippets, many=True) return JsonResponse(serializer.data, safe=False) elif request.method == 'POST': data = JSONParser().parse(request) serializer = VacationSerializer(data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data, status=201) return JsonResponse(serializer.errors, status=400) vacation/urls.py： 123456from django.conf.urls import urlfrom vacation import viewsurlpatterns = [ url('', views.vacation_list),] 根目录/urls.py 1234567from django.contrib import adminfrom django.urls import include, pathurlpatterns = [ path('api/vacation/', include('vacation.urls')), path('admin/', admin.site.urls),] 访问：http://127.0.0.1:8000/api/vacation/ 在vacation下的admin.py添加 123456from django.contrib import admin# Register your models here.from .models import Snippetadmin.site.register(Snippet) 访问:http://127.0.0.1:8000/admin 数据库操作–查询查询所有view.py 1234567891011121314151617@csrf_exemptdef vacation_list(request): """ 列出所有已经存在的vacation """ if request.method == 'GET': snippets = Snippet.objects.all() serializer = VacationSerializer(snippets, many=True) return JsonResponse(serializer.data, safe=False) elif request.method == 'POST': data = JSONParser().parse(request) serializer = VacationSerializer(data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data, status=201) return JsonResponse(serializer.errors, status=400) urls.py 123456from django.conf.urls import urlfrom vacation import viewsurlpatterns = [ url('list/', views.vacation_list)] 访问：http://127.0.0.1:8000/api/vacation/list/ 根据id查询view.py 1234567@csrf_exemptdef vacation_id(request): resId = request.GET.get('id', '') snippets = Snippet.objects.filter(id=resId) serializer = VacationSerializer(snippets, many=True) return JsonResponse(serializer.data, safe=False) urls.py 1234567from django.conf.urls import urlfrom vacation import viewsurlpatterns = [ url('list/', views.vacation_list), url('id/', views.vacation_id),] 访问：http://127.0.0.1:8000/api/vacation/id/?id=1 更新数据根据id更新数据view.py 12345678910@csrf_exemptdef vacation_update(request): try: resId = request.GET.get('id', '') resTitle = request.GET.get('title', '') Snippet.objects.filter(id=resId).update(title=resTitle) return JsonResponse(&#123;"status": "success"&#125;, safe=False) except Exception as err: print(err) return JsonResponse(&#123;"status": "false"&#125;, safe=400) urls.py 12345678from django.conf.urls import urlfrom vacation import viewsurlpatterns = [ url('list/', views.vacation_list), url('id/', views.vacation_id), url('update/', views.vacation_update),] 访问：http://127.0.0.1:8000/api/vacation/update?id=1&amp;title=端午 增加数据view.py 1234567891011@csrf_exemptdef vacation_insert(request): try: resTitle = request.GET.get('title', '') resArea = request.GET.get('area', '') resCount = request.GET.get('count', '') Snippet.objects.create(title=resTitle,area=resArea,count=resCount) return JsonResponse(&#123;"status": "success"&#125;, safe=False) except Exception as err: print(err) return JsonResponse(&#123;"status": "false"&#125;, safe=400) urls.py 123456789from django.conf.urls import urlfrom vacation import viewsurlpatterns = [ url('list/', views.vacation_list), url('id/', views.vacation_id), url('update/', views.vacation_update), url('insert/', views.vacation_insert),] 访问：http://127.0.0.1:8000/api/vacation/insert/?title=端午&amp;area=北京&amp;count=True 删除数据view.py 123456789@csrf_exemptdef vacation_delete(request): try: resId = request.GET.get('id', '') Snippet.objects.filter(id=resId).delete() return JsonResponse(&#123;"status": "success"&#125;, safe=False) except Exception as err: print(err) return JsonResponse(&#123;"status": "false"&#125;, safe=400) urls.py 1234567891011from django.conf.urls import urlfrom vacation import viewsurlpatterns = [ url('list/', views.vacation_list), url('id/', views.vacation_id), url('update/', views.vacation_update), url('insert/', views.vacation_insert), url('delete/', views.vacation_delete)] 访问：http://127.0.0.1:8000/api/vacation/delete/?id=1 不用操作sql直接就可以操作数据库确实很方便，但是我就想写sql，怎么办？ 直接写sql123456789101112@csrf_exemptdef my_custom_sql(request): try: from django.db import connection, transaction cursor = connection.cursor() cursor.execute("SELECT * FROM vacation_snippet") row = cursor.fetchone() return JsonResponse(row, safe=False) except Exception as err: print(err) return JsonResponse(&#123;"status": "false","msg":err&#125;, safe=400) 1234567891011from django.conf.urls import urlfrom vacation import viewsurlpatterns = [ url('list/', views.vacation_list), url('id/', views.vacation_id), url('update/', views.vacation_update), url('insert/', views.vacation_insert), url('delete/', views.vacation_delete), url('sql/', views.my_custom_sql)] 访问：http://127.0.0.1:8000/api/vacation/sql]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django2.1编写 RESTful API 接口]]></title>
    <url>%2Fpost%2F1c52887f.html</url>
    <content type="text"><![CDATA[安装123py -3 -m pip install djangorestframeworkpy -3 -m pip install pygments 创建创建应用1python3 manage.py startapp snippets 在setting.py下添加最后两行 123456789101112INSTALLED_APPS = [ 'polls.apps.PollsConfig', 'person.apps.PersonConfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'rest_framework', 'snippets.apps.SnippetsConfig',] 创建模型类在snippets/models.py下添加 123456789101112131415161718192021from django.db import models# Create your models here.from pygments.lexers import get_all_lexersfrom pygments.styles import get_all_stylesLEXERS = [item for item in get_all_lexers() if item[1]]LANGUAGE_CHOICES = sorted([(item[1][0], item[0]) for item in LEXERS]) # 得到所有的编程语言STYLE_CHOICES = sorted((item, item) for item in get_all_styles()) # 得到所有的配色风格class Snippet(models.Model): created = models.DateTimeField(auto_now_add=True) title = models.CharField(max_length=100, blank=True, default='') code = models.TextField() linenos = models.BooleanField(default=False) language = models.CharField(choices=LANGUAGE_CHOICES, default='python', max_length=100) style = models.CharField(choices=STYLE_CHOICES, default='friendly', max_length=100) class Meta: ordering = ('created',) 执行 12python3 manage.py makemigrations snippetspython3 manage.py migrate 创建序列化类使用django-rest-framework序列化库，把模型实例转化为json格式然后响应出去。 在snippets下创建serializers.py 1234567891011121314151617181920212223242526from rest_framework import serializersfrom snippets.models import Snippet, LANGUAGE_CHOICES, STYLE_CHOICESclass SnippetSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(required=False, allow_blank=True, max_length=100) # 利用字段标志控制序列化器渲染到HTML页面时的的显示模板 code = serializers.CharField(style=&#123;'base_template': 'textarea.html'&#125;) linenos = serializers.BooleanField(required=False) language = serializers.ChoiceField(choices=LANGUAGE_CHOICES, default='python') style = serializers.ChoiceField(choices=STYLE_CHOICES, default='friendly') # 给定经过验证的数据，创建并返回一个新的 Snippet 实例 def create(self, validated_data): return Snippet.objects.create(**validated_data) # 给定经过验证的数据，更新并返回一个已经存在的 Snippet 实例 def update(self, instance, validated_data): instance.title = validated_data.get('title', instance.title) instance.code = validated_data.get('code', instance.code) instance.linenos = validated_data.get('linenos', instance.linenos) instance.language = validated_data.get('language', instance.language) instance.style = validated_data.get('style', instance.style) instance.save() return instance 使用序列化器： 进入shell 1python3 manage.py shell 12345678910111213141516171819&gt;&gt;&gt; from snippets.models import Snippet&gt;&gt;&gt; from snippets.serializers import SnippetSerializer&gt;&gt;&gt; from rest_framework.renderers import JSONRenderer&gt;&gt;&gt; from rest_framework.parsers import JSONParser&gt;&gt;&gt; snippet = Snippet(code='foo = "bar"\n')&gt;&gt;&gt; snippet.save()&gt;&gt;&gt; snippet = Snippet(code='print "hello, world"\n')&gt;&gt;&gt; snippet.save()&gt;&gt;&gt; serializer = SnippetSerializer(snippet)&gt;&gt;&gt; serializer.data&gt;&gt;&gt; content = JSONRenderer().render(serializer.data)&gt;&gt;&gt; content&gt;&gt;&gt; from django.utils.six import BytesIO&gt;&gt;&gt; stream = BytesIO(content)&gt;&gt;&gt; data = JSONParser().parse(stream)&gt;&gt;&gt; serializer = SnippetSerializer(data=data)&gt;&gt;&gt; serializer.is_valid()&gt;&gt;&gt; serializer.validated_data&gt;&gt;&gt; serializer.save() 使用ModelSerializers 修改serializers.py： 1234class SnippetSerializer(serializers.ModelSerializer): class Meta: model = Snippet fields = ('id', 'title', 'code', 'linenos', 'language', 'style') shell 123&gt;&gt;&gt; from snippets.serializers import SnippetSerializer&gt;&gt;&gt; serializer = SnippetSerializer()&gt;&gt;&gt; print(repr(serializer)) 编写视图snippets/views.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from django.http import HttpResponse, JsonResponsefrom django.views.decorators.csrf import csrf_exemptfrom rest_framework.renderers import JSONRendererfrom rest_framework.parsers import JSONParserfrom snippets.models import Snippetfrom snippets.serializers import SnippetSerializer# Create your views here.@csrf_exemptdef snippet_list(request): """ 列出所有已经存在的snippet或者创建一个新的snippet """ if request.method == 'GET': snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return JsonResponse(serializer.data, safe=False) elif request.method == 'POST': data = JSONParser().parse(request) serializer = SnippetSerializer(data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data, status=201) return JsonResponse(serializer.errors, status=400)@csrf_exemptdef snippet_detail(request, pk): """ 检索查看、更新或者删除一个代码段 """ try: snippet = Snippet.objects.get(pk=pk) except Snippet.DoesNotExist: return HttpResponse(status=404) if request.method == 'GET': serializer = SnippetSerializer(snippet) return JsonResponse(serializer.data) elif request.method == 'PUT': data = JSONParser().parse(request) serializer = SnippetSerializer(snippet, data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data) return JsonResponse(serializer.errors, status=400) elif request.method == 'DELETE': snippet.delete() return HttpResponse(status=204) snippets/urls.py： 1234567from django.conf.urls import urlfrom snippets import viewsurlpatterns = [ url('', views.snippet_list), url('(?P&lt;pk&gt;[0-9]+)/', views.snippet_detail),] 根目录下urls.py: 1234567from django.contrib import adminfrom django.urls import include, pathurlpatterns = [ path('api/snippets/', include('snippets.urls')), path('admin/', admin.site.urls),] 测试安装模块1py -3 -m pip install httpie 在snippets下的admin.py添加 123456from django.contrib import admin# Register your models here.from .models import Snippetadmin.site.register(Snippet) 访问： 1http http://127.0.0.1:8000/api/snippets/ 返回： 123456789101112131415161718192021222324252627282930313233HTTP/1.1 200 OKContent-Length: 468Content-Type: application/jsonDate: Wed, 26 Sep 2018 03:39:16 GMTServer: WSGIServer/0.2 CPython/3.5.4rc1X-Frame-Options: SAMEORIGIN[ &#123; "code": "foo = \"bar\"\n", "id": 1, "language": "python", "linenos": false, "style": "friendly", "title": "" &#125;, &#123; "code": "print \"hello, world\"\n", "id": 2, "language": "python", "linenos": false, "style": "friendly", "title": "" &#125;, &#123; "code": "print \"hello, world\"", "id": 3, "language": "python", "linenos": false, "style": "friendly", "title": "" &#125;]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django2.1使用Django重新探索(工具)]]></title>
    <url>%2Fpost%2F2a237a1c.html</url>
    <content type="text"><![CDATA[admin 中文设置在setttings.py下 1234567891011# LANGUAGE_CODE = 'en-us'LANGUAGE_CODE = 'zh-Hans'# TIME_ZONE = 'UTC'TIME_ZONE = 'CCT'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = True 访问：http://127.0.0.1:8000/admin/发现已经变成中文的了 认证创建普通用户1python3 manage.py shell 12&gt;&gt;&gt; from django.contrib.auth.models import User&gt;&gt;&gt; user = User.objects.create_user('yinxss', 'yinxs@126.com', '12345678') 创建超级用户1$ python manage.py createsuperuser --username=hugh --email=hugh@126.com 更改密码1234&gt;&gt;&gt; from django.contrib.auth.models import User&gt;&gt;&gt; u = User.objects.get(username='yinxss')&gt;&gt;&gt; u.set_password('zxlkdfjeirr')&gt;&gt;&gt; u.save() 验证用户123&gt;&gt;&gt; from django.contrib.auth import authenticate&gt;&gt;&gt; user = authenticate(username='yinxss', password='zxlkdfjeirr')&gt;&gt;&gt; print(user) 权限和认证admin管理员的权限：添加、修改、删除。 默认权限当安装了django.contrib.auth应用，对每个已安装的应用都会有三个默认许可–添加、修改、删除。 当运行manage.py migrate时，管理员对模型的默认权限就会被创建，包括已有的模型和新增的模型。 web请求的认证1234if request.user.is_authenticated: # Do something for authenticated users.else: # Do something for anonymous users. 用户验证1234567891011from django.contrib.auth import authenticate, login def my_view(request): username = request.POST['username'] password = request.POST['password'] user = authenticate(request, username=username, password=password) if user is not None: login(request, user) # Redirect to a success page. else: # Return an 'invalid login' error message. 用户登出123456from django.contrib.auth import logout def logout_view(request): logout(request) # Redirect to a success page. 重定向(login_required 装饰器)作用：用户没有登录，跳回登录页面 12345from django.contrib.auth.decorators import login_required @login_required(login_url='/login/')def my_view(request): ... 重定向(LoginRequiredMixin)作用：用户没有登录，跳回登录页面 12345from django.contrib.auth.mixins import LoginRequiredMixin class MyView(LoginRequiredMixin, View): login_url = '/login/' redirect_field_name = 'redirect_to' 日志介绍Django使用的是Python的内置日志（logging）模块构建自己的日志系统 组成python日志组成： Loggers（记录器） Handlers（处理器） Filters（过滤器） Formatters（格式化器） Loggers 记录器日志记录器是进入日志系统的入口点。每个日志记录器都是一个有名的‘桶’，将消息写入其中进行处理。记录器具有日志级别属性(log level)。这个日志级别描述日志记录器所处理消息的严重程度。Python定义的以下日志级别：12345DEBUG：用于调试目的的低等级系统信息INFO：一般的系统信息。WARNING：描述发生的一个小问题的信息ERROR:描述发生的一个大问题的信息CRITICAL:描述已发生的关键问题的信息。 写入日志记录器的每个消息都是日志记录。每个日志记录都有一个日志级别，指示特定消息的严重程度。日志记录还可以包含描述正在记录的事件的有用元数据。这可能包括详细信息，例如堆栈跟踪或错误代码。当消息被提供给记录器时，将消息的日志级别与记录器的日志级别进行比较。如果消息的日志级别满足或超过记录器本身的日志级别，则消息将进行进一步处理。如果没有，消息将被忽略。一旦日志记录器确定需要处理消息，就会将其传递给处理程序。 Handlers处理程序是决定日志记录器中每个消息处理行为的引擎。它描述特定的日志记录行为，例如向屏幕、文件或网络套接字写入消息。与日志记录器一样，处理程序也具有日志级别。如果日志记录的日志级别不满足或超过处理程序的级别，处理程序将忽略消息。日志记录器可以有多个处理程序，每个处理程序可以有不同的日志级别。通过这种方式，可以根据消息的重要性提供不同形式的通知。例如，您可以安装一个将错误和关键消息转发到分页服务的处理程序，而第二个处理程序将所有消息(包括错误和关键消息)记录到一个文件中，以便稍后进行分析。 Filters过滤器用于提供对日志记录从日志记录器传递到处理程序过程中的额外控制。默认情况下，满足日志级别要求的任何日志消息都将被处理。但是，通过安装过滤器，您可以在日志记录过程中添加额外的条件。例如，您可以安装一个过滤器，该过滤器只允许发出来自特定源的错误消息。过滤器还可以用于在发出日志记录之前修改日志记录。例如，您可以编写一个过滤器，如果满足特定的一组条件，则将错误日志记录降级为警告记录。过滤器可以安装在记录器或处理器上;可以在一个链中使用多个过滤器来执行多个过滤操作。 Formatters最终，需要将日志记录呈现为文本。格式化器描述了文本的精确格式。格式化程序通常由包含日志记录属性(LogRecord attributes)的Python格式化字符串组成;但是，您也可以编写自定义格式化程序来实现特定的格式化行为。 使用日志在setting.py中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#导入模块import loggingimport django.utils.logimport logging.handlers LOGGING = &#123; 'version': 1, 'disable_existing_loggers': True, 'formatters': &#123; 'standard': &#123; 'format': '%(asctime)s [%(threadName)s:%(thread)d] [%(name)s:%(lineno)d] [%(module)s:%(funcName)s] [%(levelname)s]- %(message)s'&#125; #日志格式 &#125;, 'filters': &#123; &#125;, 'handlers': &#123; 'mail_admins': &#123; 'level': 'ERROR', 'class': 'django.utils.log.AdminEmailHandler', 'include_html': True, &#125;, 'default': &#123; 'level':'DEBUG', 'class':'logging.handlers.RotatingFileHandler', 'filename': '/sourceDns/log/all.log', #日志输出文件 'maxBytes': 1024*1024*5, #文件大小 'backupCount': 5, #备份份数 'formatter':'standard', #使用哪种formatters日志格式 &#125;, 'error': &#123; 'level':'ERROR', 'class':'logging.handlers.RotatingFileHandler', 'filename': '/sourceDns/log/error.log', 'maxBytes':1024*1024*5, 'backupCount': 5, 'formatter':'standard', &#125;, 'console':&#123; 'level': 'DEBUG', 'class': 'logging.StreamHandler', 'formatter': 'standard' &#125;, 'request_handler': &#123; 'level':'DEBUG', 'class':'logging.handlers.RotatingFileHandler', 'filename': '/sourceDns/log/script.log', 'maxBytes': 1024*1024*5, 'backupCount': 5, 'formatter':'standard', &#125;, 'scprits_handler': &#123; 'level':'DEBUG', 'class':'logging.handlers.RotatingFileHandler', 'filename':'/sourceDns/log/script.log', 'maxBytes': 1024*1024*5, 'backupCount': 5, 'formatter':'standard', &#125; &#125;, 'loggers': &#123; 'django': &#123; 'handlers': ['default', 'console'], 'level': 'DEBUG', 'propagate': False &#125;, 'django.request': &#123; 'handlers': ['request_handler'], 'level': 'DEBUG', 'propagate': False, &#125;, 'scripts': &#123; 'handlers': ['scprits_handler'], 'level': 'INFO', 'propagate': False &#125;, 'sourceDns.webdns.views': &#123; 'handlers': ['default', 'error'], 'level': 'DEBUG', 'propagate': True &#125;, 'sourceDns.webdns.util':&#123; 'handlers': ['error'], 'level': 'ERROR', 'propagate': True &#125; &#125; &#125; 在views.py中使用 123456logger = logging.getLogger('sourceDns.webdns.views') #刚才在setting.py中配置的logger try: mysql= connectMysql('127.0.0.1', '3306', 'david')except Exception,e: logger.error(e) #直接将错误写入到日志文件 发送邮件资讯聚合（RSS/Atom）介绍就本质而言，RSS和Atom是一种信息聚合的技术，都是为了提供一种更为方便、高效的互联网信息的发布和共享，用更少的时间分享更多的信息。 案例分页介绍Django提供了一个新的类来帮助你管理分页数据，这个类存放在django/core/paginator.py.它可以接收列表、元组或其它可迭代的对象。 使用1234567891011121314151617181920from django.core.paginator import Paginator, EmptyPage, PageNotAnIntegerfrom django.shortcuts import render def listing(request): contact_list = Contacts.objects.all() paginator = Paginator(contact_list, 25) # Show 25 contacts per page page = request.GET.get('page') try: contacts = paginator.page(page) except PageNotAnInteger: # If page is not an integer, deliver first page. contacts = paginator.page(1) except EmptyPage: # If page is out of range (e.g. 9999), deliver last page of results. contacts = paginator.page(paginator.num_pages) return render(request, 'list.html', &#123;'contacts': contacts&#125;) 123456789101112131415161718192021&#123;% for contact in contacts %&#125; &#123;# Each "contact" is a Contact model object. #&#125; &#123;&#123; contact.full_name|upper &#125;&#125;&lt;br /&gt; ...&#123;% endfor %&#125; &lt;div class="pagination"&gt; &lt;span class="step-links"&gt; &#123;% if contacts.has_previous %&#125; &lt;a href="?page=&#123;&#123; contacts.previous_page_number &#125;&#125;"&gt;previous&lt;/a&gt; &#123;% endif %&#125; &lt;span class="current"&gt; Page &#123;&#123; contacts.number &#125;&#125; of &#123;&#123; contacts.paginator.num_pages &#125;&#125;. &lt;/span&gt; &#123;% if contacts.has_next %&#125; &lt;a href="?page=&#123;&#123; contacts.next_page_number &#125;&#125;"&gt;next&lt;/a&gt; &#123;% endif %&#125; &lt;/span&gt;&lt;/div&gt; 消息框架序列化会话站点地图静态文件管理数据验证参考Django2.1 日志 中文文档 django 日志logging的配置以及处理 Django之分页功能]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django2.1使用Django重新探索(模型层)]]></title>
    <url>%2Fpost%2F3f0e5b98.html</url>
    <content type="text"><![CDATA[模型介绍模型是您的数据唯一而且准确的信息来源。它包含您正在储存的数据的重要字段和行为。一般来说，每一个模型都映射一个数据库表。 每个模型都是一个 Python 的类，这些类继承 django.db.models.Model 模型类的每个属性都相当于一个数据库的字段。 创建应用1python3 manage.py startapp person 在 person/models.py 12345from django.db import modelsclass Person(models.Model): first_name = models.CharField(max_length=30) last_name = models.CharField(max_length=30) mysite/settings.py12345678910INSTALLED_APPS = [ 'polls.apps.PollsConfig', 'person.apps.PersonConfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] 执行： 123python3 manage.py makemigrations personpython3 manage.py sqlmigrate person 0001python3 manage.py migrate 检查数据库，发现多了一个person_person表 字段模型中最重要的、并且也是唯一必须的是数据库的字段定义。字段在类中定义。定义字段名时应小心避免使用与 models API&lt;/ref/models/instances&gt;冲突的名称， 如 clean`, save, ordelete等. ex: 123456789101112from django.db import modelsclass Musician(models.Model): first_name = models.CharField(max_length=50) last_name = models.CharField(max_length=50) instrument = models.CharField(max_length=100)class Album(models.Model): artist = models.ForeignKey(Musician, on_delete=models.CASCADE) name = models.CharField(max_length=100) release_date = models.DateField() num_stars = models.IntegerField()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django2.1使用Django重新探索(1)]]></title>
    <url>%2Fpost%2Fc44a2080.html</url>
    <content type="text"><![CDATA[前言为什么是重新探索，这里给一个个人的建议，学习一个新的框架的时候，直接去看官方的文档。 编写你的第一个 Django 应用创建项目这里不负责讲如何安装，可以看我的上一篇文章 查看版本你可以查看版本号：我使用的是最新的1python3 -m django --version 创建项目2.1有所不同，命令如下 1py -3 -m django startproject mysite 目录：1234567mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py 运行1python3 manage.py runserver 指定端口号1python3 manage.py runserver 8080 公开IP1python3 manage.py runserver 0:8000 创建投票应用注意：项目不是应用，项目可以包含很多个应用。应用可以被很多个项目使用。 命令1python3 manage.py startapp polls 目录123456789polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 编写视图在 polls下的views.py 12345from django.http import HttpResponsedef index(request): return HttpResponse("Hello, world. You're at the polls index.") 在polls下创建urls.py 12345678from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'),] 在mysite下urls.py 注意：不需要正则了 1234567from django.contrib import adminfrom django.urls import include, pathurlpatterns = [ path('polls/', include('polls.urls')), path('admin/', admin.site.urls),] 测试运行访问：http://localhost:8000/polls/ 数据库配置修改 mysite/settings.py 12import pymysqlpymysql.install_as_MySQLdb() 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'myproject', 'USER': 'root', 'PASSWORD': 'root', 'HOST': '127.0.0.1', 'PORT': '3306' &#125;&#125; 创建默认表1python3 manage.py migrate 创建模型polls/models.py 123456789101112from django.db import modelsclass Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published')class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) 激活模型mysite/settings.py123456789INSTALLED_APPS = [ 'polls.apps.PollsConfig', 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles',] 运行 1python3 manage.py makemigrations polls 1python3 manage.py sqlmigrate polls 0001 1python3 manage.py migrate 查看数据库发现创建两个表 API可以打开命令行，这里不进行探索1python3 manage.py shell 修改 polls/models.py 12345678910import datetimefrom django.db import modelsfrom django.utils import timezoneclass Question(models.Model): # ... def was_published_recently(self): return self.pub_date &gt;= timezone.now() - datetime.timedelta(days=1) 管理页面1python3 manage.py createsuperuser 启动访问：http://127.0.0.1:8000/admin/ 添加投票应用在polls/admin.py 123456from django.contrib import adminfrom .models import Questionadmin.site.register(Question) 添加更多视图polls/views.py 123456789def detail(request, question_id): return HttpResponse("You're looking at question %s." % question_id)def results(request, question_id): response = "You're looking at the results of question %s." return HttpResponse(response % question_id)def vote(request, question_id): return HttpResponse("You're voting on question %s." % question_id) polls/urls.py 1234567891011121314from django.urls import pathfrom . import viewsurlpatterns = [ # ex: /polls/ path('', views.index, name='index'), # ex: /polls/5/ path('&lt;int:question_id&gt;/', views.detail, name='detail'), # ex: /polls/5/results/ path('&lt;int:question_id&gt;/results/', views.results, name='results'), # ex: /polls/5/vote/ path('&lt;int:question_id&gt;/vote/', views.vote, name='vote'),] 再往下，我感觉没有介绍的必要了，现在都是前后端分离，如何嵌入vue项目可以看我的上一个文章。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django2.1使用]]></title>
    <url>%2Fpost%2F218a770a.html</url>
    <content type="text"><![CDATA[介绍Python下有许多款不同的 Web 框架。Django是重量级选手中最有代表性的一位。许多成功的网站和APP都基于Django。 Django是一个开放源代码的Web应用框架，由Python写成。（来自菜鸟） 安装1py -3 -m pip install Django 创建项目1django-admin.py startproject HelloWorld 然后你发现并不好使，找了半天，发现是执行下面这句 1py -3 -m django startproject yinxs 接着执行 1python3 .\manage.py startup webdev 发现又不好使了 执行： 1python3 .\manage.py startapp webdev 启动项目 12python3 .\manage.py runserver 0.0.0.0:8000 之所以是0.0.0.0是为了让其他计算机也可以访问到 访问：http://127.0.0.1:8000/ 这句命令并没有改变 目录介绍如果是按照上面的步骤，那么咱们的目录应该是一样的，就算有一些修改，但是大体上没有影响 1234567891011__init__.py：让Python把该目录当成一个标准的开发包；settings.py：django项目的配置文件；urls.py：django项目的URL配置文件(尝试访问http://127.0.0.1:8000/admin/login/?next=/admin/)；wsgi.py：wsgi是Python语言定义的web服务器，为项目提供的一种服务接口；manage.py：命令行工具，可以用多种方式与该django项目进行交互；webdev: 新建的应用 我们进入webdev文件 1234567891011migrations/：记录models中的数据变更；admin.py：映射models中的数据到admin后台；apps.py：对创建的应用进行配置，比如新增文件；models.py：Django模型文件，创建应用程序的数据表模型；tests.py：创建测试用例；views.py：Django视图文件，控制向前端页面传输的内容； vue + django前端的话还是老样子，使用vue，下面我来讲解如何将Django2.1和vue结合到一起 构建vue项目1cnpm install -g vue-cli 1vue-init webpack fronted 1cd fronted 1cnpm i 1npm run build 准备工作-解决跨域问题1py -3 -m pip install django-cors-headers 修改settings.py 123456789101112MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'corsheaders.middleware.CorsMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]CORS_ORIGIN_ALLOW_ALL = True 耦合修改urls.py Django新版本改变导致URL中不需要再使用正则表达式了，只需要路径就OK了。 123456urlpatterns = [ path('admin/', admin.site.urls), path('', TemplateView.as_view(template_name="index.html")),] 修改settings.py 123456789101112131415TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': ['fronted/dist'], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 静态文件的搜索路径: 123STATICFILES_DIRS = [ os.path.join(BASE_DIR, "fronted/dist/static"),] 启动项目： 1python3 .\manage.py runserver 0.0.0.0:9000 访问：http://127.0.0.1:9000 数据库安装前后端融合完成，下面我们来写几个接口，首先我们要配置数据库。 1py -3 -m pip install mysqlclient 失败： whl下载地址 下载文件，执行 12py -3 -m pip install C:\Users\admin\Downloads\mysqlclient-1.3.13-cp35-cp35m-win_amd64.whl 注意你的版本号 1py -3 -m pip install PyMySQL 修改Django的工程同名子目录的init.py文件 12from pymysql import install_as_MySQLdbinstall_as_MySQLdb() 修改settings.py 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'myproject', 'USER': 'root', 'PASSWORD': 'root', 'HOST': '127.0.0.1', 'PORT': '3306' &#125;&#125; 操作1python3 manage.py shell 快速创建应用1python3 manage.py startapp polls 在polls下的views.py 12345from django.http import HttpResponse def index(request): return HttpResponse("Hello world!") 在polls下创建urls.py 1234567from django.urls import path from . import views urlpatterns = [ path('', views.index, name='index'),] 在根目录下的urls.py中 123456789from django.contrib import adminfrom django.urls import path,includefrom django.views.generic.base import TemplateViewurlpatterns = [ path('admin/', admin.site.urls), path('', TemplateView.as_view(template_name="index.html")), path('polls/', include('polls.urls')),] 访问： http://127.0.0.1:8000/admin/login/?next=/admin/ 当然访问这个要先创建一个管理员账号 管理员账号1python manage.py createsuperuser]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 构建微服务]]></title>
    <url>%2Fpost%2Ff3250ef9.html</url>
    <content type="text"><![CDATA[python构建微服务方案一架构Nameko + API Swagger 简介Nameko是一个让python程序员关注应用逻辑和测试的微服务框架。 项目1234py -2 -m pip install namekopy -2 -m pip install yagmailcd service nameko run service --broker amqp://guest:guest@localhost 123456py -2 -m pip install namekopy -2 -m pip install flaskpy -2 -m pip install flasggergit clone https://github.com/rochacbruno/nameko-example.gitcd apipython2 api.py 打开浏览器 http://localhost:5000/apidocs/index.html git 案例 nameko-example rabbitMQ安装-windows下 安装 rabbitMQ 及操作常用命令 安装成功后访问：http://localhost:15672/ rabbitMQ新增用户1rabbitmqctl.bat add_user username password rabbitMQ查询用户1rabbitmqctl.bat add_user username password 给用户超级管理员角色1rabbitmqctl.bat set_user_tags username administrator 修改密码1rabbitmqctl change_password userName newPassword 删除用户1rabbitmqctl.bat delete_user username 权限相关命令123456789101112131415## 设置用户权限rabbitmqctl set_permissions -p VHostPath User ConfP WriteP ReadP## 查看(指定hostpath)所有用户的权限信息rabbitmqctl list_permissions [-p VHostPath]## 查看指定用户的权限信息rabbitmqctl list_user_permissions User## 清除用户的权限信息rabbitmqctl clear_permissions [-p VHostPath] User dockerdocker安装教程 安装完成后记得配置环境变量 docker-compose1py -2 -m pip install docker-compose flaskFlask是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2 。Flask使用 BSD 授权。Flask也被称为 “microframework” ，因为它使用简单的核心，用 extension 增加其他功能。Flask没有默认使用的数据库、窗体验证工具。(来自百度) 初次使用flask_test.py12345678from flask import Flaskapp = Flask(__name__)@app.route("/")def hello(): return "Hello World!" if __name__ == "__main__": app.run() 执行123py -2 -m pip install flaskpython2 flask_test.py 打开 http://localhost:5000/ flasggerflasgger为在flask框架中使用的swagger，flasgger是flask支持的swagger UI，便于调试使用flask框架搭建的web api接口 参考文章 安装1py -2 -m pip install flasgger 案例上面的http://localhost:5000/apidocs/index.html 即为案例 配置解析12@app.route('/compute', methods=['POST'])@swag_from('compute.yml') compute.yml 123456789101112131415161718192021222324252627Micro Service Based Compute and Mail APIThis API is made with Flask, Flasgger and Nameko---parameters: - name: body in: body required: true schema: id: data properties: operation: type: string enum: - sum - mul - sub - div email: type: string value: type: integer other: type: integerresponses: 200: description: | Please wait the calculation, you'll receive an email with results parameters :参数配置GET方法：放置url中 POST方法：放置在schema responses :返回信息在这里介绍一篇文章，API文档自动生成工具apiDoc google-api-python-client谷歌正式推出Python版Google API客户端库 git地址 谷歌称，如果开发者想使用Google API构建一个Python应用程序，那么强烈建议使用该客户端库，因为该库可以帮助开发者轻松调用任何RESTful Google API，并抓取返回的数据。此外，该库还可以帮助开发者处理OAuth 2.0验证协议以及所有的错误，而无需写额外的代码。 (来自网络) 使用1pip install --upgrade google-api-python-client 版本支持Python Version Python 2.7, 3.4, 3.5, and 3.6 are fully supported and tested. (来自官网) pip网络问题解决由于网络原因，需要更改源 1pip install xlrd http://pypi.douban.com/simple/ --trusted-host pypi.douban.com 永久解决方案： 在pip安装目录（C:\Python27\pip-9.0.1\pip-9.0.1 这是我的目录）创建（.py）文件 1234567891011121314import os ini="""[global]index-url = https://pypi.doubanio.com/simple/[install]trusted-host=pypi.doubanio.com""" pippath=os.environ["USERPROFILE"]+"\\pip\\" if not os.path.exists(pippath): os.mkdir(pippath) with open(pippath+"pip.ini","w+") as f: f.write(ini) 执行，可以解决问题 兼容python2.7和python3（window版本）因为电脑中已经有版本2 进入：C:\Python27 安装目录下面 将python.exe改为python2.exe 执行： python2 -V 查看是否成功 同理 python 3也是同样操作，安装成功后改为python3.exe（默认安装目录：C:\Users\admin\AppData\Local\Programs\Python\Python37） 执行： python3 -V 查看是否成功 加上以下也可以 py 执行1#! python2 or #! python3 pip使用如下： 1234py -2 -m pip install XXXXpy -3 -m pip install XXXX pip升级1python -m pip install --upgrade pip 方案二Sanic模板来源-微服务Sanic制作一个简易本地restful API Sanic是一个支持 async/await 语法的异步无阻塞框架，Flask的升级版，效率更高，性能会提升不少 123456789101112131415# coding:utf-8 from sanic import Sanicfrom sanic.response import textapp = Sanic()@app.route("/")async def test(request): return text('Hello World!')if __name__ == "__main__": app.run(host="0.0.0.0", port=8000) 执行 123456py -3 -m pip install Sanic## 如果报错，执行py -3 -m pip install --upgrade pip## https://pypi.org/project/Sanic/#files 下载whl文件py -3 -m pip install C:\Users\admin\Downloads\httptools-0.0.11.tar.gzC:\Users\admin\Downloads\sanic-0.8.1-py3-none-any.whl]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目管理思考]]></title>
    <url>%2Fpost%2Ff4837afa.html</url>
    <content type="text"><![CDATA[前言：最近烂在自己手里的项目越来越多，思路也越来越混乱，所以特意去查了一下项目管理，如何解决现在的问题 首先是从我老大以及平常学到的东西： 1、是否是我的项目 背景：接了几个很急项目，但是职责上来说并不是我的工作范围 结果：需要我花费额外的成本去维护，造成我其他项目延期 2、成本 背景：项目每次重构需要花费时间，但是根据埋点统计，用户的使用量并不是很多 结果：没有盈利 3、沟通 背景：在最近的三个项目中，发现重构是经常发生的事情，动不动就需要代码重写，都是由于沟通 结果：延迟开发，人力浪费 4、架构 背景：同上，只不过原因是由于架构项目时，没有缕清思路 结果：同上 5、功能迭代 背景：网关平台需要迭代，我每次都是凭自己的兴趣去更新功能。 结果：没有实际的增加用户，该功能使用率不大 6、项目使用情况不好 背景： 公司的项目经常开发完没多久，就没人使用，因此下线 结果： 人力浪费 7、交接 背景：接手了好多原先的项目，但是只能负责项目的运行 结果：交接人员不当，交接内容不清，项目二次开发困难 8、项目管理排序 背景：手里的项目非常多（日常维护加上正常开发不下于10个） 结果：不知道如何项目排期，项目太多，心烦意乱 9、项目规划 多多参考大公司的项目架构，把架构想的完美，然后在这个基础上去做，如果成本不够则往下删减功能。 总结： 在工作中一定要注意以上九点。下面来谈一谈我从其他人(网络)那里借鉴的经验 如何做好项目管理：在项目管理中，需考虑五大要素，分别包含：成本，质量，进度，功能，持续发展力。一个好的管理者，应该要综合这五个要素，带领项目团队做好项目。 一、成本分为人工成本，差旅成本，采购成本，其中最主要的还是人工成本的控制，一个好的项目规划，必定要在项目确定之前，分析规划好人工成本，而这跟用户的需求是息息相关的，有了对用户需求的正确全面的判断，以及有效的用户需求管理，才能有效控制好成本支出，不因为不必要的需求变更导致成本的成倍增加，因此，要想做好该阶段的工作，除了用经验和能力做好成本预算之外，最关键的还是做好需求分析。 二、质量关键还是对需求的把握，用户的需求决定了项目所要的质量范围。是否要进行设计评审，是否要进行代码review，是否要进行单元测试，是否要进行性能测试，这些都由用户所要的效果和项目的价值，利润范围所决定。（如果已定项目价钱的话）如果项目价值高，客户有发展前景，那么质量的要求上理所当然要高点，倘若只是一些日常且价值低的项目，又或者只是一些很小且无潜在发展前景的客户，质量要求可以适当降低，以预算和项目组工作人员工作强度为重。而在质量的保证上，要尽量和客户多沟通交流，尽早让客户体验产品，通过客户的反馈和项目组内部的评审，来保证项目的质量。 三、项目进度首先得在计划阶段就确定好几个关键的时间节点，包括初验时间，换个直白的说法这是公司收钱的时间，至关重要，要放在主要位置，还有就是首个版本发布时间，需求调研时间，终验时间这三个。这些都是检验和保证项目的进度的途径和关键点，同时我们还得做好用户需求变更的准备，做好突发情况的应对方案，以有力保证项目进展顺利，按时按质完成。 四、功能首先要在需求上下功夫，确保项目设计和开发之前确定下的需求的正确性。在开发过程中不生搬硬套生命周期模型，可以适当的根据具体情况做相应的改动，以保证开发的顺利，要尽早的让客户试用，让客户参与对产品的评测，减少bug，实现客户的需求。 五、持续发展力一个项目的好坏，除了要对外满足客户的需求外，对内，还要看看能不能利用这个项目做点什么，而持续发展力的问题就体现在这里了。我们可否借这个项目发展内部的人员？增加内部技术的积累？尝试着在一些项目中做点新的变化，为以后的项目发展项目进化做点准备？是否可以借此项目稳定一些客户关系，一直做这些客户心目中的专家，方便日后的需求变更控制？这四种尝试都只是持续发展力的几个方面，一个项目若能在完成客户要求之余同时做到这四个方面，无疑是完美的，为此我们应该在做项目的过程中，一并把这些因素考虑进去，才能真正的做好一个项目。 借鉴 总结上面是我的感想以及网络借鉴来的知识，总结一些，首先你要考虑的是你是否要接手这个项目，接手之后是否需要花费时间去维护，当这个项目到了你的手里，你需要去架构这个项目，要去参考大公司的架构，一定要把项目设计的完美，功能一定要全面，然后计划自己的时间，先把核心的功能做出来，时间充足再去做扩展的功能，而且这些功能你一定要调研是否会产生价值。项目完成后，根据自己的需求来看看是否要进行设计评审，是否要进行代码review，是否要进行单元测试，是否要进行性能测试。]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[form-data接口 git错误 正则验证]]></title>
    <url>%2Fpost%2Ff9641aa3.html</url>
    <content type="text"><![CDATA[koa2 formdata接口今天在尝试项目koa-bodyparser 不解析 form-data接口传过来的参数 在网上查了一下解决方案 1cnpm i --save koa-body 1234const koaBody = require('koa-body');app.use(koaBody(&#123;multipart: true&#125;)); 这样就可以解析form-data git问题报错：error: RPC failed; HTTP 411 curl 22 The requested URL returned error: 411 Length Required 解决：git config http.postBuffer 524288000 验证邮箱以及电话的正则邮箱123456789module.exports = function checkMobile(s)&#123; let regu = /^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*\.[a-zA-Z0-9]&#123;2,6&#125;$/; let re = new RegExp(regu); if (re.test(s)) &#123; return true; &#125;else&#123; return false; &#125;&#125;; 电话（包含电话以及手机号码）1234567891011module.exports = function checkMobile(s)&#123; let regu1 = /^((1)+\d&#123;10&#125;)$/; let regu2 = /(^(\d&#123;3,4&#125;-)?\d&#123;6,8&#125;$)|(^(\d&#123;3,4&#125;-)?\d&#123;6,8&#125;(-\d&#123;1,5&#125;)?$)/; let re1 = new RegExp(regu1); let re2 = new RegExp(regu2); if (re1.test(s)||re2.test(s)) &#123; return true; &#125;else&#123; return false; &#125;&#125;;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node中webservice的使用]]></title>
    <url>%2Fpost%2F81a0d70b.html</url>
    <content type="text"><![CDATA[easy-soap-request下载1cnpm i --save easy-soap-request 使用1234const soapRequest = require('easy-soap-request')let response= await soapRequest(url, headers,xml);//url是地址，headers是请求头，xml是参数 源码修改在index.js中statusCode的参数改为response 这样你可以获取包括头的所有信息 node-koa2 支持xml下载1cnpm i --save koa-xml-body 添加1234app.use(xmlParser());//要放在bodyparser之前app.use(bodyparser(&#123; enableTypes:['json', 'form', 'text']&#125;)); xml与json互相转换下载1cnpm i --save xml2js 使用12345678const xml2js = require('xml2js');const xmlBuilder = new xml2js.Parser();const jsonBuilder = new xml2js.Builder();let xml = jsonBuilder.buildObject(json);//转jsonlet josn = xmlBuilder.parseString(xml);//转cml]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建mibew项目（开源人工客服系统）]]></title>
    <url>%2Fpost%2F60c9682d.html</url>
    <content type="text"><![CDATA[项目环境 php版本为5，千万别用7 apache mysql 具体安装可以参考我的博客在linux下部署PHP项目 git地址我在自己的git上配置过一个版本3的代码，可以借鉴。如果不喜欢请自己寻找其他版本的mibew git下载地址 代码源码地址1git clone git@github.com:Hughendman/mibew.git 部署修改apache文件 123/usr/local/apache2/confvim httpd.conf 我将项目下载到了/var/www下面 12345678910111213141516171819&lt;Directory /&gt; AllowOverride none Require all denied&lt;/Directory&gt;## Note that from this point forward you must specifically allow# particular features to be enabled - so if something's not working as# you might expect, make sure that you have specifically enabled it# below.### DocumentRoot: The directory out of which you will serve your# documents. By default, all requests are taken from this directory, but# symbolic links and aliases may be used to point to other locations.#DocumentRoot "/var/www"&lt;Directory "/var/www"&gt; 修改数据库配置 123cd /var/www/mibew/configsvim config.yml 12345678database: host: "localhost" port: 3306 db: "mibew" login: "root" pass: "abcd234" tables_prefix: "" use_persistent_connection: false 重启apache 1/usr/local/apache/bin/apachectl restart 应用访问：http://127.0.0.1/mibew/install.php 下载数据库 访问：http://127.0.0.1/mibew/index.php/operator/login 用户：admin 密码：admin 嵌入其他应用进入：http://127.0.0.1/mibew/index.php/operator/button-code 可以获取嵌入代码。 例如： 1&lt;!-- mibew button --&gt;&lt;a id="mibew-agent-button" href="/mibew/index.php/chat?locale=en" target="_blank" onclick="Mibew.Objects.ChatPopups['5b7126f35626d57a'].open();return false;"&gt;&lt;img src="/mibew/index.php/b?i=mibew&amp;amp;lang=en" border="0" alt="" /&gt;&lt;/a&gt;&lt;script type="text/javascript" src="/mibew/js/compiled/chat_popup.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;Mibew.ChatPopup.init(&#123;"id":"5b7126f35626d57a","url":"\/mibew\/index.php\/chat?locale=en","preferIFrame":true,"modSecurity":false,"forceSecure":false,"width":640,"height":480,"resizable":true,"styleLoader":"\/mibew\/index.php\/chat\/style\/popup"&#125;);&lt;/script&gt;&lt;!-- / mibew button --&gt; 修改一下： 12&lt;!-- mibew button --&gt;&lt;a id="mibew-agent-button" href="http://127.0.0.1/mibew/index.php/chat?locale=en" target="_blank" onclick="Mibew.Objects.ChatPopups['5b7126f35626d57a'].open();return false;"&gt;&lt;img src="http://127.0.0.1/mibew/index.php/b?i=mibew&amp;amp;lang=en" border="0" alt="" /&gt;&lt;/a&gt;&lt;script type="text/javascript" src="http://127.0.0.1/mibew/js/compiled/chat_popup.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;Mibew.ChatPopup.init(&#123;"id":"5b7126f35626d57a","url":"http://127.0.0.1\/mibew\/index.php\/chat?locale=en","preferIFrame":true,"modSecurity":false,"forceSecure":false,"width":640,"height":480,"resizable":true,"styleLoader":"http://127.0.0.1\/mibew\/index.php\/chat\/style\/popup"&#125;);&lt;/script&gt;&lt;!-- / mibew button --&gt; 这样就可以使用了。 进入 http://127.0.0.1/mibew/index.php/operator/users 可以操作了 一下为实例： 如果你嵌入代码成功，你会在你的代码中发现这样一个按钮 点击这个按钮，会在页面右侧弹出 下面介绍以下管理员页面：]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在linux下部署PHP项目]]></title>
    <url>%2Fpost%2F8197eef2.html</url>
    <content type="text"><![CDATA[安装httpd下载http://httpd.apache.org/download.cgi 我下载的版本为httpd-2.4.34.tar.gz 安装12345678mkdir /usr/local/apache2tar -zxvf httpd-2.4.34.tar.gz cd httpd-2.4.34./configure --prefix=/usr/local/apache2 --enable-module=shared 到这可能会报错 12checking for APR... noconfigure: error: APR not found. Please read the documentation. 解决方案： 12345678910111213141516171819202122232425262728293031323334353637# APRmkdir /usr/local/aprcd /usr/local/aprwget http://archive.apache.org/dist/apr/apr-1.5.2.tar.gztar -xvzf apr-1.5.2.tar.gz cd apr-1.5.2./configure --with-apr=/usr/local/aprmakemake install# APR Utilsmkdir /usr/local/apr-utilcd /usr/local/apr-utilwget http://archive.apache.org/dist/apr/apr-util-1.5.2.tar.gztar xvzf apr-util-1.5.2.tar.gzcd apr-util-1.5.2 ./configure --with-apr=/usr/local/apr --prefix=/usr/local/apr-utilmakemake install 继续执行 12345678cd /usr/local/apache2/httpd-2.4.34./configure --with-apr-util=/usr/local/apr-util --prefix=/usr/local/apache2 --enable-module=sharedmakemake install 启动Apache：/usr/local/apache2/bin/apachectl start 停止Apache：/usr/local/apache2/bin/apachectl stop 重启Apache：/usr/local/apache2/bin/apachectl restart 访问 ip:80 安装PHP下载 http://www.php.net/downloads.php 1234567mkdir /usr/local/phpcd /usr/local/php/tar xvzf php-7.1.20.tar.gz./configure --prefix=/usr/local/php --with-apxs2=/usr/local/apache2/bin/apxs --with-mysql=/var/lib/mysql/ 可能会报错mysql的 1./configure --prefix=/usr/local/php --with-apxs2=/usr/local/apache2/bin/apxs --with-config-file-path=/usr/local/lib --enable-track-vars --with-xml --with-mysql-dir=/usr/include/mysql/mysql.h --with-zlib-dir=/usr/lib 继续执行： 12345makemake installcp php.ini-production /usr/local/lib/php.ini 测试： 12345678910111213cd /usr/local/apache2/htdocstocuh test.phpvim test.phpi&lt;?php phpinfo(); ?&gt; 访问：ip/test.php 让apach支持php1234567891.检查apache的配置文件看是否加载了libphp5.so模块，若没有就添加LoadModule php5_module modules/libphp5.so2.在&lt;IfModule mime_module&gt;模块中看是否添加有php页面，若没有就添加AddType application/x-httpd-php .php .php3 .php43.在&lt;IfModule dir_module&gt;模块的DirectoryIndex后添加index.php 修改默认站点12345678910111213141516171819&lt;Directory /&gt; AllowOverride none Require all denied&lt;/Directory&gt;## Note that from this point forward you must specifically allow# particular features to be enabled - so if something's not working as# you might expect, make sure that you have specifically enabled it# below.### DocumentRoot: The directory out of which you will serve your# documents. By default, all requests are taken from this directory, but# symbolic links and aliases may be used to point to other locations.#DocumentRoot "/usr/local/apache2/htdocs"&lt;Directory "/usr/local/apache2/htdocs"&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flume学习]]></title>
    <url>%2Fpost%2Fdb6d0071.html</url>
    <content type="text"><![CDATA[Flume来自于百度的介绍 Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。 当前Flume有两个版本Flume 0.9X版本的统称Flume-og，Flume1.X版本的统称Flume-ng。由于Flume-ng经过重大重构，与Flume-og有很大不同，使用时请注意区分。 功能 flume 是一个分布式的，可靠的，可用的，非常有效率的对大数据量的日志数据进行收集，聚集，移动信息的服务。flume 仅支持在linux上面运行. flume 是一个基于流式数据，非常简单（就写一个配置文件就可以），灵活的架构，一个健壮的，容错的，简单的扩展数据模型用于在线上实时应用分析， 他的表现为：写一个source，channel，sink 之后一条命令就能够操作成功了。 flume ， kafka 实时进行数据收集，spark , storm 实时去处理，impala 实时去查询。 安装123wget "http://mirrors.cnnic.cn/apache/flume/1.6.0/apache-flume-1.6.0-bin.tar.gz"tar -xzvf apache-flume-1.6.0-bin.tar.gzmv flume-1.6.0 /opt 修改配置文件1vim /opt/flume-1.6.0/conf/flume.conf 1234567891011121314151617181920# 指定Agent的组件名称a1.sources = r1a1.sinks = k1a1.channels = c1# 指定Flume source(要监听的路径)a1.sources.r1.type = spooldira1.sources.r1.spoolDir = /root/path# 指定Flume sinka1.sinks.k1.type = logger# 指定Flume channela1.channels.c1.type = memorya1.channels.c1.capacity = 1000a1.channels.c1.transactionCapacity = 100# 绑定source和sink到channel上a1.sources.r1.channels = c1a1.sinks.k1.channel = c1 启动flume agent123cd /opt/flume-1.6.0bin/flume-ng agent --conf conf --conf-file conf/flume.conf --name a1 -Dflume.root.logger=INFO,console 使用1cp 1.log /root/path/ 参考Flume的下载安装]]></content>
      <categories>
        <category>flume</category>
      </categories>
      <tags>
        <tag>flume</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[压力测试(siege)）]]></title>
    <url>%2Fpost%2F448930f9.html</url>
    <content type="text"><![CDATA[安装下载下载地址 安装命令12345tar -xzvf siege-2.70.tar cd siege-2.70./configuremake make install 验证1siege -version get1siege -c 200 -r 100 http://192.168.19.5:11111/hotel/word?hotelname=%E5%8C%97%E4%BA%AC%E9%A5%AD%E5%BA%97&amp;amp;num=5 返回： 123456789101112ransactions: 19509 hits //访问次数Availability: 97.55 % //成功次数Elapsed time: 553.68 secs //测试用时Data transferred: 8.87 MB //测试传输数据量Response time: 4.84 secs //平均响应时间Transaction rate: 35.24 trans/sec //每秒事物处理量Throughput: 0.02 MB/sec //吞吐率Concurrency: 170.51 //并发用户数Successful transactions: 19509 //成功传输次数Failed transactions: 491 //失败传输次数Longest transaction: 28.75 //最长响应时间Shortest transaction: 0.04 //最短响应时间 post1siege "http://192.168.14.6:3100/route/hotel/word POST &#123;"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoi5bC56Zuq5p2-IiwicHdkIjoiYWJjZDIzNCIsImVtYWlsIjoieHVlc29uZ195aW5AMTI2LmNvbSIsInRlbGVwaG9uZSI6IjE4ODExNDI4NDUyIiwiaWF0IjoxNTMxODA1Njg5fQ.yVqCj26HeB3MAwbqoXyOdvz9-9vY_gCCwdUB1F60I3w","hotelname":"北京饭店","num":5&#125;" -r 1000 -c 200 返回： 123456789101112ransactions: 20000 hitsAvailability: 100.00 %Elapsed time: 66.88 secsData transferred: 1.74 MBResponse time: 0.02 secsTransaction rate: 299.04 trans/secThroughput: 0.03 MB/secConcurrency: 5.43Successful transactions: 20000Failed transactions: 0Longest transaction: 0.49Shortest transaction: 0.00 日志想要打上日志 1创建：/usr/local/var/siege.log]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot数据库操作(4)]]></title>
    <url>%2Fpost%2Fe57b58e0.html</url>
    <content type="text"><![CDATA[修改pom.xml12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; 修改application123456789101112131415161718192021222324252627###########################################################datasource########################################################spring.datasource.url = jdbc:mysql://localhost:3306/testspring.datasource.username = rootspring.datasource.password = abcd234spring.datasource.driverClassName = com.mysql.jdbc.Driverspring.datasource.max-active=20spring.datasource.max-idle=8spring.datasource.min-idle=8spring.datasource.initial-size=10########################################################### Java Persistence Api######################################################### Specify the DBMSspring.jpa.database = MYSQL# Show or not log for each sql queryspring.jpa.show-sql = true# Hibernate ddl auto (create, create-drop, update)spring.jpa.hibernate.ddl-auto = update# Naming strategyspring.jpa.hibernate.naming-strategy = org.hibernate.cfg.ImprovedNamingStrategy# stripped before adding them to the entity manager)spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5Dialect 测试新建一个类User.java;1234567891011121314151617181920212223242526272829303132package com.example.demo;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;/** * Created by LM on 2017/8/6. */@Entitypublic class User&#123; @Id @GeneratedValue private long id; private String name; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 重新运行，在navicat中查看发现多了一个user表 深入操作建表ddl-auto:create会新建一个表如果你之前有这个表会被删掉User.java1234567891011121314151617181920212223242526272829303132333435363738394041package com.example.demo;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;/** * Created by LM on 2017/8/6. */@Entitypublic class User&#123; @Id @GeneratedValue private long id; private String name; private Integer age; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 运行，多了age一列 ddl-auto: update 不会删掉，会保留ddl-auto: create-drop 应用停下来删掉表ddl-auto: none 什么都不做validate：验证是否一致，不一致报错 写API操作数据库get接口读取user表新建一个类：UserController.java12345678910111213141516171819package com.example.demo;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class UserController &#123; @Autowired private UserRepository userRepository; @GetMapping(value = "users") public List&lt;User&gt; userList()&#123; return userRepository.findAll(); &#125;&#125; 新建一个Interface ：UserRepository1234567package com.example.demo;import org.springframework.data.jpa.repository.JpaRepository;public interface UserRepository extends JpaRepository&lt;User, Integer&gt;&#123;&#125; 重启：http://127.0.0.1:8080/users 返回1234567[ &#123; "id": 1, "name": "yinxs", "age": 12 &#125;] 新增一条user信息在UserController.java中添加 12345678910@PostMapping(value = "/user") public User userAdd(@RequestParam("name") String name,@RequestParam("age") Integer age)&#123; User user = new User(); user.setName(name); user.setAge(age); return userRepository.save(user); &#125; 重启：http://127.0.0.1:8080/users name:yin age:16 返回12345&#123; "id": 3, "name": "yin", "age": 16&#125; 错误处理1org.hibernate.TypeMismatchException: Provided id of the wrong type for class com.example.demo.User. Expected: class java.lang.Long, got class java.lang.Integer 原因：id的类型不对 1could not execute statement; SQL [n/a]; constraint [PRIMARY]; nested excepti... 原因：数据库被修改 参考springboot链接数据库 两小时学会springboot]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JWT（JSON Web Tokens）]]></title>
    <url>%2Fpost%2Fa13f356a.html</url>
    <content type="text"><![CDATA[JWT互联网服务认证现在一种非常流行的方式就是服务器索性不保存session数据，所以数据都保存在客户端，每次请求都发挥服务器，JWT就是这种方案的一个代表 原理服务器认证之后，生成一个JSON对象，发回给用户 1234&#123; name: 'yinxs', email: '**'&#125; 在以后的通信中都需要带上这个对象 数据格式JWT分为三个部分，如下 123Header(头部)Payload(负载)Signature(签名) 也就是Header.Payload.Signature HeaderHeader是一个json对象，描述JWT的元数据，如下： 1234&#123; "alg":"HS256", "typ":"JWT"&#125; alg代表着签名的算法(algorithm),默认HMAC SHA256(写成HS256)； typ属性表示这个令牌(token)的类型(type),JWT令牌统一写JWT 将上面的JSON对象使用Base64URL算法转成字符串 payloadPauload用来存放实际需要传递的数据。JWT提供了7个官方字段，供选用： 1234567iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号 但是你也可以定义私有字段，就像我一开始做的那样 注意：JWT默认是不加密的，任何人都可以读到，所以不要把私密信息放在这个部分 这个 JSON 对象也要使用 Base64URL 算法转成字符串 SignatureSignature部分是对前两部分的签名，防止数据篡改 首先需要指定一个密钥（secret）。这个密钥只有服务器知道，不能泄露给用户。然后使用Header里面指定签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。12345HMACSHA256( base64UrlEncode(Header) + "." + base64UrlEncode(payload) + "." + secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户 注： Base64URL Base64URL跟 Base64 算法基本类似，但有一些小的不同。 JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 使用方法客户端收到服务器返回的JWT，可以存储在Cookie中，也可以存储在localStroage。 另外的一种做法：跨域的时候，JWT就放在POST请求body中或者get请求的参数后面。 特点 JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 JWT 不加密的情况下，不能将秘密数据写入 JWT。 JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot中Controller（3）]]></title>
    <url>%2Fpost%2Ff1abdc1.html</url>
    <content type="text"><![CDATA[Controller的使用12345@Controller: 处理http请求@RestController： Spring4之后新加的注解，原来返回json需要@ResponseBody配合@Controller@RequestMapping：配置url映射 实例12345678910111213141516package com.example.demo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;@Controllerpublic class HelloController &#123; @Autowired private boyProperties boyProperties; @RequestMapping(value="/hello",method=RequestMethod.GET) public String say()&#123; return boyProperties.getSize(); &#125;&#125; 启动，发现访问不了，必须配合模板使用 在pom.xml中添加 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 刷新一下pom包（idea需要刷新，eclipse不需要）然后在resourses目录下新建一个目录：templates，在这个目录下新建一个html（index.html） 1&lt;h2&gt;Hello Spring Boot&lt;/h2&gt; 重启：访问 http://127.0.0.1:9111/dev/hello RequestMapping(url映射)可以将value值写成一个集合 123456789101112package com.example.demo;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;@Controllerpublic class HelloController &#123; @RequestMapping(value= &#123;"/hello","/hi"&#125;,method=RequestMethod.GET) public String say()&#123; return "index"; &#125;&#125; 访问；http://127.0.0.1:9111/dev/hi和http://127.0.0.1:9111/dev/hello效果是一样的 另一种方式： 123456789101112package com.example.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class YinxsBootApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(YinxsBootApplication.class, args); &#125;&#125; 访问：http://127.0.0.1:9111/dev/hello/say RequestMapping中method的其他方式 我们常用的方式就是GET和POST方式12345678910111213package com.example.demo;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;@Controller@RequestMapping("/hello")public class HelloController &#123; @RequestMapping(value= "/say",method=RequestMethod.POST) public String say()&#123; return "index"; &#125;&#125; 我们在浏览器就访问不可；可以使用postman的post方式。如果你什么方式都不写，那么post和get就兼容了。但是不推荐。 处理参数12345@PathVariable 获取url中的数据@RequestParam 获取请求参数中的值@GetMapping 组合注解 url中代码：12345678910111213package com.example.demo;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping("/hello")public class HelloController &#123; @RequestMapping(value= "/say/&#123;id&#125;",method=RequestMethod.GET) public String say(@PathVariable("id") Integer id)&#123; return "id: " + id; &#125;&#125; 访问：http://127.0.0.1:9111/dev/hello/say/1 返回：id：1 传统方法123456789101112package com.example.demo;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping("/hello")public class HelloController &#123; @RequestMapping(value= "/say",method=RequestMethod.GET) public String say(@RequestParam("id") Integer myId)&#123; return "id: " + myId; &#125;&#125; 不管是get还是post都是@RequestParam 访问：http://127.0.0.1:9111/dev/hello/say?id=1111 返回：id：1111 如果不传id设置一个默认值 123456789101112package com.example.demo;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping("/hello")public class HelloController &#123; @RequestMapping(value= "/say",method=RequestMethod.GET) public String say(@RequestParam(value = "id",required = false,defaultValue = "0") Integer myId)&#123; return "id: " + myId; &#125;&#125; 这样访问不传id默认为0 GetMapping1234567891011121314package com.example.demo;import org.springframework.web.bind.annotation.*;@RestController@RequestMapping("/hello")public class HelloController &#123; // @RequestMapping(value= "/say",method=RequestMethod.GET) @GetMapping(value = "/say") public String say(@RequestParam(value = "id",required = false,defaultValue = "0") Integer myId)&#123; return "id: " + myId; &#125;&#125; 同注释掉的功能 PostMapping同post方式]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot配置文件（2）]]></title>
    <url>%2Fpost%2Ff3c575c4.html</url>
    <content type="text"><![CDATA[eclipse没有提示解决点击window =&gt; Preferences 找到java下面的Editor下的Content Assist 将Auto activation delay的值改小一点 然后将Anto activation triggers for Java 的值改成 .abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVW 第一个实例 Hello Spring Boot新建一个controllerHelloController12345678910package com.example.demo;import org.springframework.web.bind.annotation.*;@RestControllerpublic class HelloController &#123; @RequestMapping(value="/hello",method=RequestMethod.GET) public String say()&#123; return "Hello Spring Boot"; &#125;&#125; 重启 访问：http://127.0.0.1:8080/hello 属性配置；项目的配置文件：application.properties12server.port=8081server.context-path=/boy 重启：http://127.0.0.1:8081/boy/hello 但是在这里推荐使用:application.yml(application.properties删掉) 格式如下 123server: port: 8082 context-path: /boy 配置文件的使用123456server: port: 8082 context-path: /boysize: boyage: 10content: "size: $&#123;size&#125;,age: $&#123;age&#125;" 调用： 1234567891011121314151617181920package com.example.demo;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.*;@RestControllerpublic class HelloController &#123; @Value("$&#123;size&#125;") private String size; @Value("$&#123;age&#125;") private Integer age; @Value("$&#123;content&#125;") private String content; @RequestMapping(value="/hello",method=RequestMethod.GET) public String say()&#123; return content; &#125;&#125; 高级使用方式.yml文件 123456server: port: 8082 context-path: /boyboy: size: boy age: 10 新建一个类boyProperties: 1234567891011121314151617181920package com.example.demo;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = "boy")public class boyProperties &#123; private String size; private Integer age; public String getSize() &#123; return size; &#125; public void setSize(String size) &#123; this.size = size; &#125; &#125; 在HelloController中使用 123456789101112131415package com.example.demo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.*;@RestControllerpublic class HelloController &#123; @Autowired private boyProperties boyProperties; @RequestMapping(value="/hello",method=RequestMethod.GET) public String say()&#123; return boyProperties.getSize(); &#125;&#125; 重启，页面显示boy 开发环境和生产环境配置新建两个yml文件 123application-dev.ymlapplication-prod.yml dev 123456server: port: 9111 context-path: /devboy: size: boy_dev age: 10 prod 123456server: port: 9112 context-path: /prodboy: size: boy_prod age: 10 修改application.yml 123spring: profiles: active: dev 启动 访问：http://127.0.0.1:9111/dev/hello 再修改application.yml 123spring: profiles: active: prod 启动 访问：http://127.0.0.1:9112/prod/hello 小知识： netstat -a 在cmd中可以查看哪些端口被占用了 另外的启动方式：jar 12java -jar ****.jar --spring.profiles.active=prod 总结注解1234567@Value实现配置内容的注入@Component@ConfigurationProperties上面这两个是用来对配置进行分解 多环境配置]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速创建springboot项目(1)]]></title>
    <url>%2Fpost%2Ff7ca40ba.html</url>
    <content type="text"><![CDATA[idea参考慕课网 构建项目 运行 打开80端口 eclipse构建项目 最后点击finish 运行 错误处理在eclipse运行时失败，要进入项目目录执行mvn clean install，再回到eclipse重新执行即可 如果你打开之后发现没有运行tomcat，修改spring boot的版本号。（目前我使用的是1.4.7）]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你node发送邮件]]></title>
    <url>%2Fpost%2Fcd60cfe6.html</url>
    <content type="text"><![CDATA[使用插件nodemailer1cnpm i --save nodemailer CODE1234567891011121314151617181920212223242526const nodemailer = require('nodemailer');let transporter = nodemailer.createTransport(&#123; service: '126', auth: &#123; user: 'xuesong_yin@126.com', pass: 'y2001129' //授权码 &#125; &#125;); let mailOptions = &#123; from: 'xuesong_yin@126.com', // 发送者 to: 'yinxs@jointwisdom.cn', // 接受者,可以同时发送多个,以逗号隔开 subject: 'YINXS博客', // 标题 html: `&lt;h2&gt;YINXS博客&lt;/h2&gt;&lt;p&gt;http://hughendman.github.io&lt;/p&gt;` &#125;; transporter.sendMail(mailOptions, function (err, info) &#123; if (err) &#123; console.log(err); return; &#125; console.log('发送成功'); &#125;); 发送附件123456789101112131415161718192021222324252627282930313233let transporter = nodemailer.createTransport(&#123; service: '126', auth: &#123; user: 'xuesong_yin@126.com', pass: 'y2001129' //授权码 &#125; &#125;); let mailOptions = &#123; from: 'xuesong_yin@126.com', // 发送者 to: 'yinxs@jointwisdom.cn', // 接受者,可以同时发送多个,以逗号隔开 subject: 'YINXS博客', // 标题 html: `&lt;h2&gt;YINXS博客&lt;/h2&gt;&lt;p&gt;http://hughendman.github.io&lt;/p&gt;`, attachments:[ &#123; filename : 'package.json', path: './package.json' &#125;, &#123; filename : 'content', content : '发送内容' &#125; ] &#125;; transporter.sendMail(mailOptions, function (err, info) &#123; if (err) &#123; console.log(err); return; &#125; console.log('发送成功'); &#125;); 注意你的信息中在html里面不要包含https,不管是在p标签中还是在a标签中 参考nodejs模块nodemailer基本使用-邮件发送(支持附件)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API文档自动生成工具apiDoc]]></title>
    <url>%2Fpost%2F652bf3bd.html</url>
    <content type="text"><![CDATA[最近写项目的时候不打算一边写接口一边写前端，感觉这样写很混乱，所以打算先把后端的接口完成，前端先放在后面，但是写完了接口时经常发现自己忘记写了哪些，所以要写一个API的文档，下面我来介绍一个非常方便的工具，API文档自动生成工具apiDoc。 安装1npm install apidoc -g 执行1apidoc -v 出现： 123456warn: Please create an apidoc.json configuration file.verbose: apidoc-generator name: apidocverbose: apidoc-generator version: 0.17.6verbose: apidoc-core version: 0.8.3verbose: apidoc-spec version: 0.3.0verbose: run parser 安装成功 生成文档在目录里面放一个apidoc.json 123456789101112&#123; "name": "Apidoc Example", "version": "1.0.0", "description": "Apidoc Example descrption", "title": "Custom apiDoc browser title", "url" : "http://localhost:8000/api/v1", "sampleUrl": "http://localhost:8000/api/v1", "template": &#123; "withCompare": true, "withGenerator": true &#125;&#125; 我把路由全部放在routes里面，生成的apidoc直接打开index.html就可以访问1apidoc -i routes/ -o apidoc/ # 可以通过搜索routes目录中的文件快速的生成文档文件，并将这些文件放在apidoc目录下。 注释格式你需要写特定注释才可以生成。 举个例子 123456789101112131415161718192021222324252627/** * * @api &#123;post get&#125; /&#123;model&#125;/query 查询数据 * @apiName query * @apiGroup 业务单元基础 * @apiVersion 1.0.0 * @apiDescription 接口详细描述 * * @apiParam &#123;Object&#125; body 请求参数JSON对象 * * @apiSuccess &#123;String&#125; status 结果码 * @apiSuccess &#123;String&#125; message 消息说明 * @apiSuccessExample Success-Response: * HTTP/1.1 200 OK * &#123; * code:1, * message:'success', * data:&#123;total:100, result:[]&#125; * &#125; * @apiErrorExample &#123;json&#125; Error-Response: * HTTP/1.1 200 * &#123; * code:0, * message:'user not found', * &#125; * @apiPermission Auth */ 展示]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[术语总结]]></title>
    <url>%2Fpost%2Ffacec4eb.html</url>
    <content type="text"><![CDATA[发布 蓝绿部署 A/B测试 灰度发布 蓝绿部署蓝绿部署是一种以可预测的方式发布应用的技术，目的是是安全稳定地发布新版本应用，并在必要时回滚。 你需要准备两个相同的环境(以下称为蓝色和绿色环境)，在蓝色环境中运行当前生产环境中的应用（旧版本），在率环境中运行新版本的应用，并进行测试。如果没有问题就把负载均衡器/反向代理/路由指向蓝色环境。 A/B测试A/B测试是用来测试应用功能表现的方法。例如可用性、受欢迎程度、可见性等等。一般应用在前端上。 A/B测试目的在于通过科学的实验设计、采样样本代表性、流量分割与小流量测试等方式来获得具有代表性的实验结论，并确信该结论在推广到全部流量可信 灰度发布／金丝雀发布灰度发布是在原有版本可用的情况下，同时部署一个新版本应用作为“金丝雀”（金丝雀对瓦斯极敏感，矿井工人携带金丝雀，以便及时发发现危险），测试新版本的性能和表现，以保障整体系统稳定的情况下，尽早发现、调整问题。 灰度发布／金丝雀发布由以下几个步骤组成： 准备好部署各个阶段的工件，包括：构建工件，测试脚本，配置文件和部署清单文件。 从负载均衡列表中移除掉“金丝雀”服务器。 升级“金丝雀”应用（排掉原有流量并进行部署）。 对应用进行自动化测试。 将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）。 如果“金丝雀”在线使用测试成功，升级剩余的其他服务器。（否则就回滚） 负载均衡负载均衡(Load Balance，简称LB)是一种服务器或网络设备的集群技术。负载均衡将特定的业务(网络服务、网络流量等)分担给多个服务器或网络设备，从而提高了业务处理能力，保证了业务的高可用性。负载均衡基本概念有：实服务、实服务组、虚服务、调度算法、持续性等 nginx 反向代理和负载均衡网站的访问量越来越大，服务器的服务模式也得进行相应的升级，比如分离出数据库服务器、分离出图片作为单独服务，这些是简单的数据的负载均衡，将压力分散到不同的机器上。有时候来自web前端的压力，也能让人十分头痛。怎样将同一个域名的访问分散到两台或更多的机器上呢？这其实就是另一种负载均衡了，nginx自身就可以做到，只需要做个简单的配置就行。 nginx不单可以作为强大的web服务器，也可以作为一个反向代理服务器，而且nginx还可以按照调度规则实现动态、静态页面的分离，可以按照轮询、ip哈希、URL哈希、权重等多种方式对后端服务器做负载均衡，同时还支持后端服务器的健康检查。 请求分片Node.js 中实现 HTTP 206 内容分片地址 无感知动态扩容1.是无感知，即用户来说服务ip和port保持不变 2.动态扩容，指的是在需要时刻可以按照业务增加接口。 服务熔断服务熔断一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，所以很多地方把熔断亦称为过载保护。]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API Gateway功能]]></title>
    <url>%2Fpost%2Fb8717e5.html</url>
    <content type="text"><![CDATA[前面两篇从其他地方抄来的文章主要是介绍以下微服务以及API Gateway ，以下就是我实现的API Gateway主要的功能以及实现的思路 技术选型由于本人技术限制，大家已经猜到了 node（koa2） + mysql + VUE + nginx 前端和mysql没什么好说的，纯粹是我最熟悉就是他们两个了 对于大多数应用程序而言，API网关的性能和可扩展性通常都非常重要。因此，将 API网关构建在一个支持异步、I/O非阻塞的平台上是合理的。有多种不同的技术可以用于实现一个可扩展的API网关。在JVM上，可以使用一种基于 NIO的框架，比如Netty、Vertx、Spring Reactor或JBoss Undertow中的一种。一个非常流行的非JVM选项是Node.js，它是一个以Chrome JavaScript引擎为基础构建的平台。 功能实现API网关作为微服务的入口点这是API网关的基本功能 为了实现这个功能，我需要有一个具体的方案 因为gs的需求，我们只有http或者https两种，其他的协议方式可以留到以后进行优化 一般分为两种get/post请求方式get方式参数一： url 参数二：参数：query 参数三：gateway 地址 post方式参数一： url 参数二：参数：props 参数三：gateway 地址 技术实现1npm install --save request get 123456const request = require('request');request('您的请求url', function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; console.log(body) // 请求成功的处理逻辑 &#125;&#125;); post 1234567891011121314151617const request = require('request');let url="请求url";let requestData="参数对象";request(&#123; url: url, method: "POST", json: true, headers: &#123; "content-type": "application/json", &#125;, body: JSON.stringify(requestData)&#125;, function(error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; console.log(body) // 请求成功的处理逻辑 &#125;&#125;); post form 123456789const request = require('request');let url="请求url";let formData="参数对象";request.post(&#123;url:url, form:formData&#125;, function(error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; console.log(body) // 请求成功的处理逻辑 &#125;&#125;) 匹配路由（原方案是动态生成路由，不能满足方案，已放弃） 利用正则模糊匹配，根据参数决定具体的逻辑 匹配任何字符：[\s\S]* 没有成功 12345678910111213141516171819const router = require('koa-router')()router.prefix('/api')let arr = [];let obj = "";for(let i=0;i&lt;20;i++)&#123; obj = obj + "/:id"; arr.push(obj);&#125;arr.forEach(function(item,index)&#123; router.get(item,async function (ctx, next) &#123; let data; ctx.body = 'this is a users response!' &#125;)&#125;);module.exports = router 认证使用access_token 每一个url根据用户生成一个assess_token，状态码为1（true）或者0（false） 12access_token = md5('path名称'+'日期'+'方法名'+'模块名'+'随机字符串') 数据聚合可能是两个接口的数据的聚合 熔断token认证中的状态码控制 监控log4js日志收集响应日志，通过响应日志监控 每天会将日志导入到数据库中]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue+koa2+mysql]]></title>
    <url>%2Fpost%2Fc688e256.html</url>
    <content type="text"><![CDATA[koa2_vuegit：git@github.com:Hughendman/koa2_vue.git 邮箱 xuesong_yin@126.com 微信 wxid_reb7kk3h8om122 一个搭建好的项目，可以拿来直接开发，里面的架构已经替你完成，前端使用vue（可以在这koa2-vue/public下进行更替），后端使用koa2使用： cd koa2-vue 执行npm i 下载完成后执行 npm run dev 访问：http://127.0.0.1:3000 前端开发：cd koa2-vue/public/fronted 执行npm i 下载完成后执行 npm run dev 访问：http://127.0.0.1:8080 前端构架已经解决：2018/6/8 引入全局css样式 (static/css/global.css) 引入elementUI框架 引入axios1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// get方式this.$http.get('/user?name=yinxs') .then( (response) =&gt; &#123; console.log(response); &#125;) .catch( (error) =&gt; &#123; console.log(error); &#125;);// get方式第二种this.$http.get('/user', &#123; params: &#123; name: 'yinxs' &#125; &#125;) .then( (response) =&gt; &#123; console.log(response); &#125;) .catch( (error) =&gt; &#123; console.log(error); &#125;);//post 方法this.$http.post('/user', &#123; firstName: 'Xuesong', lastName: 'Yin' &#125;) .then( (response) =&gt; &#123; console.log(response); &#125;) .catch( (error) =&gt; &#123; console.log(error); &#125;);//执行多个并发请求 getUser =&gt; () &#123; return this.$http.get('/tj/user/12345');&#125; getApp =&gt; () &#123; return axios.get('/tj/app/123');&#125;this.$http.all([getUser(), getApp()]) .then(this.$http.spread( (res1, res2) =&gt; &#123; // 两个请求现在都执行完成 &#125;)); 后端构架已经解决：2018/6/7 跨域问题 （”koa2-cors”: “^2.0.5”） 日志 （”log4js”: “^0.6.38”）（/koa2-vue/public/logs/error || /koa2-vue/public/logs/response（响应日志格式：年月日 时分秒 信息 get/post 接口 ip 参数 状态码 响应内容）） sql架构 (数据库配置：koa2-vue/public/config/database.js)（所有的sql语句统一管理，放在koa2-vue/public/javascripts/database目录下面，一个数据库一个js文件）（在user.js文件中有使用案例）]]></content>
      <categories>
        <category>koa2</category>
      </categories>
      <tags>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API Gateway]]></title>
    <url>%2Fpost%2F83d1d1c.html</url>
    <content type="text"><![CDATA[API Gateway百度介绍： API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。 API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。 下图解释了API Gateway的作用 为什么需要API Gateway可以参考以下两张图片： 从部署结构上说，上图是不采用API Gateway的微服务部署模式，我们可以清晰看到，这种部署模式下，客户端与负载均衡器直接交互，完成服务的调用。但这是这种模式下，也有它的不足。 不支持动态扩展，系统每多一个服务，就需要部署或修改负载均衡器。 无法做到动态的开关服务，若要下线某个服务，需要运维人员将服务地址从负载均衡器中移除。 对于API的限流，安全等控制，需要每个微服务去自己实现，增加了微服务的复杂性，同时也违反了微服务设计的单一职责原则。 上图为采用API Gateway模式，我们通过上图可以看到，API Gateway做为系统统一入口，实现了对各个微服务间的整合，同时又做到了对客户端友好，屏蔽系统了复杂性和差异性。对比之前无API Gateway模式，API Gateway具有几个比较重要的优点： 采用API Gateway可以与微服务注册中心连接，实现微服务无感知动态扩容。 API Gateway对于无法访问的服务，可以做到自动熔断，无需人工参与。 API Gateway可以方便的实现蓝绿部署，金丝雀发布或A/B发布。 API Gateway做为系统统一入口，我们可以将各个微服务公共功能放在API Gateway中实现，以尽可能减少各服务的职责。 帮助我们实现客户端的负载均衡策略。 API Gateway中一些重要的功能负载均衡 实际的部署应用中，当应用系统面临大量访问，负载过高时，通常我们会增加服务数量来进行横向扩展，使用集群来提高系统的处理能力。此时多个服务通过某种负载算法分摊了系统的压力，我们将这种多节点分摊压力的行为称为负载均衡。 API Gateway可以帮助我们轻松的实现负载均衡，利用服务发现知道所有Service的地址和位置，通过在API Gateway中实现负载均衡算法，就可以实现负载均衡效果。 服务熔断 在实际生产中，一些服务很有可能因为某些原因发生故障，如果此时不采取一些手段，会导致整个系统“雪崩”。或因系统整体负载的考虑，会对服务访问次数进行限制。服务熔断、服务降级就是解决上述问题的主要方式。API Gateway可以帮助我们实现这些功能，对于服务的调用次数的限制，当某服务达到上限时，API Gateway会自动停止向上游服务发送请求，并像客户端返回错误提示信息或一个统一的响应，进行服务降级。对于需要临时发生故障的服务，API Gateway自动可以打开对应服务的断路器，进行服务熔断，防止整个系统“雪崩”。 灰度发布 服务发布上线过程中，我们不可能将新版本全部部署在生产环节中，因为新版本并没有接受真实用户、真实数据、真实环境的考验，此时我们需要进行灰度发布，灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，同时影响小。API Gateway可以帮助我们轻松的完成灰度发布，只需要在API Gateway中配置我们需要的规则，按版本，按IP段等，API Gateway会自动为我们完成实际的请求分流。 认证和鉴权目前在微服务中，我们还需要考虑如何保护我们的API只能被同意授权的客户调用。那么对于API的保护，目前大多数采用的方式有这么几种，分别为AppKeys，OAuth2 和 OAuth2+JWT 认证方式AppKeys 目前采用AppKeys Auth认证的公有云API Gateway和数据开放平台居多，如阿里API Gateway，聚合数据等，这种认证模式是由API Gateway颁发一个key，或者appkey+appsecret+某种复杂的加密算法生成AppKey，调用方获取到key后直接调用API。这个key可以是无任何意义的一串字符。API Gateway在收到调用API请求时，首先校验key的合法性，包括key是否失效，当前调用API是否被订阅等等信息，若校验成功，则请求上游服务，返回结果。此处上游服务不再对请求做任何校验，直接返回结果。采用AppKeys认证模式比较适合Open Service的场景。其中并不涉及到用户信息，权限信息。 OAuth2 大部分场景中，我们还是需要有知道谁在调用，调用者是否有对应的角色权限等。OAuth2可以帮助我们来完成这个工作。在OAuth2的世界中，分为以下几种角色：Resource Owner，Client，Authorization Server，Resource Sever。上图是一个简单的OAuh2流程来说明各个角色之前的关系。最终，App获得了Rory的个人信息。 OAuth2+JWT OAuth2 + JWT流程跟OAuth2完全一致。了解OAuth2的童鞋都应该知道，OAuth2最后会给调用方颁发一个Access Token，OAuth2+JWT实际上就是将Access Token换成JWT而已。这样做的好处仅仅是减少Token校验时查询DB的次数。 参考API管理的正确姿势–API Gateway]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务]]></title>
    <url>%2Fpost%2F460c1130.html</url>
    <content type="text"><![CDATA[微服务 微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。 微服务的本质 微服务，关键其实不仅仅是微服务本身，而是系统要提供一套基础的架构，这种架构使得微服务可以独立的部署、运行、升级，不仅如此，这个系统架构还让微服务与微服务之间在结构上“松耦合”，而在功能上则表现为一个统一的整体。这种所谓的“统一的整体”表现出来的是统一风格的界面，统一的权限管理，统一的安全策略，统一的上线过程，统一的日志和审计方法，统一的调度方式，统一的访问入口等等。 微服务的目的是有效的拆分应用，实现敏捷开发和部署 。 微服务提倡的理念团队间应该是 inter-operate, not integrate 。inter-operate是定义好系统的边界和接口，在一个团队内全栈，让团队自治，原因就是因为如果团队按照这样的方式组建，将沟通的成本维持在系统内部，每个子系统就会更加内聚，彼此的依赖耦合能变弱，跨系统的沟通成本也就能降低。 适用能不能做成微服务，取决于四个要素： 小：微服务体积小，2 pizza 团队。 独：能够独立的部署和运行。 轻：使用轻量级的通信机制和架构。 松：为服务之间是松耦合的。 设计原则单一职责原则意思是每个微服务只需要实现自己的业务逻辑就可以了，比如订单管理模块，它只需要处理订单的业务逻辑就可以了，其它的不必考虑。 服务自治原则意思是每个微服务从开发、测试、运维等都是独立的，包括存储的数据库也都是独立的，自己就有一套完整的流程，我们完全可以把它当成一个项目来对待。不必依赖于其它模块。 轻量级通信原则首先是通信的语言非常的轻量，第二，该通信方式需要是跨语言、跨平台的，之所以要跨平台、跨语言就是为了让每个微服务都有足够的独立性，可以不受技术的钳制。 接口明确原则由于微服务之间可能存在着调用关系，为了尽量避免以后由于某个微服务的接口变化而导致其它微服务都做调整，在设计之初就要考虑到所有情况，让接口尽量做的更通用，更灵活，从而尽量避免其它模块也做调整。 特性 每个微服务可独立运行在自己的进程里； 一系列独立运行的微服务共同构建起了整个系统； 每个服务为独立的业务开发，一个微服务一般完成某个特定的功能，比如：订单管理，用户管理等； 微服务之间通过一些轻量级的通信机制进行通信，例如通过REST API或者RPC的方式进行调用。 特点 易于开发和维护 由于微服务单个模块就相当于一个项目，开发这个模块我们就只需关心这个模块的逻辑即可，代码量和逻辑复杂度都会降低，从而易于开发和维护。 启动较快 这是相对单个微服务来讲的，相比于启动单体架构的整个项目，启动某个模块的服务速度明显是要快很多的。 局部修改容易部署 在开发中发现了一个问题，如果是单体架构的话，我们就需要重新发布并启动整个项目，非常耗时间，但是微服务则不同，哪个模块出现了bug我们只需要解决那个模块的bug就可以了，解决完bug之后，我们只需要重启这个模块的服务即可，部署相对简单，不必重启整个项目从而大大节约时间。 技术栈不受限 比如订单微服务和电影微服务原来都是用java写的，现在我们想把电影微服务改成nodeJs技术，这是完全可以的，而且由于所关注的只是电影的逻辑而已，因此技术更换的成本也就会少很多。 按需伸缩 我们上面说了单体架构在想扩展某个模块的性能时不得不考虑到其它模块的性能会不会受影响，对于我们微服务来讲，完全不是问题，电影模块通过什么方式来提升性能不必考虑其它模块的情况。 缺点 运维要求较高 对于单体架构来讲，我们只需要维护好这一个项目就可以了，但是对于微服务架构来讲，由于项目是由多个微服务构成的，每个模块出现问题都会造成整个项目运行出现异常，想要知道是哪个模块造成的问题往往是不容易的，因为我们无法一步一步通过debug的方式来跟踪，这就对运维人员提出了很高的要求。 分布式的复杂性 对于单体架构来讲，我们可以不使用分布式，但是对于微服务架构来说，分布式几乎是必会用的技术，由于分布式本身的复杂性，导致微服务架构也变得复杂起来。 接口调整成本高 比如，用户微服务是要被订单微服务和电影微服务所调用的，一旦用户微服务的接口发生大的变动，那么所有依赖它的微服务都要做相应的调整，由于微服务可能非常多，那么调整接口所造成的成本将会明显提高。 重复劳动 对于单体架构来讲，如果某段业务被多个模块所共同使用，我们便可以抽象成一个工具类，被所有模块直接调用，但是微服务却无法这样做，因为这个微服务的工具类是不能被其它微服务所直接调用的，从而我们便不得不在每个微服务上都建这么一个工具类，从而导致代码的重复。 如何访问这些服务一般在后台N个服务和UI之间一般会一个代理或者叫API Gateway，他的作用包括 提供统一服务入口，让微服务对前台透明 聚合后台的服务，节省流量，提升性能 提供安全，过滤，流控等API管理功能 而这个API Gateway也就是我目前需要去实现的。 参考什么是微服务]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PM2]]></title>
    <url>%2Fpost%2F1efd976a.html</url>
    <content type="text"><![CDATA[简介pm2 是一个带有负载均衡功能的Node应用的进程管理器. 使用安装1npm install -g pm2 启动项目方式一： 1pm2 start app.js 方式二： 我使用的koa2的cli所以我启动项目的时候使用的命令是： 1npm run prd 显示所以进程的状态1pm2 list 在这里你会找到你项目的id，很有用，下面的命令会用到这个id 删除这个进程1pm2 delete $&#123;id&#125; 重启项目123pm2 restart all //重启所有pm2 restart $&#123;id&#125; //重启这个id的项目 暂停项目1234pm2 restart all //暂停所有pm2 restart $&#123;id&#125; //暂停这个id的项目 查看项目具体信息由于有的时候项目非常多，已经不知道哪个是哪个，所以可以在这里面查看到项目的路径 1pm2 describe $&#123;id&#125; //暂停这个id的项目 查看日志如果你有打印端口号的习惯，那么你可以通过这种方式查看到这个项目的端口号 123pm2 logs //查看所有日志pm2 logs $&#123;id&#125; //查看当前id的日志]]></content>
      <categories>
        <category>koa2</category>
      </categories>
      <tags>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es9]]></title>
    <url>%2Fpost%2Fea4a72e4.html</url>
    <content type="text"><![CDATA[除了es9(es2018)其他只是简单谈谈 es2016只有两个小特性： includes(),判断一个数组是否包含一个指定的值,返回true或者false 123456789let site = ['runoob', 'google', 'taobao']; site.includes('runoob'); // true site.includes('baidu'); // false//案例来自菜鸟教程 a ** b指数运算符，同Math.pow(a,b) es2017 async函数 12345678router.get('/',async function (ctx, next) &#123; let data; await yinxs_a.test_a().then(result =&gt; &#123; data = result; &#125;); console.log(data);//从数据库中获取的数据 ctx.body = 'this is a users response!'&#125;) Object.values () 123456789101112131415161718//es5 Object.keys(obj)let data = &#123; name:'yinx', age:'666', &#125;Object.keys(data);// 返回["name","age"]//Object.values()let data = &#123; name:'yinx', age:'666', &#125; Object.values(data);//返回["yinx","666"] Object.entries() 1234567let data = &#123; name:'yinx', age:'666', &#125;Object.entries(data);//返回[["name","yinx"],["age","666"]] Object.getOwnPropertyDescriptors() 1234567let data = &#123; name:'yinx', age:'666', &#125;Object.getOwnPropertyDescriptors(data);//返回&#123;"name": &#123;"value": "yinx","writable": true,"enumerable": true,"configurable": true&#125;,"age": &#123;"value": "666","writable": true,"enumerable": true,"configurable": true&#125;&#125; padStart()和padEnd()字符串方法 1234'x'.padStart(5, 'ab')//返回'ababx''x'.padEnd(5, 'ab')//返回'xabab' 结尾逗号，数组定义和函数参数列表 ES2017允许函数和数组的最后一个参数有尾逗号 ShareArrayBuffer和Atomics 共享内存 es2018异步迭代首先这段代码是不能执行的12345async function process(array) &#123; for (let i of array) &#123; await doSomething(i); &#125; &#125; es9引入了异步迭代器 12345async function process(array) &#123; for await (let i of array) &#123; doSomething(i); &#125; &#125; Promise.finally()一个Promise调用链要么成功到达最后一个.then()，要么失败触发.catch()。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除，删除对话，关闭数据库连接等。 Rest/Spread 属性12345const myObject = &#123; a: 1, b: 2, c: 3 &#125;;const &#123; a, ...x &#125; = myObject; // a = 1 // x = &#123; b: 2, c: 3 &#125; 正则表达式命名捕获组（Regular Expression Named Capture Groups）ES2018允许命名捕获组使用符号?，在打开捕获括号(后立即命名，示例如下： 1const reDate = /(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/, match = reDate.exec('2018-04-30'), year = match.groups.year, // 2018 month = match.groups.month, // 04 day = match.groups.day; // 30 任何匹配失败的命名组都将返回undefined。 正则表达式反向断言（lookbehind）ES2018引入以相同方式工作但是匹配前面的反向断言（lookbehind），这样我就可以忽略货币符号，单纯的捕获价格的数字： 1const reLookbehind = /(?&lt;=\D)\d+/, match = reLookbehind.exec('$123.89'); console.log( match[0] ); // 123.89 正则表达式dotAll模式正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许行终止符的出现，例如： 1/hello.world/.test('hello\nworld'); // false /hello.world/s.test('hello\nworld'); // true 正则表达式 Unicode 转义到目前为止，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES2018添加了 Unicode 属性转义——形式为\p{…}和\P{…}，在正则表达式中使用标记 u (unicode) 设置，在\p块儿内，可以以键值对的方式设置需要匹配的属性而非具体内容。 1const reGreekSymbol = /\p&#123;Script=Greek&#125;/u; reGreekSymbol.test('π'); // true 非转义序列的模板字符串ES2018 移除对 ECMAScript 在带标签的模版字符串中转义序列的语法限制。 最后参考 es都出9了，安排（T-T）]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue知识杂项]]></title>
    <url>%2Fpost%2Fa3fa9686.html</url>
    <content type="text"><![CDATA[快速构建项目全局安装1npm i -g vue-cli 创建项目(项目名称叫muses)1vue init webpack muses 启动(默认的是80端)1npm run dev 详细讲解 与ng4 的cli 不同 ，vue的cli比较复杂 ，但是实际上只要一直回车对后面没有影响，注意最后一项要选择npm的那个选项 build文件里面是一些操作文件,执行 npm run * 时执行的就是这里的文件 config 文件是配置文件 src 是资源文件，组件等都放在这里 assets 资源文件，同ng4 类似，放的是公共的资源，例如图片 打包1npm run build 注意 如果你是用的编辑器是webstorm 那么需要在setting中的Language选项里面的JavaScript设置为ECMAScript 6，这样才可以使用，如果还有问题，那么需要在script标签中标注type为es6 引入facvion123456789// build/webpack.dev.conf.jsnew HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true, favicon: path.resolve('favicon.ico') // 加上这个&#125;) favicon.ico 放在根目录下 页面传参vuex参考：这篇文章不错 vuex是一个为了vue开发的状态管理模式，它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化， 安装1npm i vuex --save 引入1234567891011121314import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const mutations = &#123;...&#125;;const actions = &#123;...&#125;;const state = &#123;...&#125;; Vuex.Store(&#123; state, actions, mutation&#125;); 使用123456789import &#123;mapActions&#125; from 'vuex' //我是一个组件export default &#123; methods: mapActions([ 'actionName', ])&#125; query传参query是拼接在url后面的参数 query:/home?id=1 ,/home?id=2 ,这里的id叫做query 使用12345&lt;router-link :to="&#123; name:'home',query: &#123; id: 1 &#125;&#125;" &gt;home&lt;/router-link&gt;//或者this.$router.push(&#123; name:'home',query: &#123; id: 1 &#125;&#125;); 获取1this.$route.query.id params传参params是路由的一部分，注意，设置了params，那么params就是路由的一部分，一旦没有传params，那么会导致跳转失败或者没有内容 params：/home/:id ，/home/1，/home/2 ,这里的id叫做params 路由配置params使用的时候需要配置路由 12345678routes:[ &#123; path:'/home/:id', name:'home', component:Home &#125;] 使用12345&lt;router-link :to="&#123; name:'home',params: &#123; id: 1&#125;" &gt;home&lt;/router-link&gt;//或者this.$router.push(&#123; name:'home',params: &#123; id:1&#125;&#125;); 获取1this.$route.params.id 广播在vue1.0中使用的是 $dispatch 和 $broadcast ，但是目前为止已经弃用。 在vue2.0中使用的是 $emit, $on, $off 来分发、监听、取消监听事件 父传子父：1234567891011121314151617&lt;template&gt; &lt;div&gt; 父组件: &lt;input type="text" v-model="name"&gt; &lt;!-- child子组件 --&gt; &lt;child :inputName="name"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; name: '' &#125; &#125; &#125;&lt;/script&gt; 子：123456789101112131415&lt;template&gt; &lt;div&gt; 子组件: &lt;span&gt;&#123;&#123;inputName&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; // 接收父组件的值 props: &#123; inputName: String, required: true &#125; &#125;&lt;/script&gt; 子传父父：123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; 父组件: &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt; &lt;br&gt; &lt;br&gt; &lt;!-- 引入子组件 定义一个on的方法监听子组件的状态--&gt; &lt;child v-on:childByValue="childByValue"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child from './child' export default &#123; components: &#123; child &#125;, data () &#123; return &#123; name: '' &#125; &#125;, methods: &#123; childByValue: function (childValue) &#123; // childValue就是子组件传过来的值 this.name = childValue &#125; &#125; &#125;&lt;/script&gt; 子：123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; 子组件: &lt;span&gt;&#123;&#123;childValue&#125;&#125;&lt;/span&gt; &lt;!-- 定义一个子组件传值的方法 --&gt; &lt;input type="button" value="点击触发" @click="childClick"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; childValue: '我是子组件的数据' &#125; &#125;, methods: &#123; childClick () &#123; // childByValue是在父组件on监听的方法 // 第二个参数this.childValue是需要传的值 this.$emit('childByValue', this.childValue) &#125; &#125; &#125;&lt;/script&gt; 非父子传值非父子组件传值，需要定义一个公共的实例文件bus.js来作为中间仓库来传值 bus.js文件 123import Vue form 'vue'export default new Vue() 组件1： 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; A组件: &lt;span&gt;&#123;&#123;elementValue&#125;&#125;&lt;/span&gt; &lt;input type="button" value="点击触发" @click="elementByValue"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入公共的bus，来做为中间传达的工具 import Bus from './bus.js' export default &#123; data () &#123; return &#123; elementValue: 4 &#125; &#125;, methods: &#123; elementByValue: function () &#123; Bus.$emit('val', this.elementValue) &#125; &#125; &#125;&lt;/script&gt; 组件2： 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; B组件: &lt;input type="button" value="点击触发" @click="getData"&gt; &lt;span&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Bus from './bus.js' export default &#123; data () &#123; return &#123; name: 0 &#125; &#125;, mounted: function () &#123; var vm = this // 用$on事件来接收参数 Bus.$on('val', (data) =&gt; &#123; console.log(data) vm.name = data &#125;) &#125;, methods: &#123; getData: function () &#123; this.name++ &#125; &#125; &#125;&lt;/script&gt; 插件的使用element-ui安装1cnpm i element-ui --save 引入 在main.js 中 123456789101112import Vue from 'vue'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import App from './App.vue'Vue.use(ElementUI)new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;) 使用菜单导航123456&lt;el-menu :router="true" :default-active="$route.path" class="el-menu-demo" mode="horizontal" @select="handleSelect"&gt; &lt;el-menu-item index="/table"&gt;表格&lt;/el-menu-item&gt; &lt;el-menu-item index="/form"&gt;表单&lt;/el-menu-item&gt; &lt;el-menu-item index="/graph"&gt;图形&lt;/el-menu-item&gt; &lt;/el-menu&gt; index里面添加路由， router是使用路由模式为true 但是还会发现一个新的问题，它不默认选中了，所以这里要修改一下 12345&lt;el-menu :router="true" :default-active="$route.path" class="el-menu-demo" mode="horizontal" @select="handleSelect"&gt; &lt;el-menu-item index="/table"&gt;表格&lt;/el-menu-item&gt; &lt;el-menu-item index="/form"&gt;表单&lt;/el-menu-item&gt; &lt;el-menu-item index="/graph"&gt;图形&lt;/el-menu-item&gt; &lt;/el-menu&gt; elementUI关于树状图的增删改查，局部刷新问题链接在这里 elementUI关于tree的使用getCheckedKeys不能获取父节点的key 在vue中使用less安装 cnpm install less less-loader –save 在webpack.base.config.js在loaders里面加上 12345678&#123;test: /\.less$/,loader: "style-loader!css-loader!less-loader",&#125;, 1&lt;style scoped lang="less"&gt; vue中使用sass安装12npm install node-sass --save-devnpm install sass-loader --save-dev 配置 打开webpack.base.config.js在loaders里面加上 module – rules 123456789101112131415161718192021222324252627282930313233rules: [ &#123; test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; test: /\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test')] &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', query: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.scss$/, loaders: ["style", "css", "sass"] &#125;,//这里这里看这里，主要引入这一段 &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', query: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125; vue中使用富文本编辑器123456## 安装&gt; cnpm install vue-quill-editor --save## 引入&gt; import &#123; quillEditor &#125; from 'vue-quill-editor' 在vue中使用Echarts（vue）安装 cnpm install echarts –save 引入 import echarts from ‘echarts’ Vue.prototype.$echarts = echarts 使用具体使用可以看我的git代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;div&gt; &lt;h1&gt;e-chart_1:南丁格尔图&lt;/h1&gt; &lt;div class="charts"&gt; &lt;div class="myChart" :style="&#123;width: '500px', height: '500px'&#125;"&gt;&lt;/div&gt; &lt;div class="tip"&gt; &lt;vue-markdown :ishljs = "true"&gt;&#123;&#123;msg&#125;&#125;&lt;/vue-markdown&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import VueMarkdown from 'vue-markdown' import &#123;rose&#125; from '../../assets/eCharts/rose'; import rosemd from '../../assets/md/rose.md'; export default &#123; data()&#123; return &#123; msg:rosemd &#125; &#125;, mounted()&#123; this.drawLine(); &#125;, methods: &#123; drawLine()&#123; // 基于准备好的dom，初始化echarts实例 let myChart = this.$echarts.init(document.getElementsByClassName('myChart')[0]); // 绘制图表 let option = rose(); myChart.setOption(option); &#125; &#125;, components: &#123; VueMarkdown &#125; &#125;&lt;/script&gt;&lt;style scoped lang="less"&gt; .charts &#123; padding: 20px; position: relative; .myChart &#123; position: absolute; left: 0px; &#125; .tip &#123; position: absolute; right: 0px; width: 460px; height: 460px; overflow: auto; background-color: #ccc; padding: 20px; &#125; &#125;&lt;/style&gt; 如何在vue中引入jquery安装 在package.json里的dependencies加入”jquery” : “^2.2.3”，然后install 或者直接安装也可以 12345678910111213141516在webpack.base.conf.js里加入var webpack = require("webpack")在module.exports的最后加入plugins: [new webpack.ProvidePlugin(&#123;jQuery: "jquery",$: "jquery"&#125;)]然后一定要重新 run dev在main.js 引入就ok了import $ from 'jquery' 生命周期以及函数vue全局拦截前端错误（前端异常监控系统+ng4）errorHandler 一般来讲，前端的异常处理使用的是try catch 和window.onerror 但是在框架中就不可以了，三大前端框架只有react可以这么使用，vue中有自己的errorHandler，ng也有自己的属性可以这么用 这里面我们用errorHandler来进行错误拦截 12345Vue.config.errorHandler = function (err, vm, info) &#123; // handle error // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 // 只在 2.2.0+ 可用&#125; 123456789101112131415161718//具体报错信息ReferenceError: i is not defined //err at VueComponent.created (bigdata.vue?1536:26) at callHook (vue.esm.js?5425:2895) at VueComponent.Vue._init (vue.esm.js?5425:4560) at new VueComponent (vue.esm.js?5425:4728) at createComponentInstanceForVnode (vue.esm.js?5425:4242) at init (vue.esm.js?5425:4059) at createComponent (vue.esm.js?5425:5512) at createElm (vue.esm.js?5425:5460) at createChildren (vue.esm.js?5425:5586) at createElm (vue.esm.js?5425:5488)VueComponent &#123;_uid: 4, _isVue: true, $options: &#123;…&#125;, //vm _renderProxy: Proxy, _self: VueComponent, …&#125;created hook //info vue2.0参考这里 ng4参考这里 接口形式同埋点上传（利用一个gif的形式传递数据）这是我以前写的关于如何进行埋点上传的文章 vue中操作DOM方案1 可以在mounted中挂载 12345mounted:function()&#123; this.$nextTick(function()&#123; //this.$nextTick是在下次DOM更新循环结束时调用延迟回调函数。异步函数 this.loadData(); //DOM加载就绪，后调用loadData方法进行数据更新&lt;br&gt;//想要更新后的获取dom //此时若获取更新后dom数据将会报错，数据为undefined； &#125;) &#125; 方案2123456789101112if(document.addEventListener)&#123; document.addEventListener('DOMMouseScroll',()=&gt;&#123; &#125;,false); &#125;//W3C window.onmousewheel=document.onmousewheel=()=&gt;&#123; let top = document.getElementById("bottoms").scrollTop; console.log(top); this.$refs.add.style.marginTop = top + 10 + "px"; // document.getElementById("rights").style.marginTop = top+"px"; console.log(this.$refs.add.style); &#125;;//IE/Opera/Chrome erroreslint语法解决12345678910111213141516在webpack.base.conf.js里面删掉下面:preLoaders: [ &#123; test: /\.vue$/, loader: 'eslint', include: projectRoot, exclude: [/node_modules/, /ignore_lib/] &#125;, &#123; test: /\.js$/, loader: 'eslint', include: projectRoot, exclude: [/node_modules/, /ignore_lib/] &#125; ] 1234567891011删除以下代码就可以&#123; test: /\.(js|vue)$/, loader: 'eslint-loader', enforce: 'pre', include: [resolve('src'), resolve('test')], options: &#123; formatter: require('eslint-friendly-formatter') &#125; 然后需要重新编辑生效 杂项知识大公司vue前端架构vue + vuex+ axios + vue-router + webpack + es6 + less 单页面应用 单页 Web 应用 (single-page application 简称为 SPA) 是一种特殊的 Web 应用。它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。一旦页面加载完成了，SPA不会因为用户的操作而进行页面的重新加载或跳转。而是利用 JavaScript 动态的变换HTML的内（采用的是div切换显示和隐藏），从而实现UI与用户的交互。由于避免了页面的重新加载，SPA 可以提供较为流畅的用户体验。得益于ajax，我们可以实现无跳转刷新，又多亏了浏览器的histroy机制，我们用hash的变化从而可以实现推动界面变化。 前端路由的两种方式history 和 hash文章vue里面是有的是hash ，因为有一个# hash —— 即地址栏 URL 中的 # 符号（此 hash 不是密码学里的散列运算）。比如这个 URL：http://www.abc.com/#/hello，hash 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。 history —— 利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。 hash值即url中#号后面的部分。 1234&lt;a href="target"&gt;go target&lt;/a&gt;......&lt;div id="target"&gt;i am target place&lt;/div&gt; 点击a链接，文档会滚动到id为target的div的可视区域上面去。hash除了这个功能还有另一一种含义：指导浏览器的行为但不上传到服务器。大家都知道，改变url中的任何一个字符都会导致浏览器重新请求服务器，除了#号后面那段字符之外。所以，简而言之我们可以这样理解：改变#后面的值不触发网页重载，但会记录到浏览器history中去。 驱动div显示隐藏的方式有很多种，比较好的选择为以下两种： 监听地址栏中hash变化驱动界面变化 用pushsate记录浏览器的历史，驱动界面发送变化 如何搭建一个基础的SPA Hash的改变不会引起界面的刷新，但是会出发onhashchange事件，我们要做的就是监听这个事件： 123456789101112function hashChanged()&#123; //变化之后的url var newhash = hashObj.newURL.split('#')[1]; //变化之前的rul var oldhash = hashObj.oldURL.split('#')[1]; //将对应的hash下界面显示和隐藏 document.getElementById(oldhash).style.display = "none"; document.getElementById(newhash).style.display = "block";&#125;//监听路由变化window.onhashchange = hashChanged; 改造vue项目为history模式(使用的是vue-cli)修改 build/dev-server.js 文件 12 app.use(require('connect-history-api-fallback')()) 这句话修改为 12345678var history = require('connect-history-api-fallback')app.use(history(&#123; rewrites: [ &#123; from: 'index', to: '/index.html'&#125;, // 默认入口 &#123; from: /\/backend/, to: '/backend.html'&#125;, // 其他入口 &#123; from: /^\/backend\/.*$/, to: '/backend.html'&#125;, ]&#125;)) 参考 参考Vue2.0的三种常用传值方式、父传子、子传父、非父子组件传值 vuex参考文档]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql基础常用]]></title>
    <url>%2Fpost%2F4f05048c.html</url>
    <content type="text"><![CDATA[日期格式化(DATE_FORMAT() 函数)1234567DATE_FORMAT(date,format)DATE_FORMAT(NOW(),'%Y%m%d')//20180704DATE_FORMAT(NOW(),'%b %d %Y %h:%i %p')DATE_FORMAT(NOW(),'%m-%d-%Y')DATE_FORMAT(NOW(),'%d %b %y')DATE_FORMAT(NOW(),'%d %b %Y %T:%f') 设置自增日期类型：timestamp 默认：CURRENT_TIMESTAMP CREATE12345678910111213141516171819202122SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for user_info-- ----------------------------DROP TABLE IF EXISTS `user_info`;CREATE TABLE `user_info` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `age` int(11) DEFAULT NULL, `tel` varchar(255) DEFAULT NULL, `address` varchar(255) DEFAULT NULL, `date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_info-- ----------------------------INSERT INTO `user_info` VALUES ('1', 'yinxs', '24', '18811428452', '北京', '2018-07-04 16:21:09');INSERT INTO `user_info` VALUES ('2', 'yinxs', '24', '18811428452', '北京', '2018-07-04 16:21:56'); 12345678910111213141516171819SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for option_info-- ----------------------------DROP TABLE IF EXISTS `option_info`;CREATE TABLE `option_info` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) DEFAULT NULL, `option` varchar(255) DEFAULT NULL, `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;-- ------------------------------ Records of option_info-- ----------------------------INSERT INTO `option_info` VALUES ('1', '1', '选项一', '2018-07-04 16:29:03'); INSERT1INSERT INTO user_info (name,age,tel,address) VALUES ('yinxs','24','18811428452','北京') left join1SELECT * FROM user_info AS a LEFT JOIN option_info AS b ON(b.user_id = a.id) HAVING1SELECT * FROM user_info HAVING SUM(age) &gt; 1000 inner join同join 1SELECT * FROM user_info AS a INNER JOIN option_info AS b ON (b.user_id = a.id) right join1SELECT * FROM user_info AS a RIGHT JOIN option_info AS b ON(b.user_id = a.id) update1UPDATE user_info SET tel = '18811428453' WHERE id = 1 DELETE1DELETE FROM user_info WHERE id = 2 DISTINCT去重 1SELECT DISTINCT age FROM user_info LIKE1234567以y开始SELECT * FROM user_info WHERE name LIKE 'y%'SELECT * FROM user_info WHERE name LIKE '%x%'以s结束SELECT * FROM user_info WHERE name LIKE '%s' ORDER BY1234正序SELECT * FROM user_info AS a LEFT JOIN option_info AS b ON(b.user_id = a.id) ORDER BY a.id 逆序SELECT * FROM user_info AS a LEFT JOIN option_info AS b ON(b.user_id = a.id) ORDER BY a.id DESC function(SQL Server)12345678910AVG(column) 返回某列的平均值COUNT(column) 返回某列的行数（不包括NULL值）COUNT(*) 返回被选行数COUNT(DISTINCT column) 返回相异结果的数目FIRST(column) 返回在指定的域中第一个记录的值（SQLServer2000 不支持）LAST(column) 返回在指定的域中最后一个记录的值（SQLServer2000 不支持）MAX(column) 返回某列的最高值MIN(column) 返回某列的最低值SUM(column) 返回某列的总和 GROUP BY1SELECT * FROM user_info AS a LEFT JOIN option_info AS b ON (b.user_id = a.id) ORDER BY age UNION &amp;&amp; UNION ALLUNION 操作符用于合并两个或多个 SELECT 语句的结果集。 123SELECT * FROM user_info UNION SELECT * FROM user_infoSELECT * FROM user_info UNION ALL SELECT * FROM user_info AND &amp; OR123SELECT * FROM user_info WHERE id = 1 AND age = 24SELECT * FROM user_info WHERE id = 1 OR age = 24 in123SELECT * from user_info WHERE id in (1,2,3)SELECT * from user_info WHERE id not in (1,2,3) case when zhen123456789--简单case函数case sex when '1' then '男' when '2' then '女’ else '其他' end--case搜索函数case when sex = '1' then '男' when sex = '2' then '女' else '其他' end 实例： 1SELECT (CASE when uid = 1 THEN '男' WHEN uid = 2 THEN '女' ELSE '其他' END)性别 FROM `session` Round12345SELECT ROUND(column_name,decimals) FROM table_namecolumn_name 必需。要舍入的字段。decimals 必需。规定要返回的小数位数。 舍入为最接近的整数 1SELECT ProductName, ROUND(UnitPrice,0) as UnitPrice FROM Products 标准函数中的日期函数1234567891011121314151、day(date_expression)返回date_expression中的日期值 2、month(date_expression)返回date_expression中的月份值 3、year(date_expression)返回date_expression中的年份值 BETWEEN … AND操作符 BETWEEN … AND 会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。 1select * from tj_md WHERE date BETWEEN 20180705 AND 20180706]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[google扩展程序]]></title>
    <url>%2Fpost%2F9bf77d3f.html</url>
    <content type="text"><![CDATA[平常收集的一些google扩展程序 位置如图 google扩展程序在右上角三个小冒号下面 谷歌访问助手在国内访问不了google，除了开vpn外还有一种方法： 点击：谷歌访问助手 Postman这个相信很多人都在用，如果你不想下载程序，可以直接在google上应用 点击：Postman WEB前端助手(FeHelper)这个是我最常用的扩展程序，里面的功能非常齐全 点击：WEB前端助手(FeHelper) Office Online这个我安装之后就没有用过（捂脸哭） 为 Chrome 打造 - 无需安装 Office，即可使用 Word、Excel、PowerPoint、OneNote 和 Sway Online。 点击：Office Online 花瓣网页收藏工具这个就比较有意思了 这个扩展程序可以让你方便地从任意网站上采集喜欢的图片、视频或者网页截图到花瓣网(huaban.com)上。这是花瓣网官方(huaban.com)提供的扩展。 点击：花瓣网页收藏工具 JSON代码Unicode转义工具将manifest.json文件中的非ASCII字符进行unicode转义。 点击：JSON代码Unicode转义工具 掘金为设计师、程序员、产品经理每日发现优质内容。包含Android、前端、产品、设计、iOS、后端六大频道，每个频道内都有一到多个为你精心准备的优质内容源。 点击：掘金 WhatRuns只要点击一下就可以找到你访问过的任何网站上使用的技术。从开发人员工具和广告网络到Wordpress插件和主题，我们甚至可以检测到新的和即将到来的工具和服务。 点击：WhatRuns]]></content>
      <categories>
        <category>趣闻</category>
      </categories>
      <tags>
        <tag>趣闻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node读写json文件&Buff（nginx日志中文解决方案）]]></title>
    <url>%2Fpost%2Fbf58f078.html</url>
    <content type="text"><![CDATA[jsonjson文件首先要创建一个json文件，这里推荐一个google插件（WEB前端助手（Fehelper）），可以直接从一个接口中copy一个response，放进插件的输入框中，它会自动格式化代码，并且右上角有一个下载为json格式。但是这个下载的json文件有个问题，需要把第一行的注释去掉。 因为我使用的koa2框架，所以写法我就按照koa2的规则写 node读文件1234567891011121314const fs=require('fs');const readFile = function()&#123; return new Promise(function(resolve,reject)&#123; fs.readFile( './public/config/staff.json',function (err,data) &#123; if(err) return reject(error) resolve(JSON.parse(data)); &#125;); &#125;)&#125;let staffJson = await readFile();//这样就可以获取到json里面的内容了 node写文件123456//query.staff 是你要改写的内容fs.writeFile('./public/config/staff.json',query.staff,function (err) &#123; if(err)&#123; console.log(err); &#125; &#125;); try catch当使用同步操作时，任何异常都会被立即抛出，可以使用try catch来处理异常 123456789const fs = require('fs');try &#123; fs.unlinkSync('/tmp/hello'); console.log('successfully deleted /tmp/hello');&#125; catch (err) &#123; // handle the error&#125; BufferBuffer类用来创建一个专门存放二进制数据的缓存区 字符编码1234567const buf = Buffer.from('runoob', 'ascii');// 输出 72756e6f6f62console.log(buf.toString('hex'));// 输出 cnVub29iconsole.log(buf.toString('base64')); 重点前几篇文章中我有写了如何利用nginx进行数据埋点，如果你去实践了，你会发现中文在高版本的nginx中会进行自动编码 让我们来解析一下如何解决这个问题 方案一降低nginx的版本 调用数据的时候进行解码根据你的日志将编码后的中文分割，可能是’x’,’\x’,’\\x’。 12let arr = 'DBxE6x8AxA5xE8xA1xA8'.split('x');result = []; 将 第一个参数进行 Unicode 编码 123for (let i = 0; i &lt; arr[0].length; i++) &#123; result.push(arr[0][i].charCodeAt());&#125; 剩下的参数中前两个字母进行16进制编码，后几个进行Unicode 编码 1234567891011arr.forEach(function(item,index)&#123; if(index != 0)&#123; for (let i = 0; i &lt; item.length; i++) &#123; if (i == 0 || i == 1) &#123; result.push(parseInt(item[0] + item[1], 16)); &#125; else &#123; result.push(item[i].charCodeAt()); &#125; &#125; &#125;&#125;) 最后创建一个新的包含字符串 ‘buffer’ 的 UTF-8 字节的 Buffer 1let buf = Buffer.from(arr); 获取中文 1let zw = buf.toString(); 详解上面的内容想要理解，我们就需要了解utf-8编码 转自：字符编码笔记：ASCII，Unicode和UTF-8 UTF-8互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。 UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的(nginx日志中的第一位不是英文就是数字要不就为空)。 2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码（对应第二阶段代码）。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python27常用]]></title>
    <url>%2Fpost%2Fafab67f.html</url>
    <content type="text"><![CDATA[中文编码1# encoding: utf-8 Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字 基础语法条件语句1234567891011if 判断条件1: 执行语句1……elif 判断条件2: 执行语句2……elif 判断条件3: 执行语句3……else: 执行语句4……if 判断条件： 执行语句……else： 执行语句…… 循环语句123a=[1,2,3]for i in a: print('当前数组 :', i) 1234a=[1,2,3]for i in range(len(a)): print(a[i]) 函数123def functionname( parameters ): function_suite return [expression] 文件读文件 123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open("foo.txt", "r+")str = fo.read(10)print "读取的字符串是 : ", str# 关闭打开的文件fo.close() 写文件 123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 打开一个文件fo = open("foo.txt", "w")fo.write( "www.runoob.com!\nVery good site!\n") # 关闭打开的文件fo.close() 判断文件是否存在 123456import osif os.path.exists(response_name): print('文件存在')else: print('文件不存在') 其他应用excel安装xlrd、xlwt、xlutilsxlrd：是python从excel读数据的第三方控件；xlwt：是python从excel写数据的第三方控件；xlutils：是python使用xlrd、xlwt的工具箱。若安装不成功，可能原因是需要安装setuptools。 [root@vm4 python]# pip install xlrd [root@vm4 python]# pip install xlwt [root@vm4 python]# pip install xlutils 语法如下： 1234567891011121314151617181920212223import xlwtworkbook = xlwt.Workbook(encoding = 'utf-8')worksheet = workbook.add_sheet('My Worksheet')# excel当前格大小worksheet.col(0).width = 256*20worksheet.col(1).width = 256*20worksheet.col(2).width = 256*20# 第一行worksheet.col(0).width = 256*20worksheet.write(0, 0, label = '日期')worksheet.write(0, 1, label = 'PV')worksheet.write(0, 2, label = 'UV')# 第二行worksheet.write(1, 0, label = '2018/7/3')worksheet.write(1, 1, label = 3)worksheet.write(1, 2, label = 4)# 生成excel文件workbook.save('excel.xls') 日期123456import datetimetoday = datetime.date.today()yesterday = today - datetime.timedelta(days=1)day = yesterday.strftime("%Y-%m-%d") 数据库操作先下载改模块：pip install MySQLdb 123456789101112131415161718import MySQLdbdb = MySQLdb.connect("localhost","root","abcd","databaseName",charset='utf8' )cursor = db.cursor()sql = 'SELECT * FROM tj_md'try: cursor.execute(sql) results = cursor.fetchall() for row in results: print(row)except: print "Error: unable to fecth data"db.close()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端错误日志监听]]></title>
    <url>%2Fpost%2F74ae734e.html</url>
    <content type="text"><![CDATA[前言后台有日志，会把一些错误的原记录下来，但是前端没有办法记录下来，所以我们利用和埋点类似的方式来记录这些错误，方便我们对项目进行优化 在这里我只是提供一个思路，一个方案。我用vue来举个例子 可能有的人看过我关于数据埋点的那套方案，这套方案我们来沿用它 vue中在2.5之前可以使用全局的 config.errorHandler 设置来为应用提供一个监听未知异常的函数，2.5 中，组件内提供了一个新的钩子函数 errorCaptured，可以捕获该组件内所有子组件树中（不含自身）产生的所有的异常（包括异步调用中的异常），这个钩子函数接收的参数和 errorHandler 一样，可以让开发者更加友好地处理组件内异常。 前端代码在这个函数中我们埋入一段代码 1234errorCaptured (err, vm, info) &#123; log(err,vm,info)//处理错误函数 return false &#125; 处理错误函数代码123456789101112131415161718function log (err,vm,info) &#123; var params = &#123;&#125;; params.err = err||null; params.vm = vm||null; params.info = info||null //拼接参数串 var args = ''; for(var i in params) &#123; if(args != '') &#123; args += '&amp;'; &#125; args += i + '=' + encodeURIComponent(params[i]); &#125; //通过Image对象请求后端脚本 var img = new Image(1, 1); img.src = 'http://127.0.0.1:9100/log.gif?' + args;&#125; 服务器之后的代码请参考我的埋点方案 手把手教你做数据埋点 python-nginx日志埋点导入mysql]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux定时任务(crontab)]]></title>
    <url>%2Fpost%2Fc156bde1.html</url>
    <content type="text"><![CDATA[crontab 添加任务crontab -e 规则123分 时 日 月 周 * * * * * sh 1.sh 0-59 0-23 1-31 1-12 0-7 需要执行的命令 在以上各个字段中，还可以使用以下特殊字符： 星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9” 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6” 正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。 crond服务安装crontab： yum install crontabs 服务操作说明：123456重启： /etc/init.d/crond restart查看日志： cat /var/log/cron修改： crontab -e 问题你可能会发现的脚本被执行了多层次 1ps -A | grep cron 查看进程，是否启动多个，kill掉]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-nginx日志埋点导入mysql]]></title>
    <url>%2Fpost%2Fdccb0cee.html</url>
    <content type="text"><![CDATA[前不久发了一篇关于nginx日志埋点的文章，这篇文章是讲的如何利用python将nginx日志的数据导入到mysql库中，之后的操作将交给数据分析师来进行 前置需要python版本为2.7 需要下载pip： easy_install pip 需要下载MySQLdb： pip install MySQL-python 如果还有下载不懂的可以查看我的这篇文章–python 闲散知识 注意： 这个文件要放在nginx的logs文件下面执行 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# encoding: utf-8import datetimeimport osimport MySQLdbdb = MySQLdb.connect("localhost","userName","pwd","",charset='utf8' )today = datetime.date.today()currentday0 = today - datetime.timedelta(days=0)targe = currentday0.strftime("%Y%m")cursor = db.cursor()def insertdata (num): for index in range(num): tag1 = index + 1 currentday = today - datetime.timedelta(days=tag1) day = currentday.strftime("%d") catalogue = "access_"+day+".log" if os.path.exists(targe + '/' + catalogue): f = open( targe + '/' + catalogue,'r') str = f.read() f.close() arr = str.split('\n') for index_i in range(len(arr)): # 因为有非常多的项目利用nginx做了代理，所以这里进行一次过滤 if len(arr[index_i].split('^A')) &gt;= 17: if arr[index_i].split('^A')[15] == '这里写的是你的pid': list_arr = arr[index_i].split('“')[1].split('”')[0] list_data = list_arr.split('^A') li = '","'.join(list_data) sql = 'INSERT INTO tj_md(msec,remote_addr,u_domain,u_url,u_title,u_referrer,u_sh,u_sw,u_cd,u_lang,http_user_agent,u_utrace,u_account,time_local,u_uid,u_pid,u_option) VALUES ("' + li + '")' try: cursor.execute(sql) db.commit() except: db.rollback()# 这里面填写的数字代表的是你要执行多少天的操作，第一次执行的我设置为昨天的数据insertdata(1)db.close() 添加定时任务因为添加了定时任务（每天执行一次），所以函数中添加的参数为1 1insertdata(1) crontab -e 后添加，每天凌晨四点执行一次 10 4 * * * python /usr/logcal/nginx/logs/1.py 如果权限不过请执行：chmod a+x /usr/local/nginx/logs/1.py]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>埋点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你做数据埋点]]></title>
    <url>%2Fpost%2F19e24b69.html</url>
    <content type="text"><![CDATA[前端埋点代码 12345678910111213141516171819202122232425262728293031323334function md (uid,pid,option) &#123; var params = &#123;&#125;; //Document对象数据 if(document) &#123; params.domain = document.domain || ''; params.url = document.URL || ''; params.title = document.title || ''; params.referrer = document.referrer || ''; &#125; //Window对象数据 if(window &amp;&amp; window.screen) &#123; params.sh = window.screen.height || 0; params.sw = window.screen.width || 0; params.cd = window.screen.colorDepth || 0; &#125; //navigator对象数据 if(navigator) &#123; params.lang = navigator.language || ''; &#125; params.uid = uid||null; params.pid = pid||null; params.option = option||null //拼接参数串 var args = ''; for(var i in params) &#123; if(args != '') &#123; args += '&amp;'; &#125; args += i + '=' + encodeURIComponent(params[i]); &#125; //通过Image对象请求后端脚本 var img = new Image(1, 1); img.src = 'http://127.0.0.1:9100/1.gif?' + args;&#125; 服务器在这里面我们使用的是nginx的日志来收集数据 注意事项下文中的配置文件可以直接拿来就用，但是需要修改几点 log_format 修改你需要记录的参数 i-log中自定义变量 以下为nginx的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263log_format tick “$msec^A$remote_addr^A$u_domain^A$u_url^A$u_title^A$u_referrer^A$u_sh^A$u_sw^A$u_cd^A$u_lang^A$http_user_agent^A$u_utrace^A$u_account^A$time_local^A$u_uid^A$u_pid^A$u_option”;server &#123; listen 9999; server_name localhost; #charset koi8-r; location /1.gif &#123; #伪装成gif文件 default_type image/gif; #本身关闭access_log，通过subrequest记录log access_log off; access_by_lua " -- 用户跟踪cookie名为__utrace local uid = ngx.var.cookie___utrace if not uid then -- 如果没有则生成一个跟踪cookie，算法为md5(时间戳+IP+客户端信息) uid = ngx.md5(ngx.now() .. ngx.var.remote_addr .. ngx.var.http_user_agent) end ngx.header['Set-Cookie'] = &#123;'__utrace=' .. uid .. '; path=/'&#125; if ngx.var.arg_domain then -- 通过subrequest到/i-log记录日志，将参数和用户跟踪cookie带过去 ngx.location.capture('/i-log?' .. ngx.var.args .. '&amp;utrace=' .. uid) end "; #此请求不缓存 add_header Expires "Fri, 01 Jan 1980 00:00:00 GMT"; add_header Pragma "no-cache"; add_header Cache-Control "no-cache, max-age=0, must-revalidate"; #返回一个1×1的空gif图片 empty_gif; &#125; location /dv_tj.gif&#123; access_log off; default_type image/gif; empty_gif; &#125; location /i-log &#123; #内部location，不允许外部直接访问 internal; #设置变量，注意需要unescape set_unescape_uri $u_domain $arg_domain; set_unescape_uri $u_url $arg_url; set_unescape_uri $u_title $arg_title; set_unescape_uri $u_referrer $arg_referrer; set_unescape_uri $u_sh $arg_sh; set_unescape_uri $u_sw $arg_sw; set_unescape_uri $u_cd $arg_cd; set_unescape_uri $u_lang $arg_lang; set_unescape_uri $u_utrace $arg_utrace; set_unescape_uri $u_account $arg_account; set_unescape_uri $u_uid $arg_uid; set_unescape_uri $u_pid $arg_pid; set_unescape_uri $u_option $arg_option; #打开日志 log_subrequest on; #记录日志到ma.log，实际应用中最好加buffer，格式为tick access_log /usr/local/src/ma.log tick; #输出空字符串 echo ''; &#125; error_page 404 /404.html; &#125; 日志处理如果你的项目访问量特别大，可能需要做一次日志轮转，当然我的项目访问量不多，不做处理也无所谓 写一个shell脚本分割日志 12345678# 你的nginx的日志的位置base_path='/usr/local/nginx/logs'log_path=$(date -d yesterday +"%Y%m")day=$(date -d yesterday +"%d")mkdir -p $base_path/$log_pathmv $base_path/access.log $base_path/$log_path/$access_$day.log# 记得修改为你自己的位置kill -USR1 `cat /usr/local/nginx/logs/nginx.pid` 添加定时任务 12345678910crontab -e# 每天0时1分进行日志分割(建议在02-04点之间,系统负载小)01 00 * * * /opt/nginx/logs/splitLog.sh 重启Linux定时任务crond restart如果提示以下错误crond: can't lock /var/run/crond.pid, otherpid may be 4141: 资源暂时不可用删除/var/run/crond.pid 重新执行命令即可 参考使用nginx lua实现网站统计中的数据收集 Nginx日志按天切割及日志基本配置说明]]></content>
      <categories>
        <category>埋点</category>
      </categories>
      <tags>
        <tag>埋点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 闲散知识]]></title>
    <url>%2Fpost%2F73c670e0.html</url>
    <content type="text"><![CDATA[安装python升级2.7版本 BUG1 pkg_resources.DistributionNotFound: The ‘pip==7.1.0’ distribution was not found and is 解决方案： 使用easy_install pip==7.1.0 然后再安装easy_install pip==9.0.1 然后删掉rm -f /usr/local/lib/python2.7/site-packages/pip-7.1.0-py2.7.egg 2 cannot concatenate ‘str’ and ‘list’ objects 解决： 列表不能直接和字符串连接在一起 3 _mysql_exceptions.OperationalError: (2006, ‘MySQL server has gone away’) 修改了一下程序，当日志分析完毕后再打开与mysql数据库的链接，且当使用完毕后关闭链接 4 list index out of range 第1种可能情况list[index]index超出范围 第2种可能情况list是一个空的 没有一个元素进行list[0]就会出现该错误 python用法定时执行python脚本python 获取当前日期12import datetimetoday = datetime.date.today() python 获取前几天日期12345import datetimetoday = datetime.date.today()yesterday = today - datetime.timedelta(days=1)day = yesterday.strftime("%Y-%m-%d") python 操作数据库 pip install MySQL-python 语法数组合并字符串1",".join(arr)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[egg.js]]></title>
    <url>%2Fpost%2Fd593ec.html</url>
    <content type="text"><![CDATA[egg.js 说明Egg.js 为企业级框架和应用而生，希望由 Egg.js 孕育出更多上层框架，帮助开发团队和开发人员降低开发和维护成本。 使用我们推荐直接使用脚手架，只需几条简单指令，即可快速生成项目: 1234$ npm i egg-init -g$ egg-init egg-example --type=simple$ cd egg-example$ npm i 启动项目： 12$ npm run dev$ open localhost:7001 目录结构 app/router.js 用于配置 URL 路由规则，具体参见 Router。 app/controller/** 用于解析用户的输入，处理后返回相应的结果，具体参见 Controller。 app/service/** 用于编写业务逻辑层，可选，建议使用，具体参见 Service。 app/middleware/** 用于编写中间件，可选，具体参见 Middleware。 app/public/** 用于放置静态资源，可选，具体参见内置插件 egg-static。 app/extend/** 用于框架的扩展，可选，具体参见框架扩展。 config/config.{env}.js 用于编写配置文件，具体参见配置。 config/plugin.js 用于配置需要加载的插件，具体参见插件。 test/** 用于单元测试，具体参见单元测试。 app.js 和 agent.js 用于自定义启动时的初始化工作，可选，具体参见启动自定义。关于agent.js的作用参见Agent机制。 由内置插件约定的目录： app/public/** 用于放置静态资源，可选，具体参见内置插件 egg-static。 app/schedule/** 用于定时任务，可选，具体参见定时任务。 若需自定义自己的目录规范，参见 Loader API app/view/** 用于放置模板文件，可选，由模板插件约定，具体参见模板渲染。 app/model/** 用于放置领域模型，可选，由领域类相关插件约定，如 egg-sequelize。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx日志导出pv，uv（python版本）]]></title>
    <url>%2Fpost%2Fcda56fe8.html</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# encoding: utf-8# get yesterday's dateimport datetimeimport xlwtimport osworkbook = xlwt.Workbook(encoding = 'utf-8')worksheet = workbook.add_sheet('My Worksheet')worksheet.col(0).width = 256*20worksheet.write(0, 0, label = '日期')worksheet.write(0, 1, label = 'PV')worksheet.write(0, 2, label = 'UV')f = open('n.jointwisdom.cn.log','r')# Gets the statistics of the day's response file.str = f.read()f.close()# Divide by blank lines.arr = str.split('\n');base_data = []for base in arr: if base.split(' ')[0] != '210.13.49.224': base_data.append(base.split(' ')) time = []rep_data_pv = []arr_uv = []rep_data_uv = []all_uv = []all_pv_count = 0for index in range(len(base_data)): for indexs in range(len(base_data[index])): api = base_data[index][5].split('/') length = len(api) targ = api[length-1].split('?')[0] if(indexs == 2 and targ == 'province'): all_pv_count = all_pv_count + 1 if(indexs == 2 and base_data[index][indexs].split('[')[1].split(':')[0] not in time and targ == 'province'): if(base_data[index][0] not in all_uv): all_uv.append(base_data[index][0]) time.append(base_data[index][indexs].split('[')[1].split(':')[0]) rep_data_pv.append(1) rep_data_uv.append(len(arr_uv)) arr_uv = [] arr_uv.append(base_data[index][0]) else: if(indexs == 2 and targ == 'province'): if(base_data[index][0] not in all_uv): all_uv.append(base_data[index][0]) pv_len = len(rep_data_pv) rep_data_pv[pv_len-1] = rep_data_pv[pv_len-1] + 1 if(base_data[index][0] not in arr_uv): arr_uv.append(base_data[index][0])rep_data_uv.append(len(arr_uv))rep_data_uv.pop(0)print(all_pv_count)all_uv_con = len(all_uv)for index in range(len(time)): lawn = index + 1 worksheet.write(lawn, 0, label = time[index]) worksheet.write(lawn, 1, label = rep_data_pv[index]) worksheet.write(lawn, 2, label = rep_data_uv[index]) lawns = len(time) + 1all_pv = 0for index in range(len(rep_data_pv)): all_pv = all_pv + int(rep_data_pv[index])worksheet.write(lawns, 0, label = '合计')worksheet.write(lawns, 1, label = all_pv)worksheet.write(lawns, 2, label = all_uv_con)workbook.save('市场热度报告.xls')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa的一些模块的使用]]></title>
    <url>%2Fpost%2F2a41bd63.html</url>
    <content type="text"><![CDATA[文章摘抄自 架设HTTP服务123const Koa = require("koa");cosnt app = new Koa();app.listen(3000); Context对象Koa提供一个Context对象（HTTP请求和HTTP回复） ctx.response.body属性就是发送给用户的内容1234567891011// demos/02.jsconst Koa = require('koa');const app = new Koa();const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;app.use(main);app.listen(3000); HTTP Response 的类型Koa 默认的返回类型是text/plain，如果想返回其他类型的内容，可以先用ctx.request.accepts判断一下，客户端希望接受什么数据（根据 HTTP Request 的Accept字段），然后使用ctx.response.type指定返回类型 123456789101112131415const main = ctx =&gt; &#123; if (ctx.request.accepts('xml')) &#123; ctx.response.type = 'xml'; ctx.response.body = '&lt;data&gt;Hello World&lt;/data&gt;'; &#125; else if (ctx.request.accepts('json')) &#123; ctx.response.type = 'json'; ctx.response.body = &#123; data: 'Hello World' &#125;; &#125; else if (ctx.request.accepts('html')) &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;p&gt;Hello World&lt;/p&gt;'; &#125; else &#123; ctx.response.type = 'text'; ctx.response.body = 'Hello World'; &#125;&#125;; 网页模板123456const fs = require('fs');const main = ctx =&gt; &#123; ctx.response.type = 'html'; ctx.response.body = fs.createReadStream('./demos/template.html');&#125;; 路由原生路由网站一般都有多个页面。通过ctx.request.path可以获取用户请求的路径，由此实现简单的路由。 123456789// demos/05.jsconst main = ctx =&gt; &#123; if (ctx.request.path !== '/') &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;a href="/"&gt;Index Page&lt;/a&gt;'; &#125; else &#123; ctx.response.body = 'Hello World'; &#125;&#125;; koa-route 模块12345678910111213const route = require('koa-route');const about = ctx =&gt; &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;a href="/"&gt;Index Page&lt;/a&gt;';&#125;;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;app.use(route.get('/', main));app.use(route.get('/about', about)); 根路径/的处理函数是main，/about路径的处理函数是about 静态资源koa-static模块封装了静态资源的请求。 12345const path = require('path');const serve = require('koa-static');const main = serve(path.join(__dirname));app.use(main); 重定向有些场合，服务器需要重定向（redirect）访问请求。比如，用户登陆以后，将他重定向到登陆前的页面。ctx.response.redirect()方法可以发出一个302跳转，将用户导向另一个路由。 123456const redirect = ctx =&gt; &#123; ctx.response.redirect('/'); ctx.response.body = '&lt;a href="/"&gt;Index Page&lt;/a&gt;';&#125;;app.use(route.get('/redirect', redirect)); 中间件Logger功能1234const main = ctx =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); ctx.response.body = 'Hello World';&#125;; 中间件的概念12345const logger = (ctx, next) =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); next();&#125;app.use(logger); 像上面代码中的logger函数就叫做”中间件”（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。app.use()用来加载中间件。 基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的main也是中间件。每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是next函数。只要调用next函数，就可以把执行权转交给下一个中间件。 中间件栈多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行。 最外层的中间件首先执行。 调用next函数，把执行权交给下一个中间件。 … 最内层的中间件最后执行。 执行结束后，把执行权交回上一层的中间件。 … 最外层的中间件收回执行权之后，执行next函数后面的代码。 123456789101112131415161718192021const one = (ctx, next) =&gt; &#123; console.log('&gt;&gt; one'); next(); console.log('&lt;&lt; one');&#125;const two = (ctx, next) =&gt; &#123; console.log('&gt;&gt; two'); next(); console.log('&lt;&lt; two');&#125;const three = (ctx, next) =&gt; &#123; console.log('&gt;&gt; three'); next(); console.log('&lt;&lt; three');&#125;app.use(one);app.use(two);app.use(three); 输出： 123456&gt;&gt; one&gt;&gt; two&gt;&gt; three&lt;&lt; three&lt;&lt; two&lt;&lt; one 异步中间件如果有异步操作（比如读取数据库），中间件就必须写成 async 函数。 1234567891011const fs = require('fs.promised');const Koa = require('koa');const app = new Koa();const main = async function (ctx, next) &#123; ctx.response.type = 'html'; ctx.response.body = await fs.readFile('./demos/template.html', 'utf8');&#125;;app.use(main);app.listen(3000); 合成中间件koa-compose模块可以将多个中间件合成为一个。 12345678910111213const compose = require('koa-compose');const logger = (ctx, next) =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); next();&#125;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;const middlewares = compose([logger, main]);app.use(middlewares); 错误处理500错误如果代码运行过程中发生错误，我们需要把错误信息返回给用户。HTTP 协定约定这时要返回500状态码。Koa 提供了ctx.throw()方法，用来抛出错误，ctx.throw(500)就是抛出500错误。 123const main = ctx =&gt; &#123; ctx.throw(500);&#125;; 404错误如果将ctx.response.status设置成404，就相当于ctx.throw(404)，返回404错误。 1234const main = ctx =&gt; &#123; ctx.response.status = 404; ctx.response.body = 'Page Not Found';&#125;; 处理错误的中间件1234567891011121314151617const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.response.status = err.statusCode || err.status || 500; ctx.response.body = &#123; message: err.message &#125;; &#125;&#125;;const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.use(handler);app.use(main); error事件的监听运行过程中一旦出错，Koa 会触发一个error事件。监听这个事件，也可以处理错误。 1234567const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.on('error', (err, ctx) =&gt; console.error('server error', err);); 释放 error 事件需要注意的是，如果错误被try…catch捕获，就不会触发error事件。这时，必须调用ctx.app.emit()，手动释放error事件，才能让监听函数生效 1234567891011121314151617181920const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.response.status = err.statusCode || err.status || 500; ctx.response.type = 'html'; ctx.response.body = '&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;'; ctx.app.emit('error', err, ctx); &#125;&#125;;const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.on('error', function(err) &#123; console.log('logging error ', err.message); console.log(err);&#125;); Web App的功能Cookiesctx.cookies用来读写 Cookie 12345const main = function(ctx) &#123; const n = Number(ctx.cookies.get('view') || 0) + 1; ctx.cookies.set('view', n); ctx.response.body = n + ' views';&#125; 表单Web 应用离不开处理表单。本质上，表单就是 POST 方法发送到服务器的键值对。koa-body模块可以用来从 POST 请求的数据体里面提取键值对。 123456789const koaBody = require('koa-body');const main = async function(ctx) &#123; const body = ctx.request.body; if (!body.name) ctx.throw(400, '.name required'); ctx.body = &#123; name: body.name &#125;;&#125;;app.use(koaBody()); 文件上传koa-body模块还可以用来处理文件上传。 12345678910111213141516171819202122const os = require('os');const path = require('path');const koaBody = require('koa-body');const main = async function(ctx) &#123; const tmpdir = os.tmpdir(); const filePaths = []; const files = ctx.request.body.files || &#123;&#125;; for (let key in files) &#123; const file = files[key]; const filePath = path.join(tmpdir, file.name); const reader = fs.createReadStream(file.path); const writer = fs.createWriteStream(filePath); reader.pipe(writer); filePaths.push(filePath); &#125; ctx.body = filePaths;&#125;;app.use(koaBody(&#123; multipart: true &#125;));]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rollup.js的使用]]></title>
    <url>%2Fpost%2Fd0055c9e.html</url>
    <content type="text"><![CDATA[全局安装rollup1npm install -g rollup 构建外部文件(src/basic.js)1234567export function u() &#123; try&#123; return 'uid'; &#125;catch (e)&#123; console.log(e); &#125;&#125; 构建入口文件(src/main.js)123import &#123; u &#125; from './basic';console.log(u()); 构建打包文件(rollup.config.js)12345export default &#123; entry: 'src/main.js', //入口文件 format: 'cjs', dest: 'rel/bundle.js' // 输出文件&#125;; 执行打包命令1rollup -c 附件API讲解 实例]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>打包工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node小知识（1）]]></title>
    <url>%2Fpost%2Fda8c6d93.html</url>
    <content type="text"><![CDATA[Nodejs优缺点优点 事件驱动，通过闭包很容易实现客户端的生命活期。 不用担心多线程，锁，并行计算的问题 V8引擎速度非常快 对于游戏来说，写一遍游戏逻辑代码，前端后端通用 缺点 nodejs更新很快，可能会出现版本兼容 nodejs还不算成熟，还没有大制作 nodejs不像其他的服务器，对于不同的链接，不支持进程和线程操作 预防timing attacks攻击12345678function checkApiKey(apiKeyFromDb, apiKeyReceived)&#123; if (apiKeyFromDb === apiKeyReceived) &#123; return true &#125; return false&#125; 比较密码时，不能泄露任何信息，因此比较必须在固定时间完成。否则，可以使用timing attacks来攻击你的应用。为什么会这样呢?Node.js使用V8引擎，它会从性能角度优化代码。它会逐个比较字符串的字母，一旦发现不匹配时就停止比较。当攻击者的密码更准确时，比较的时间越长。因此，攻击者可以通过比较的时间长短来判断密码的正确性。使用cryptiles可以解决这个问题: 1234function checkApiKey(apiKeyFromDb, apiKeyReceived)&#123; return cryptiles.fixedTimeComparison(apiKeyFromDb, apiKeyReceived)&#125; 什么是错误优先的回调函数？错误优先的回调函数(Error-First Callback)用于同时返回错误和数据。第一个参数返回错误，并且验证它是否出错；其他参数用于返回数据。 123456789fs.readFile(filePath, function(err, data)&#123; if (err) &#123; // 处理错误 return err; &#125; console.log(data);&#125;); 如何避免回调地狱？ 模块化: 将回调函数转换为独立的函数 使用流程控制库，例如aync 使用Promise 使用aync/await(参考Async/Await替代Promise的6个理由) 用什么工具保证一致的代码风格？为什么要这样？团队协作时，保证一致的代码风格是非常重要的，这样团队成员才可以更快地修改代码，而不需要每次去适应新的风格。这些工具可以帮助我们： ESLint Standard JSLint JSHint ESLint JSCS推荐 什么是事件循环 Node采用的是单线程的处理机制(所有的I/O请求都采用非阻塞的工作方式)，至少从Node.js开发者的角度是这样的。而在底层，Node.js借助libuv来作为抽象封装层，从而屏蔽不同操作系统的差异，Node可以借助libuv来实现线程。 Libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的执行结果返回给V8引擎。 每一个I/O都需要一个回调函数————一旦执行完便堆到事件循环上用于执行 Cookies如何防范XSS攻击？SS(Cross-Site Scripting，跨站脚本攻击)是指攻击者在返回的HTML中插入JavaScript脚本。为了减轻这些攻击，需要在HTTP头部配置set-cookie: HttpOnly - 这个属性可以防止cross-site scripting，因为它会禁止Javascript脚本访问cookie。 secure - 这个属性告诉浏览器仅在请求为HTTPS时发送cookie 结果应该是这样的: Set-Cookie: sid=; HttpOnly. 使用监控unhandledRejection事件来捕获所有未处理的Promise错误:1234process.on('unhandledRejection', (err) =&gt;&#123; console.log(err)&#125;) 什么是Promise?Promise是一个构造函数，有属于自己私有的all,reject,resolve,rece等方法，也有原型上面的，属于实例对象调用的方法then,catch 12345678910111213141516// Promise里面传入一个函数类型的参数，这个函数类型的参数接收两个参数resolve rejectvar p=new Promise(function(resolve,reject)&#123; // 异步操作 setTimeout(function()&#123; console.log('icessun'); // 两秒之后打印出icessun resolve('icessun2'); // resolve是成功后的回调函数 里面的icessun2是传入的参数 &#125;,2000) &#125;);// 那么p是一个实例对象，可以使用then方法（Promise原型上面的方法）p.then(function()&#123; console.log(arguments); // 会打印出一个类数组 ['icessun2'] &#125;)p.then(function(data)&#123; console.log(data); // 会打印出icessun2 data接收了resolve里面的参数 &#125;) 于上面这段代码，首先new一个实例对象赋值给p，Promise的构造函数接受一个参数，是函数；并且传入两个参数：resolve,reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数；然后里面设置一个定时器setTimeout，开启一个异步操作，两秒后输出icessun，并且调用resolve方法 1234567891011121314151617181920212223function icessun()&#123; var p=new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; console.log('icessun'); reslove('icessun2'); &#125;,2000); &#125;); return p; // 返回p实例，使其可以使用Promise原型上面的方法&#125;icessun(); // 调用执行icessun函数 得到一个Promis对象// 也可以直接这样调用icessun().then(function(data)&#123;console.log(data); // icessun2// 一些其他的操作// .....&#125;);作者：icessun链接：https://www.jianshu.com/p/43f948051d65來源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 promsie1234567Promise.resolve(1) .then((x) =&gt; x + 1) .then((x) =&gt; &#123; throw new Error('My Error') &#125;) .catch(() =&gt; 1) .then((x) =&gt; x + 1) .then((x) =&gt; console.log(x)) .catch(console.error) 答案是2，逐行解释如下: 创建新的Promise，resolve值为1。 x为1，加1之后返回2。 x为2，但是没有用到。抛出一个错误。 捕获错误，但是没有处理。返回1。 x为1，加1之后返回2。 x为2，打印2。 不会执行，因为没有错误抛出。 参考Nodejs2017 Promise用法]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE公共组件的使用]]></title>
    <url>%2Fpost%2F8d07ac1f.html</url>
    <content type="text"><![CDATA[创建一个组件imgTarg.vue 123456789101112&lt;template&gt;......&lt;/template&gt;&lt;script&gt; export default &#123; props:["imgUrl","keyId"] &#125; &lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 引入组件12import imgTarg from './components/imgTarg'Vue.component('img-targ', imgTarg); 使用(在需要的组件中)1&lt;img-targ v-for="(data,index) in data" :key="index" :imgUrl="data" :keyId="index"&gt;&lt;/img-targ&gt;]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE中使用埋点（如何使用外部js）]]></title>
    <url>%2Fpost%2F1a9bc311.html</url>
    <content type="text"><![CDATA[简介说是使用无痕埋点，只是因为遇见了这种情况，因为现在前端有非常多的框架，我们想要把外部的js引进来就需要多一步的操作： 全局开放封装的埋点代码1234567let maidian = function ()&#123; &#125;export &#123; checkName&#125; 引入代码中使用123456//引入import &#123;maidian&#125; from './../../static/maidian'//使用,建议放入methods中，或者mounteds中maidian() 附件一个模糊查询姓名是否匹配的插件 使用方式 123456789//引入import &#123;checkName&#125; from './../../static/pinYIn'//在代码中使用checkName('你要判断的名字','你所拥有名字的数组')//如果匹配返回true，否则返回false 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461var PinYin = &#123; "a": "\u554a\u963f\u9515", "ai": "\u57c3\u6328\u54ce\u5509\u54c0\u7691\u764c\u853c\u77ee\u827e\u788d\u7231\u9698\u8bf6\u6371\u55f3\u55cc\u5ad2\u7477\u66a7\u7839\u953f\u972d", "an": "\u978d\u6c28\u5b89\u4ffa\u6309\u6697\u5cb8\u80fa\u6848\u8c19\u57ef\u63de\u72b4\u5eb5\u6849\u94f5\u9e4c\u9878\u9eef", "ang": "\u80ae\u6602\u76ce", "ao": "\u51f9\u6556\u71ac\u7ff1\u8884\u50b2\u5965\u61ca\u6fb3\u5773\u62d7\u55f7\u5662\u5c99\u5ed2\u9068\u5aaa\u9a9c\u8071\u87af\u93ca\u9ccc\u93d6", "ba": "\u82ad\u634c\u6252\u53ed\u5427\u7b06\u516b\u75a4\u5df4\u62d4\u8dcb\u9776\u628a\u8019\u575d\u9738\u7f62\u7238\u8307\u83dd\u8406\u636d\u5c9c\u705e\u6777\u94af\u7c91\u9c85\u9b43", "bai": "\u767d\u67cf\u767e\u6446\u4f70\u8d25\u62dc\u7a17\u859c\u63b0\u97b4", "ban": "\u6591\u73ed\u642c\u6273\u822c\u9881\u677f\u7248\u626e\u62cc\u4f34\u74e3\u534a\u529e\u7eca\u962a\u5742\u8c73\u94a3\u7622\u764d\u8228", "bang": "\u90a6\u5e2e\u6886\u699c\u8180\u7ed1\u68d2\u78c5\u868c\u9551\u508d\u8c24\u84a1\u8783", "bao": "\u82de\u80de\u5305\u8912\u96f9\u4fdd\u5821\u9971\u5b9d\u62b1\u62a5\u66b4\u8c79\u9c8d\u7206\u52f9\u8446\u5b80\u5b62\u7172\u9e28\u8913\u8db5\u9f85", "bo": "\u5265\u8584\u73bb\u83e0\u64ad\u62e8\u94b5\u6ce2\u535a\u52c3\u640f\u94c2\u7b94\u4f2f\u5e1b\u8236\u8116\u818a\u6e24\u6cca\u9a73\u4eb3\u8543\u5575\u997d\u6a97\u64d8\u7934\u94b9\u9e41\u7c38\u8ddb", "bei": "\u676f\u7891\u60b2\u5351\u5317\u8f88\u80cc\u8d1d\u94a1\u500d\u72c8\u5907\u60eb\u7119\u88ab\u5b5b\u9642\u90b6\u57e4\u84d3\u5457\u602b\u6096\u789a\u9e4e\u8919\u943e", "ben": "\u5954\u82ef\u672c\u7b28\u755a\u574c\u951b", "beng": "\u5d29\u7ef7\u752d\u6cf5\u8e66\u8ff8\u552a\u5623\u750f", "bi": "\u903c\u9f3b\u6bd4\u9119\u7b14\u5f7c\u78a7\u84d6\u853d\u6bd5\u6bd9\u6bd6\u5e01\u5e87\u75f9\u95ed\u655d\u5f0a\u5fc5\u8f9f\u58c1\u81c2\u907f\u965b\u5315\u4ef3\u4ffe\u8298\u835c\u8378\u5421\u54d4\u72f4\u5eb3\u610e\u6ed7\u6fde\u5f3c\u59a3\u5a62\u5b16\u74a7\u8d32\u7540\u94cb\u79d5\u88e8\u7b5a\u7b85\u7be6\u822d\u895e\u8df8\u9ac0", "bian": "\u97ad\u8fb9\u7f16\u8d2c\u6241\u4fbf\u53d8\u535e\u8fa8\u8fa9\u8fab\u904d\u533e\u5f01\u82c4\u5fed\u6c74\u7f0f\u7178\u782d\u78a5\u7a39\u7a86\u8759\u7b3e\u9cca", "biao": "\u6807\u5f6a\u8198\u8868\u5a4a\u9aa0\u98d1\u98d9\u98da\u706c\u9556\u9573\u762d\u88f1\u9cd4", "bie": "\u9cd6\u618b\u522b\u762a\u8e69\u9cd8", "bin": "\u5f6c\u658c\u6fd2\u6ee8\u5bbe\u6448\u50a7\u6d5c\u7f24\u73a2\u6ba1\u8191\u9554\u9acc\u9b13", "bing": "\u5175\u51b0\u67c4\u4e19\u79c9\u997c\u70b3\u75c5\u5e76\u7980\u90b4\u6452\u7ee0\u678b\u69df\u71f9", "bu": "\u6355\u535c\u54fa\u8865\u57e0\u4e0d\u5e03\u6b65\u7c3f\u90e8\u6016\u62ca\u535f\u900b\u74ff\u6661\u949a\u91ad", "ca": "\u64e6\u5693\u7924", "cai": "\u731c\u88c1\u6750\u624d\u8d22\u776c\u8e29\u91c7\u5f69\u83dc\u8521", "can": "\u9910\u53c2\u8695\u6b8b\u60ed\u60e8\u707f\u9a96\u74a8\u7cb2\u9eea", "cang": "\u82cd\u8231\u4ed3\u6ca7\u85cf\u4f27", "cao": "\u64cd\u7cd9\u69fd\u66f9\u8349\u8279\u5608\u6f15\u87ac\u825a", "ce": "\u5395\u7b56\u4fa7\u518c\u6d4b\u5202\u5e3b\u607b", "ceng": "\u5c42\u8e6d\u564c", "cha": "\u63d2\u53c9\u832c\u8336\u67e5\u78b4\u643d\u5bdf\u5c94\u5dee\u8be7\u7339\u9987\u6c4a\u59f9\u6748\u6942\u69ce\u6aab\u9497\u9538\u9572\u8869", "chai": "\u62c6\u67f4\u8c7a\u4faa\u8308\u7625\u867f\u9f87", "chan": "\u6400\u63ba\u8749\u998b\u8c17\u7f20\u94f2\u4ea7\u9610\u98a4\u5181\u8c04\u8c36\u8487\u5edb\u5fcf\u6f7a\u6fb6\u5b71\u7fbc\u5a75\u5b17\u9aa3\u89c7\u7985\u9561\u88e3\u87fe\u8e94", "chang": "\u660c\u7316\u573a\u5c1d\u5e38\u957f\u507f\u80a0\u5382\u655e\u7545\u5531\u5021\u4f25\u9b2f\u82cc\u83d6\u5f9c\u6005\u60dd\u960a\u5a3c\u5ae6\u6636\u6c05\u9cb3", "chao": "\u8d85\u6284\u949e\u671d\u5632\u6f6e\u5de2\u5435\u7092\u600a\u7ec9\u6641\u8016", "che": "\u8f66\u626f\u64a4\u63a3\u5f7b\u6f88\u577c\u5c6e\u7817", "chen": "\u90f4\u81e3\u8fb0\u5c18\u6668\u5ff1\u6c89\u9648\u8d81\u886c\u79f0\u8c0c\u62bb\u55d4\u5bb8\u741b\u6987\u809c\u80c2\u789c\u9f80", "cheng": "\u6491\u57ce\u6a59\u6210\u5448\u4e58\u7a0b\u60e9\u6f84\u8bda\u627f\u901e\u9a8b\u79e4\u57d5\u5d4a\u5fb5\u6d48\u67a8\u67fd\u6a18\u665f\u584d\u77a0\u94d6\u88ce\u86cf\u9172", "chi": "\u5403\u75f4\u6301\u5319\u6c60\u8fdf\u5f1b\u9a70\u803b\u9f7f\u4f88\u5c3a\u8d64\u7fc5\u65a5\u70bd\u50ba\u5880\u82aa\u830c\u640b\u53f1\u54e7\u557b\u55e4\u5f73\u996c\u6cb2\u5ab8\u6555\u80dd\u7719\u7735\u9e31\u761b\u892b\u86a9\u87ad\u7b1e\u7bea\u8c49\u8e05\u8e1f\u9b51", "chong": "\u5145\u51b2\u866b\u5d07\u5ba0\u833a\u5fe1\u61a7\u94f3\u825f", "chou": "\u62bd\u916c\u7574\u8e0c\u7a20\u6101\u7b79\u4ec7\u7ef8\u7785\u4e11\u4fe6\u5733\u5e31\u60c6\u6eb4\u59af\u7633\u96e0\u9c8b", "chu": "\u81ed\u521d\u51fa\u6a71\u53a8\u8e87\u9504\u96cf\u6ec1\u9664\u695a\u7840\u50a8\u77d7\u6410\u89e6\u5904\u4e8d\u520d\u61b7\u7ecc\u6775\u696e\u6a17\u870d\u8e70\u9edc", "chuan": "\u63e3\u5ddd\u7a7f\u693d\u4f20\u8239\u5598\u4e32\u63be\u821b\u60f4\u9044\u5ddb\u6c1a\u948f\u9569\u8221", "chuang": "\u75ae\u7a97\u5e62\u5e8a\u95ef\u521b\u6006", "chui": "\u5439\u708a\u6376\u9524\u5782\u9672\u68f0\u69cc", "chun": "\u6625\u693f\u9187\u5507\u6df3\u7eaf\u8822\u4fc3\u83bc\u6c8c\u80ab\u6710\u9e51\u877d", "chuo": "\u6233\u7ef0\u851f\u8fb6\u8f8d\u955e\u8e14\u9f8a", "ci": "\u75b5\u8328\u78c1\u96cc\u8f9e\u6148\u74f7\u8bcd\u6b64\u523a\u8d50\u6b21\u8360\u5472\u5d6f\u9e5a\u8785\u7ccd\u8d91", "cong": "\u806a\u8471\u56f1\u5306\u4ece\u4e1b\u506c\u82c1\u6dd9\u9aa2\u742e\u7481\u679e", "cu": "\u51d1\u7c97\u918b\u7c07\u731d\u6b82\u8e59", "cuan": "\u8e7f\u7be1\u7a9c\u6c46\u64ba\u6615\u7228", "cui": "\u6467\u5d14\u50ac\u8106\u7601\u7cb9\u6dec\u7fe0\u8403\u60b4\u7480\u69b1\u96b9", "cun": "\u6751\u5b58\u5bf8\u78cb\u5fd6\u76b4", "cuo": "\u64ae\u6413\u63aa\u632b\u9519\u539d\u811e\u9509\u77ec\u75e4\u9e7e\u8e49\u8e9c", "da": "\u642d\u8fbe\u7b54\u7629\u6253\u5927\u8037\u54d2\u55d2\u601b\u59b2\u75b8\u8921\u7b2a\u977c\u9791", "dai": "\u5446\u6b79\u50a3\u6234\u5e26\u6b86\u4ee3\u8d37\u888b\u5f85\u902e\u6020\u57ed\u7519\u5454\u5cb1\u8fe8\u902f\u9a80\u7ed0\u73b3\u9edb", "dan": "\u803d\u62c5\u4e39\u5355\u90f8\u63b8\u80c6\u65e6\u6c2e\u4f46\u60ee\u6de1\u8bde\u5f39\u86cb\u4ebb\u510b\u5369\u840f\u5556\u6fb9\u6a90\u6b9a\u8d55\u7708\u7605\u8043\u7baa", "dang": "\u5f53\u6321\u515a\u8361\u6863\u8c20\u51fc\u83ea\u5b95\u7800\u94db\u88c6", "dao": "\u5200\u6363\u8e48\u5012\u5c9b\u7977\u5bfc\u5230\u7a3b\u60bc\u9053\u76d7\u53e8\u5541\u5fc9\u6d2e\u6c18\u7118\u5fd1\u7e9b", "de": "\u5fb7\u5f97\u7684\u951d", "deng": "\u8e6c\u706f\u767b\u7b49\u77aa\u51f3\u9093\u5654\u5d9d\u6225\u78f4\u956b\u7c26", "di": "\u5824\u4f4e\u6ef4\u8fea\u654c\u7b1b\u72c4\u6da4\u7fdf\u5ae1\u62b5\u5e95\u5730\u8482\u7b2c\u5e1d\u5f1f\u9012\u7f14\u6c10\u7c74\u8bcb\u8c1b\u90b8\u577b\u839c\u837b\u5600\u5a23\u67e2\u68e3\u89cc\u7825\u78b2\u7747\u955d\u7f9d\u9ab6", "dian": "\u98a0\u6382\u6ec7\u7898\u70b9\u5178\u975b\u57ab\u7535\u4f43\u7538\u5e97\u60e6\u5960\u6dc0\u6bbf\u4e36\u963d\u576b\u57dd\u5dc5\u73b7\u765c\u766b\u7c1f\u8e2e", "diao": "\u7889\u53fc\u96d5\u51cb\u5201\u6389\u540a\u9493\u8c03\u8f7a\u94de\u8729\u7c9c\u8c82", "die": "\u8dcc\u7239\u789f\u8776\u8fed\u8c0d\u53e0\u4f5a\u57a4\u581e\u63f2\u558b\u6e2b\u8f76\u7252\u74de\u8936\u800b\u8e40\u9cbd\u9cce", "ding": "\u4e01\u76ef\u53ee\u9489\u9876\u9f0e\u952d\u5b9a\u8ba2\u4e22\u4ec3\u5576\u738e\u815a\u7887\u753a\u94e4\u7594\u8035\u914a", "dong": "\u4e1c\u51ac\u8463\u61c2\u52a8\u680b\u4f97\u606b\u51bb\u6d1e\u578c\u549a\u5cbd\u5cd2\u5902\u6c21\u80e8\u80f4\u7850\u9e2b", "dou": "\u515c\u6296\u6597\u9661\u8c46\u9017\u75d8\u8538\u94ad\u7aa6\u7aac\u86aa\u7bfc\u9161", "du": "\u90fd\u7763\u6bd2\u728a\u72ec\u8bfb\u5835\u7779\u8d4c\u675c\u9540\u809a\u5ea6\u6e21\u5992\u828f\u561f\u6e0e\u691f\u6a50\u724d\u8839\u7b03\u9ad1\u9ee9", "duan": "\u7aef\u77ed\u953b\u6bb5\u65ad\u7f0e\u5f56\u6934\u7145\u7c16", "dui": "\u5806\u5151\u961f\u5bf9\u603c\u619d\u7893", "dun": "\u58a9\u5428\u8e72\u6566\u987f\u56e4\u949d\u76fe\u9041\u7096\u7818\u7905\u76f9\u9566\u8db8", "duo": "\u6387\u54c6\u591a\u593a\u579b\u8eb2\u6735\u8dfa\u8235\u5241\u60f0\u5815\u5484\u54da\u7f0d\u67c1\u94ce\u88f0\u8e31", "e": "\u86fe\u5ce8\u9e45\u4fc4\u989d\u8bb9\u5a25\u6076\u5384\u627c\u904f\u9102\u997f\u5669\u8c14\u57a9\u57ad\u82ca\u83aa\u843c\u5443\u6115\u5c59\u5a40\u8f6d\u66f7\u816d\u786a\u9507\u9537\u9e57\u989a\u9cc4", "en": "\u6069\u84bd\u6441\u5514\u55ef", "er": "\u800c\u513f\u8033\u5c14\u9975\u6d31\u4e8c\u8d30\u8fe9\u73e5\u94d2\u9e38\u9c95", "fa": "\u53d1\u7f5a\u7b4f\u4f10\u4e4f\u9600\u6cd5\u73d0\u57a1\u781d", "fan": "\u85e9\u5e06\u756a\u7ffb\u6a0a\u77fe\u9492\u7e41\u51e1\u70e6\u53cd\u8fd4\u8303\u8d29\u72af\u996d\u6cdb\u8629\u5e61\u72ad\u68b5\u6535\u71d4\u7548\u8e6f", "fang": "\u574a\u82b3\u65b9\u80aa\u623f\u9632\u59a8\u4eff\u8bbf\u7eba\u653e\u531a\u90a1\u5f77\u94ab\u822b\u9c82", "fei": "\u83f2\u975e\u5561\u98de\u80a5\u532a\u8bfd\u5420\u80ba\u5e9f\u6cb8\u8d39\u82be\u72d2\u60b1\u6ddd\u5983\u7ecb\u7eef\u69a7\u8153\u6590\u6249\u7953\u7829\u9544\u75f1\u871a\u7bda\u7fe1\u970f\u9cb1", "fen": "\u82ac\u915a\u5429\u6c1b\u5206\u7eb7\u575f\u711a\u6c7e\u7c89\u594b\u4efd\u5fff\u6124\u7caa\u507e\u7035\u68fc\u610d\u9cbc\u9f22", "feng": "\u4e30\u5c01\u67ab\u8702\u5cf0\u950b\u98ce\u75af\u70fd\u9022\u51af\u7f1d\u8bbd\u5949\u51e4\u4ff8\u9146\u8451\u6ca3\u781c", "fu": "\u4f5b\u5426\u592b\u6577\u80a4\u5b75\u6276\u62c2\u8f90\u5e45\u6c1f\u7b26\u4f0f\u4fd8\u670d\u6d6e\u6daa\u798f\u88b1\u5f17\u752b\u629a\u8f85\u4fef\u91dc\u65a7\u812f\u8151\u5e9c\u8150\u8d74\u526f\u8986\u8d4b\u590d\u5085\u4ed8\u961c\u7236\u8179\u8d1f\u5bcc\u8ba3\u9644\u5987\u7f1a\u5490\u5310\u51eb\u90db\u8299\u82fb\u832f\u83a9\u83d4\u544b\u5e5e\u6ecf\u8274\u5b5a\u9a78\u7ec2\u6874\u8d59\u9efb\u9efc\u7f58\u7a03\u99a5\u864d\u86a8\u8709\u8760\u876e\u9eb8\u8dba\u8dd7\u9cc6", "ga": "\u5676\u560e\u86e4\u5c2c\u5477\u5c15\u5c1c\u65ee\u9486", "gai": "\u8be5\u6539\u6982\u9499\u76d6\u6e89\u4e10\u9654\u5793\u6224\u8d45\u80f2", "gan": "\u5e72\u7518\u6746\u67d1\u7aff\u809d\u8d76\u611f\u79c6\u6562\u8d63\u5769\u82f7\u5c34\u64c0\u6cd4\u6de6\u6f89\u7ec0\u6a44\u65f0\u77f8\u75b3\u9150", "gang": "\u5188\u521a\u94a2\u7f38\u809b\u7eb2\u5c97\u6e2f\u6206\u7f61\u9883\u7b7b", "gong": "\u6760\u5de5\u653b\u529f\u606d\u9f9a\u4f9b\u8eac\u516c\u5bab\u5f13\u5de9\u6c5e\u62f1\u8d21\u5171\u857b\u5efe\u54a3\u73d9\u80b1\u86a3\u86e9\u89e5", "gao": "\u7bd9\u768b\u9ad8\u818f\u7f94\u7cd5\u641e\u9550\u7a3f\u544a\u777e\u8bf0\u90dc\u84bf\u85c1\u7f1f\u69d4\u69c1\u6772\u9506", "ge": "\u54e5\u6b4c\u6401\u6208\u9e3d\u80f3\u7599\u5272\u9769\u845b\u683c\u9601\u9694\u94ec\u4e2a\u5404\u9b32\u4ee1\u54ff\u5865\u55dd\u7ea5\u643f\u8188\u784c\u94ea\u9549\u88bc\u988c\u867c\u8238\u9abc\u9ac2", "gei": "\u7ed9", "gen": "\u6839\u8ddf\u4e98\u831b\u54cf\u826e", "geng": "\u8015\u66f4\u5e9a\u7fb9\u57c2\u803f\u6897\u54fd\u8d53\u9ca0", "gou": "\u94a9\u52fe\u6c9f\u82df\u72d7\u57a2\u6784\u8d2d\u591f\u4f5d\u8bdf\u5ca3\u9058\u5abe\u7f11\u89cf\u5f40\u9e32\u7b31\u7bdd\u97b2", "gu": "\u8f9c\u83c7\u5495\u7b8d\u4f30\u6cbd\u5b64\u59d1\u9f13\u53e4\u86ca\u9aa8\u8c37\u80a1\u6545\u987e\u56fa\u96c7\u560f\u8bc2\u83f0\u54cc\u5d2e\u6c69\u688f\u8f71\u726f\u727f\u80cd\u81cc\u6bc2\u77bd\u7f5f\u94b4\u9522\u74e0\u9e2a\u9e44\u75fc\u86c4\u9164\u89da\u9cb4\u9ab0\u9e58", "gua": "\u522e\u74dc\u5250\u5be1\u6302\u8902\u5366\u8bd6\u5471\u681d\u9e39", "guai": "\u4e56\u62d0\u602a\u54d9", "guan": "\u68fa\u5173\u5b98\u51a0\u89c2\u7ba1\u9986\u7f50\u60ef\u704c\u8d2f\u500c\u839e\u63bc\u6dab\u76e5\u9e73\u9ccf", "guang": "\u5149\u5e7f\u901b\u72b7\u6844\u80f1\u7592", "gui": "\u7470\u89c4\u572d\u7845\u5f52\u9f9f\u95fa\u8f68\u9b3c\u8be1\u7678\u6842\u67dc\u8dea\u8d35\u523d\u5326\u523f\u5e8b\u5b84\u59ab\u6867\u7085\u6677\u7688\u7c0b\u9c91\u9cdc", "gun": "\u8f8a\u6eda\u68cd\u4e28\u886e\u7ef2\u78d9\u9ca7", "guo": "\u9505\u90ed\u56fd\u679c\u88f9\u8fc7\u9998\u8803\u57da\u63b4\u5459\u56d7\u5e3c\u5d1e\u7313\u6901\u8662\u951e\u8052\u872e\u873e\u8748", "ha": "\u54c8", "hai": "\u9ab8\u5b69\u6d77\u6c26\u4ea5\u5bb3\u9a87\u54b4\u55e8\u988f\u91a2", "han": "\u9163\u61a8\u90af\u97e9\u542b\u6db5\u5bd2\u51fd\u558a\u7f55\u7ff0\u64bc\u634d\u65f1\u61be\u608d\u710a\u6c57\u6c49\u9097\u83e1\u6496\u961a\u701a\u6657\u7113\u9894\u86b6\u9f3e", "hen": "\u592f\u75d5\u5f88\u72e0\u6068", "hang": "\u676d\u822a\u6c86\u7ed7\u73e9\u6841", "hao": "\u58d5\u568e\u8c6a\u6beb\u90dd\u597d\u8017\u53f7\u6d69\u8585\u55e5\u5686\u6fe0\u704f\u660a\u7693\u98a2\u869d", "he": "\u5475\u559d\u8377\u83cf\u6838\u79be\u548c\u4f55\u5408\u76d2\u8c89\u9602\u6cb3\u6db8\u8d6b\u8910\u9e64\u8d3a\u8bc3\u52be\u58d1\u85ff\u55d1\u55ec\u9616\u76cd\u86b5\u7fee", "hei": "\u563f\u9ed1", "heng": "\u54fc\u4ea8\u6a2a\u8861\u6052\u8a07\u8605", "hong": "\u8f70\u54c4\u70d8\u8679\u9e3f\u6d2a\u5b8f\u5f18\u7ea2\u9ec9\u8ba7\u836d\u85a8\u95f3\u6cd3", "hou": "\u5589\u4faf\u7334\u543c\u539a\u5019\u540e\u5820\u5f8c\u9005\u760a\u7bcc\u7cc7\u9c8e\u9aba", "hu": "\u547c\u4e4e\u5ffd\u745a\u58f6\u846b\u80e1\u8774\u72d0\u7cca\u6e56\u5f27\u864e\u552c\u62a4\u4e92\u6caa\u6237\u51b1\u553f\u56eb\u5cb5\u7322\u6019\u60da\u6d52\u6ef9\u7425\u69f2\u8f77\u89f3\u70c0\u7173\u623d\u6248\u795c\u9e55\u9e71\u7b0f\u9190\u659b", "hua": "\u82b1\u54d7\u534e\u733e\u6ed1\u753b\u5212\u5316\u8bdd\u5290\u6d4d\u9a85\u6866\u94e7\u7a1e", "huai": "\u69d0\u5f8a\u6000\u6dee\u574f\u8fd8\u8e1d", "huan": "\u6b22\u73af\u6853\u7f13\u6362\u60a3\u5524\u75ea\u8c62\u7115\u6da3\u5ba6\u5e7b\u90c7\u5942\u57b8\u64d0\u571c\u6d39\u6d63\u6f36\u5bf0\u902d\u7f33\u953e\u9ca9\u9b1f", "huang": "\u8352\u614c\u9ec4\u78fa\u8757\u7c27\u7687\u51f0\u60f6\u714c\u6643\u5e4c\u604d\u8c0e\u968d\u5fa8\u6e5f\u6f62\u9051\u749c\u8093\u7640\u87e5\u7bc1\u9cc7", "hui": "\u7070\u6325\u8f89\u5fbd\u6062\u86d4\u56de\u6bc1\u6094\u6167\u5349\u60e0\u6666\u8d3f\u79fd\u4f1a\u70e9\u6c47\u8bb3\u8bf2\u7ed8\u8bd9\u8334\u835f\u8559\u54d5\u5599\u96b3\u6d04\u5f57\u7f0b\u73f2\u6656\u605a\u867a\u87ea\u9ebe", "hun": "\u8364\u660f\u5a5a\u9b42\u6d51\u6df7\u8be8\u9984\u960d\u6eb7\u7f17", "huo": "\u8c41\u6d3b\u4f19\u706b\u83b7\u6216\u60d1\u970d\u8d27\u7978\u6509\u56af\u5925\u94ac\u952a\u956c\u8020\u8816", "ji": "\u51fb\u573e\u57fa\u673a\u7578\u7a3d\u79ef\u7b95\u808c\u9965\u8ff9\u6fc0\u8ba5\u9e21\u59ec\u7ee9\u7f09\u5409\u6781\u68d8\u8f91\u7c4d\u96c6\u53ca\u6025\u75be\u6c72\u5373\u5ac9\u7ea7\u6324\u51e0\u810a\u5df1\u84df\u6280\u5180\u5b63\u4f0e\u796d\u5242\u60b8\u6d4e\u5bc4\u5bc2\u8ba1\u8bb0\u65e2\u5fcc\u9645\u5993\u7ee7\u7eaa\u5c45\u4e0c\u4e69\u525e\u4f76\u4f74\u8114\u58bc\u82a8\u82b0\u8401\u84ba\u857a\u638e\u53fd\u54ad\u54dc\u5527\u5c8c\u5d74\u6d0e\u5f50\u5c50\u9aa5\u757f\u7391\u696b\u6b9b\u621f\u6222\u8d4d\u89ca\u7284\u9f51\u77f6\u7f81\u5d47\u7a37\u7620\u7635\u866e\u7b08\u7b04\u66a8\u8dfb\u8dfd\u9701\u9c9a\u9cab\u9afb\u9e82", "jia": "\u5609\u67b7\u5939\u4f73\u5bb6\u52a0\u835a\u988a\u8d3e\u7532\u94be\u5047\u7a3c\u4ef7\u67b6\u9a7e\u5ac1\u4f3d\u90cf\u62ee\u5cac\u6d43\u8fe6\u73c8\u621b\u80db\u605d\u94d7\u9553\u75c2\u86f1\u7b33\u8888\u8dcf", "jian": "\u6b7c\u76d1\u575a\u5c16\u7b3a\u95f4\u714e\u517c\u80a9\u8270\u5978\u7f04\u8327\u68c0\u67ec\u78b1\u7877\u62e3\u6361\u7b80\u4fed\u526a\u51cf\u8350\u69db\u9274\u8df5\u8d31\u89c1\u952e\u7bad\u4ef6\u5065\u8230\u5251\u996f\u6e10\u6e85\u6da7\u5efa\u50ed\u8c0f\u8c2b\u83c5\u84b9\u641b\u56dd\u6e54\u8e47\u8b07\u7f23\u67a7\u67d9\u6957\u620b\u622c\u726e\u728d\u6bfd\u8171\u7751\u950f\u9e63\u88e5\u7b15\u7bb4\u7fe6\u8dbc\u8e3a\u9ca3\u97af", "jiang": "\u50f5\u59dc\u5c06\u6d46\u6c5f\u7586\u848b\u6868\u5956\u8bb2\u5320\u9171\u964d\u8333\u6d1a\u7edb\u7f30\u729f\u7913\u8029\u7ce8\u8c47", "jiao": "\u8549\u6912\u7901\u7126\u80f6\u4ea4\u90ca\u6d47\u9a84\u5a07\u56bc\u6405\u94f0\u77eb\u4fa5\u811a\u72e1\u89d2\u997a\u7f34\u7ede\u527f\u6559\u9175\u8f7f\u8f83\u53eb\u4f7c\u50ec\u832d\u6322\u564d\u5ce4\u5fbc\u59e3\u7e9f\u656b\u768e\u9e6a\u86df\u91ae\u8de4\u9c9b", "jie": "\u7a96\u63ed\u63a5\u7686\u79f8\u8857\u9636\u622a\u52ab\u8282\u6854\u6770\u6377\u776b\u7aed\u6d01\u7ed3\u89e3\u59d0\u6212\u85c9\u82a5\u754c\u501f\u4ecb\u75a5\u8beb\u5c4a\u5048\u8ba6\u8bd8\u5588\u55df\u736c\u5a55\u5b51\u6840\u7352\u78a3\u9534\u7596\u88b7\u9889\u86a7\u7faf\u9c92\u9ab1\u9aeb", "jin": "\u5dfe\u7b4b\u65a4\u91d1\u4eca\u6d25\u895f\u7d27\u9526\u4ec5\u8c28\u8fdb\u9773\u664b\u7981\u8fd1\u70ec\u6d78\u5c3d\u537a\u8369\u5807\u5664\u9991\u5ed1\u5997\u7f19\u747e\u69ff\u8d46\u89d0\u9485\u9513\u887f\u77dc", "jing": "\u52b2\u8346\u5162\u830e\u775b\u6676\u9cb8\u4eac\u60ca\u7cbe\u7cb3\u7ecf\u4e95\u8b66\u666f\u9888\u9759\u5883\u656c\u955c\u5f84\u75c9\u9756\u7adf\u7ade\u51c0\u522d\u5106\u9631\u83c1\u734d\u61ac\u6cfe\u8ff3\u5f2a\u5a67\u80bc\u80eb\u8148\u65cc", "jiong": "\u70af\u7a98\u5182\u8fe5\u6243", "jiu": "\u63ea\u7a76\u7ea0\u7396\u97ed\u4e45\u7078\u4e5d\u9152\u53a9\u6551\u65e7\u81fc\u8205\u548e\u5c31\u759a\u50e6\u557e\u9604\u67e9\u6855\u9e6b\u8d73\u9b0f", "ju": "\u97a0\u62d8\u72d9\u75bd\u9a79\u83ca\u5c40\u5480\u77e9\u4e3e\u6cae\u805a\u62d2\u636e\u5de8\u5177\u8ddd\u8e1e\u952f\u4ff1\u53e5\u60e7\u70ac\u5267\u5028\u8bb5\u82e3\u82f4\u8392\u63ac\u907d\u5c66\u741a\u67b8\u6910\u6998\u6989\u6a58\u728b\u98d3\u949c\u9514\u7aad\u88fe\u8d84\u91b5\u8e3d\u9f83\u96ce\u97ab", "juan": "\u6350\u9e43\u5a1f\u5026\u7737\u5377\u7ee2\u9104\u72f7\u6d93\u684a\u8832\u9529\u954c\u96bd", "jue": "\u6485\u652b\u6289\u6398\u5014\u7235\u89c9\u51b3\u8bc0\u7edd\u53a5\u5282\u8c32\u77cd\u8568\u5658\u5d1b\u7357\u5b53\u73cf\u6877\u6a5b\u721d\u9562\u8e76\u89d6", "jun": "\u5747\u83cc\u94a7\u519b\u541b\u5cfb\u4fca\u7ae3\u6d5a\u90e1\u9a8f\u6343\u72fb\u76b2\u7b60\u9e87", "ka": "\u5580\u5496\u5361\u4f67\u5494\u80e9", "ke": "\u54af\u5777\u82db\u67ef\u68f5\u78d5\u9897\u79d1\u58f3\u54b3\u53ef\u6e34\u514b\u523b\u5ba2\u8bfe\u5ca2\u606a\u6e98\u9a92\u7f02\u73c2\u8f72\u6c2a\u778c\u94b6\u75b4\u7aa0\u874c\u9ac1", "kai": "\u5f00\u63e9\u6977\u51ef\u6168\u5240\u57b2\u8488\u5ffe\u607a\u94e0\u950e", "kan": "\u520a\u582a\u52d8\u574e\u780d\u770b\u4f83\u51f5\u83b0\u83b6\u6221\u9f9b\u77b0", "kang": "\u5eb7\u6177\u7ce0\u625b\u6297\u4ea2\u7095\u5751\u4f09\u95f6\u94aa", "kao": "\u8003\u62f7\u70e4\u9760\u5c3b\u6832\u7292\u94d0", "ken": "\u80af\u5543\u57a6\u6073\u57a0\u88c9\u9880", "keng": "\u542d\u5fd0\u94ff", "kong": "\u7a7a\u6050\u5b54\u63a7\u5025\u5d06\u7b9c", "kou": "\u62a0\u53e3\u6263\u5bc7\u82a4\u853b\u53e9\u770d\u7b58", "ku": "\u67af\u54ed\u7a9f\u82e6\u9177\u5e93\u88e4\u5233\u5800\u55be\u7ed4\u9ab7", "kua": "\u5938\u57ae\u630e\u8de8\u80ef\u4f89", "kuai": "\u5757\u7b77\u4fa9\u5feb\u84af\u90d0\u8489\u72ef\u810d", "kuan": "\u5bbd\u6b3e\u9acb", "kuang": "\u5321\u7b50\u72c2\u6846\u77ff\u7736\u65f7\u51b5\u8bd3\u8bf3\u909d\u5739\u593c\u54d0\u7ea9\u8d36", "kui": "\u4e8f\u76d4\u5cbf\u7aa5\u8475\u594e\u9b41\u5080\u9988\u6127\u6e83\u9997\u532e\u5914\u9697\u63c6\u55b9\u559f\u609d\u6126\u9615\u9035\u668c\u777d\u8069\u8770\u7bd1\u81fe\u8dec", "kun": "\u5764\u6606\u6346\u56f0\u6083\u9603\u7428\u951f\u918c\u9cb2\u9ae1", "kuo": "\u62ec\u6269\u5ed3\u9614\u86de", "la": "\u5783\u62c9\u5587\u8721\u814a\u8fa3\u5566\u524c\u647a\u908b\u65ef\u782c\u760c", "lai": "\u83b1\u6765\u8d56\u5d03\u5f95\u6d9e\u6fd1\u8d49\u7750\u94fc\u765e\u7c41", "lan": "\u84dd\u5a6a\u680f\u62e6\u7bee\u9611\u5170\u6f9c\u8c30\u63fd\u89c8\u61d2\u7f06\u70c2\u6ee5\u5549\u5c9a\u61d4\u6f24\u6984\u6593\u7f71\u9567\u8934", "lang": "\u7405\u6994\u72fc\u5eca\u90ce\u6717\u6d6a\u83a8\u8497\u5577\u9606\u9512\u7a02\u8782", "lao": "\u635e\u52b3\u7262\u8001\u4f6c\u59e5\u916a\u70d9\u6d9d\u5520\u5d02\u6833\u94d1\u94f9\u75e8\u91aa", "le": "\u52d2\u4e50\u808b\u4ec2\u53fb\u561e\u6cd0\u9cd3", "lei": "\u96f7\u956d\u857e\u78ca\u7d2f\u5121\u5792\u64c2\u7c7b\u6cea\u7fb8\u8bd4\u837d\u54a7\u6f2f\u5ad8\u7f27\u6a91\u8012\u9179", "ling": "\u68f1\u51b7\u62ce\u73b2\u83f1\u96f6\u9f84\u94c3\u4f36\u7f9a\u51cc\u7075\u9675\u5cad\u9886\u53e6\u4ee4\u9143\u5844\u82d3\u5464\u56f9\u6ce0\u7eeb\u67c3\u68c2\u74f4\u8046\u86c9\u7fce\u9cae", "leng": "\u695e\u6123", "li": "\u5398\u68a8\u7281\u9ece\u7bf1\u72f8\u79bb\u6f13\u7406\u674e\u91cc\u9ca4\u793c\u8389\u8354\u540f\u6817\u4e3d\u5389\u52b1\u783e\u5386\u5229\u5088\u4f8b\u4fd0\u75e2\u7acb\u7c92\u6ca5\u96b6\u529b\u7483\u54e9\u4fea\u4fda\u90e6\u575c\u82c8\u8385\u84e0\u85dc\u6369\u5456\u5533\u55b1\u7301\u6ea7\u6fa7\u9026\u5a0c\u5ae0\u9a8a\u7f21\u73de\u67a5\u680e\u8f79\u623e\u783a\u8a48\u7f79\u9502\u9e42\u75a0\u75ac\u86ce\u870a\u8821\u7b20\u7be5\u7c9d\u91b4\u8dde\u96f3\u9ca1\u9ce2\u9ee7", "lian": "\u4fe9\u8054\u83b2\u8fde\u9570\u5ec9\u601c\u6d9f\u5e18\u655b\u8138\u94fe\u604b\u70bc\u7ec3\u631b\u8539\u5941\u6f4b\u6fc2\u5a08\u740f\u695d\u6b93\u81c1\u81a6\u88e2\u880a\u9ca2", "liang": "\u7cae\u51c9\u6881\u7cb1\u826f\u4e24\u8f86\u91cf\u667e\u4eae\u8c05\u589a\u690b\u8e09\u9753\u9b49", "liao": "\u64a9\u804a\u50da\u7597\u71ce\u5be5\u8fbd\u6f66\u4e86\u6482\u9563\u5ed6\u6599\u84fc\u5c25\u5639\u7360\u5bee\u7f2d\u948c\u9e69\u8022", "lie": "\u5217\u88c2\u70c8\u52a3\u730e\u51bd\u57d2\u6d0c\u8d94\u8e90\u9b23", "lin": "\u7433\u6797\u78f7\u9716\u4e34\u90bb\u9cde\u6dcb\u51db\u8d41\u541d\u853a\u5d99\u5eea\u9074\u6aa9\u8f9a\u77b5\u7cbc\u8e8f\u9e9f", "liu": "\u6e9c\u7409\u69b4\u786b\u998f\u7559\u5218\u7624\u6d41\u67f3\u516d\u62a1\u507b\u848c\u6cd6\u6d4f\u905b\u9a9d\u7efa\u65d2\u7198\u950d\u954f\u9e68\u938f", "long": "\u9f99\u804b\u5499\u7b3c\u7abf\u9686\u5784\u62e2\u9647\u5f04\u5785\u830f\u6cf7\u73d1\u680a\u80e7\u783b\u7643", "lou": "\u697c\u5a04\u6402\u7bd3\u6f0f\u964b\u55bd\u5d5d\u9542\u7618\u8027\u877c\u9ac5", "lu": "\u82a6\u5362\u9885\u5e90\u7089\u63b3\u5364\u864f\u9c81\u9e93\u788c\u9732\u8def\u8d42\u9e7f\u6f5e\u7984\u5f55\u9646\u622e\u5786\u6445\u64b8\u565c\u6cf8\u6e0c\u6f09\u7490\u680c\u6a79\u8f73\u8f82\u8f98\u6c07\u80ea\u9565\u9e2c\u9e6d\u7c0f\u823b\u9c88", "lv": "\u9a74\u5415\u94dd\u4fa3\u65c5\u5c65\u5c61\u7f15\u8651\u6c2f\u5f8b\u7387\u6ee4\u7eff\u634b\u95fe\u6988\u8182\u7a06\u891b", "luan": "\u5ce6\u5b6a\u6ee6\u5375\u4e71\u683e\u9e3e\u92ae", "lue": "\u63a0\u7565\u950a", "lun": "\u8f6e\u4f26\u4ed1\u6ca6\u7eb6\u8bba\u56f5", "luo": "\u841d\u87ba\u7f57\u903b\u9523\u7ba9\u9aa1\u88f8\u843d\u6d1b\u9a86\u7edc\u502e\u8366\u645e\u7321\u6cfa\u6924\u8136\u9559\u7630\u96d2", "ma": "\u5988\u9ebb\u739b\u7801\u8682\u9a6c\u9a82\u561b\u5417\u551b\u72b8\u5b37\u6769\u9ebd", "mai": "\u57cb\u4e70\u9ea6\u5356\u8fc8\u8109\u52a2\u836c\u54aa\u973e", "man": "\u7792\u9992\u86ee\u6ee1\u8513\u66fc\u6162\u6f2b\u8c29\u5881\u5e54\u7f26\u71b3\u9558\u989f\u87a8\u9cd7\u9794", "mang": "\u8292\u832b\u76f2\u5fd9\u83bd\u9099\u6f2d\u6726\u786d\u87d2", "meng": "\u6c13\u840c\u8499\u6aac\u76df\u9530\u731b\u68a6\u5b5f\u52d0\u750d\u77a2\u61f5\u791e\u867b\u8722\u8813\u824b\u8268\u9efe", "miao": "\u732b\u82d7\u63cf\u7784\u85d0\u79d2\u6e3a\u5e99\u5999\u55b5\u9088\u7f08\u7f2a\u676a\u6dfc\u7707\u9e4b\u8731", "mao": "\u8305\u951a\u6bdb\u77db\u94c6\u536f\u8302\u5192\u5e3d\u8c8c\u8d38\u4f94\u88a4\u52d6\u8306\u5cc1\u7441\u6634\u7266\u8004\u65c4\u61cb\u7780\u86d1\u8765\u87ca\u9ae6", "me": "\u4e48", "mei": "\u73ab\u679a\u6885\u9176\u9709\u7164\u6ca1\u7709\u5a92\u9541\u6bcf\u7f8e\u6627\u5bd0\u59b9\u5a9a\u5776\u8393\u5d4b\u7338\u6d7c\u6e44\u6963\u9545\u9e5b\u8882\u9b45", "men": "\u95e8\u95f7\u4eec\u626a\u739f\u7116\u61d1\u9494", "mi": "\u772f\u919a\u9761\u7cdc\u8ff7\u8c1c\u5f25\u7c73\u79d8\u89c5\u6ccc\u871c\u5bc6\u5e42\u8288\u5196\u8c27\u863c\u5627\u7315\u736f\u6c68\u5b93\u5f2d\u8112\u6549\u7cf8\u7e3b\u9e8b", "mian": "\u68c9\u7720\u7ef5\u5195\u514d\u52c9\u5a29\u7f05\u9762\u6c94\u6e4e\u817c\u7704", "mie": "\u8511\u706d\u54a9\u881b\u7bfe", "min": "\u6c11\u62bf\u76bf\u654f\u60af\u95fd\u82e0\u5cb7\u95f5\u6cef\u73c9", "ming": "\u660e\u879f\u9e23\u94ed\u540d\u547d\u51a5\u8317\u6e9f\u669d\u7791\u9169", "miu": "\u8c2c", "mo": "\u6478\u6479\u8611\u6a21\u819c\u78e8\u6469\u9b54\u62b9\u672b\u83ab\u58a8\u9ed8\u6cab\u6f20\u5bde\u964c\u8c1f\u8309\u84e6\u998d\u5aeb\u9546\u79e3\u763c\u8031\u87c6\u8c8a\u8c98", "mou": "\u8c0b\u725f\u67d0\u53b6\u54de\u5a7a\u7738\u936a", "mu": "\u62c7\u7261\u4ea9\u59c6\u6bcd\u5893\u66ae\u5e55\u52df\u6155\u6728\u76ee\u7766\u7267\u7a46\u4eeb\u82dc\u5452\u6c90\u6bea\u94bc", "na": "\u62ff\u54ea\u5450\u94a0\u90a3\u5a1c\u7eb3\u5185\u637a\u80ad\u954e\u8872\u7bac", "nai": "\u6c16\u4e43\u5976\u8010\u5948\u9f10\u827f\u8418\u67f0", "nan": "\u5357\u7537\u96be\u56ca\u5583\u56e1\u6960\u8169\u877b\u8d67", "nao": "\u6320\u8111\u607c\u95f9\u5b6c\u57b4\u7331\u7459\u7847\u94d9\u86f2", "ne": "\u6dd6\u5462\u8bb7", "nei": "\u9981", "nen": "\u5ae9\u80fd\u6798\u6041", "ni": "\u59ae\u9713\u502a\u6ce5\u5c3c\u62df\u4f60\u533f\u817b\u9006\u6eba\u4f32\u576d\u730a\u6029\u6ee0\u6635\u65ce\u7962\u615d\u7768\u94cc\u9cb5", "nian": "\u852b\u62c8\u5e74\u78be\u64b5\u637b\u5ff5\u5eff\u8f87\u9ecf\u9c87\u9cb6", "niang": "\u5a18\u917f", "niao": "\u9e1f\u5c3f\u8311\u5b32\u8132\u8885", "nie": "\u634f\u8042\u5b7d\u556e\u954a\u954d\u6d85\u4e5c\u9667\u8616\u55eb\u8080\u989e\u81ec\u8e51", "nin": "\u60a8\u67e0", "ning": "\u72de\u51dd\u5b81\u62e7\u6cde\u4f5e\u84e5\u549b\u752f\u804d", "niu": "\u725b\u626d\u94ae\u7ebd\u72c3\u5ff8\u599e\u86b4", "nong": "\u8113\u6d53\u519c\u4fac", "nu": "\u5974\u52aa\u6012\u5476\u5e11\u5f29\u80ec\u5b65\u9a7d", "nv": "\u5973\u6067\u9495\u8844", "nuan": "\u6696", "nuenue": "\u8650", "nue": "\u759f\u8c11", "nuo": "\u632a\u61e6\u7cef\u8bfa\u50a9\u6426\u558f\u9518", "ou": "\u54e6\u6b27\u9e25\u6bb4\u85d5\u5455\u5076\u6ca4\u6004\u74ef\u8026", "pa": "\u556a\u8db4\u722c\u5e15\u6015\u7436\u8469\u7b62", "pai": "\u62cd\u6392\u724c\u5f98\u6e43\u6d3e\u4ff3\u848e", "pan": "\u6500\u6f58\u76d8\u78d0\u76fc\u7554\u5224\u53db\u723f\u6cee\u88a2\u897b\u87e0\u8e52", "pang": "\u4e53\u5e9e\u65c1\u802a\u80d6\u6ec2\u9004", "pao": "\u629b\u5486\u5228\u70ae\u888d\u8dd1\u6ce1\u530f\u72cd\u5e96\u812c\u75b1", "pei": "\u5478\u80da\u57f9\u88f4\u8d54\u966a\u914d\u4f69\u6c9b\u638a\u8f94\u5e14\u6de0\u65c6\u952b\u9185\u9708", "pen": "\u55b7\u76c6\u6e53", "peng": "\u7830\u62a8\u70f9\u6f8e\u5f6d\u84ec\u68da\u787c\u7bf7\u81a8\u670b\u9e4f\u6367\u78b0\u576f\u580b\u562d\u6026\u87db", "pi": "\u7812\u9739\u6279\u62ab\u5288\u7435\u6bd7\u5564\u813e\u75b2\u76ae\u5339\u75de\u50fb\u5c41\u8b6c\u4e15\u9674\u90b3\u90eb\u572e\u9f19\u64d7\u567c\u5e80\u5ab2\u7eb0\u6787\u7513\u7765\u7f74\u94cd\u75e6\u7656\u758b\u868d\u8c94", "pian": "\u7bc7\u504f\u7247\u9a97\u8c1d\u9a88\u728f\u80fc\u890a\u7fe9\u8e41", "piao": "\u98d8\u6f02\u74e2\u7968\u527d\u560c\u5ad6\u7f25\u6b8d\u779f\u87b5", "pie": "\u6487\u77a5\u4e3f\u82e4\u6c15", "pin": "\u62fc\u9891\u8d2b\u54c1\u8058\u62da\u59d8\u5ad4\u6980\u725d\u98a6", "ping": "\u4e52\u576a\u82f9\u840d\u5e73\u51ed\u74f6\u8bc4\u5c4f\u4fdc\u5a09\u67b0\u9c86", "po": "\u5761\u6cfc\u9887\u5a46\u7834\u9b44\u8feb\u7c95\u53f5\u9131\u6ea5\u73c0\u948b\u94b7\u76a4\u7b38", "pou": "\u5256\u88d2\u8e23", "pu": "\u6251\u94fa\u4ec6\u8386\u8461\u83e9\u84b2\u57d4\u6734\u5703\u666e\u6d66\u8c31\u66dd\u7011\u530d\u5657\u6fee\u749e\u6c06\u9564\u9568\u8e7c", "qi": "\u671f\u6b3a\u6816\u621a\u59bb\u4e03\u51c4\u6f06\u67d2\u6c8f\u5176\u68cb\u5947\u6b67\u7566\u5d0e\u8110\u9f50\u65d7\u7948\u7941\u9a91\u8d77\u5c82\u4e5e\u4f01\u542f\u5951\u780c\u5668\u6c14\u8fc4\u5f03\u6c7d\u6ce3\u8bab\u4e9f\u4e93\u573b\u8291\u840b\u847a\u5601\u5c7a\u5c90\u6c54\u6dc7\u9a90\u7eee\u742a\u7426\u675e\u6864\u69ed\u6b39\u797a\u61a9\u789b\u86f4\u871e\u7da6\u7dae\u8dbf\u8e4a\u9ccd\u9e92", "qia": "\u6390\u6070\u6d3d\u845c", "qian": "\u7275\u6266\u948e\u94c5\u5343\u8fc1\u7b7e\u4edf\u8c26\u4e7e\u9ed4\u94b1\u94b3\u524d\u6f5c\u9063\u6d45\u8c34\u5811\u5d4c\u6b20\u6b49\u4f65\u9621\u828a\u82a1\u8368\u63ae\u5c8d\u60ad\u614a\u9a9e\u6434\u8930\u7f31\u6920\u80b7\u6106\u94a4\u8654\u7b9d", "qiang": "\u67aa\u545b\u8154\u7f8c\u5899\u8537\u5f3a\u62a2\u5af1\u6a2f\u6217\u709d\u9516\u9535\u956a\u8941\u8723\u7f9f\u8deb\u8dc4", "qiao": "\u6a47\u9539\u6572\u6084\u6865\u77a7\u4e54\u4fa8\u5de7\u9798\u64ac\u7fd8\u5ced\u4fcf\u7a8d\u5281\u8bee\u8c2f\u835e\u6100\u6194\u7f32\u6a35\u6bf3\u7857\u8df7\u9792", "qie": "\u5207\u8304\u4e14\u602f\u7a83\u90c4\u553c\u60ec\u59be\u6308\u9532\u7ba7", "qin": "\u94a6\u4fb5\u4eb2\u79e6\u7434\u52e4\u82b9\u64d2\u79bd\u5bdd\u6c81\u82a9\u84c1\u8572\u63ff\u5423\u55ea\u5659\u6eb1\u6a8e\u8793\u887e", "qing": "\u9752\u8f7b\u6c22\u503e\u537f\u6e05\u64ce\u6674\u6c30\u60c5\u9877\u8bf7\u5e86\u5029\u82d8\u570a\u6aa0\u78ec\u873b\u7f44\u7b90\u8b26\u9cad\u9ee5", "qiong": "\u743c\u7a77\u909b\u8315\u7a79\u7b47\u928e", "qiu": "\u79cb\u4e18\u90b1\u7403\u6c42\u56da\u914b\u6cc5\u4fc5\u6c3d\u5def\u827d\u72b0\u6e6b\u9011\u9052\u6978\u8d47\u9e20\u866c\u86af\u8764\u88d8\u7cd7\u9cc5\u9f3d", "qu": "\u8d8b\u533a\u86c6\u66f2\u8eaf\u5c48\u9a71\u6e20\u53d6\u5a36\u9f8b\u8da3\u53bb\u8bce\u52ac\u8556\u8627\u5c96\u8862\u9612\u74a9\u89d1\u6c0d\u795b\u78f2\u766f\u86d0\u883c\u9eb4\u77bf\u9ee2", "quan": "\u5708\u98a7\u6743\u919b\u6cc9\u5168\u75ca\u62f3\u72ac\u5238\u529d\u8be0\u8343\u737e\u609b\u7efb\u8f81\u754e\u94e8\u8737\u7b4c\u9b08", "que": "\u7f3a\u7094\u7638\u5374\u9e4a\u69b7\u786e\u96c0\u9619\u60ab", "qun": "\u88d9\u7fa4\u9021", "ran": "\u7136\u71c3\u5189\u67d3\u82d2\u9aef", "rang": "\u74e4\u58e4\u6518\u56b7\u8ba9\u79b3\u7a70", "rao": "\u9976\u6270\u7ed5\u835b\u5a06\u6861", "ruo": "\u60f9\u82e5\u5f31", "re": "\u70ed\u504c", "ren": "\u58ec\u4ec1\u4eba\u5fcd\u97e7\u4efb\u8ba4\u5203\u598a\u7eab\u4ede\u834f\u845a\u996a\u8f6b\u7a14\u887d", "reng": "\u6254\u4ecd", "ri": "\u65e5", "rong": "\u620e\u8338\u84c9\u8363\u878d\u7194\u6eb6\u5bb9\u7ed2\u5197\u5d58\u72e8\u7f1b\u6995\u877e", "rou": "\u63c9\u67d4\u8089\u7cc5\u8e42\u97a3", "ru": "\u8339\u8815\u5112\u5b7a\u5982\u8fb1\u4e73\u6c5d\u5165\u8925\u84d0\u85b7\u5685\u6d33\u6ebd\u6fe1\u94f7\u8966\u98a5", "ruan": "\u8f6f\u962e\u670a", "rui": "\u854a\u745e\u9510\u82ae\u8564\u777f\u868b", "run": "\u95f0\u6da6", "sa": "\u6492\u6d12\u8428\u5345\u4ee8\u6332\u98d2", "sai": "\u816e\u9cc3\u585e\u8d5b\u567b", "san": "\u4e09\u53c1\u4f1e\u6563\u5f61\u9993\u6c35\u6bf5\u7cc1\u9730", "sang": "\u6851\u55d3\u4e27\u6421\u78c9\u98a1", "sao": "\u6414\u9a9a\u626b\u5ac2\u57fd\u81ca\u7619\u9ccb", "se": "\u745f\u8272\u6da9\u556c\u94e9\u94ef\u7a51", "sen": "\u68ee", "seng": "\u50e7", "sha": "\u838e\u7802\u6740\u5239\u6c99\u7eb1\u50bb\u5565\u715e\u810e\u6b43\u75e7\u88df\u970e\u9ca8", "shai": "\u7b5b\u6652\u917e", "shan": "\u73ca\u82eb\u6749\u5c71\u5220\u717d\u886b\u95ea\u9655\u64c5\u8d61\u81b3\u5584\u6c55\u6247\u7f2e\u5261\u8baa\u912f\u57cf\u829f\u6f78\u59d7\u9a9f\u81bb\u9490\u759d\u87ee\u8222\u8dda\u9cdd", "shang": "\u5892\u4f24\u5546\u8d4f\u664c\u4e0a\u5c1a\u88f3\u57a7\u7ef1\u6b87\u71b5\u89de", "shao": "\u68a2\u634e\u7a0d\u70e7\u828d\u52fa\u97f6\u5c11\u54e8\u90b5\u7ecd\u52ad\u82d5\u6f72\u86f8\u7b24\u7b72\u8244", "she": "\u5962\u8d4a\u86c7\u820c\u820d\u8d66\u6444\u5c04\u6151\u6d89\u793e\u8bbe\u538d\u4f58\u731e\u7572\u9e9d", "shen": "\u7837\u7533\u547b\u4f38\u8eab\u6df1\u5a20\u7ec5\u795e\u6c88\u5ba1\u5a76\u751a\u80be\u614e\u6e17\u8bdc\u8c02\u5432\u54c2\u6e16\u6939\u77e7\u8703", "sheng": "\u58f0\u751f\u7525\u7272\u5347\u7ef3\u7701\u76db\u5269\u80dc\u5723\u4e1e\u6e11\u5ab5\u771a\u7b19", "shi": "\u5e08\u5931\u72ee\u65bd\u6e7f\u8bd7\u5c38\u8671\u5341\u77f3\u62fe\u65f6\u4ec0\u98df\u8680\u5b9e\u8bc6\u53f2\u77e2\u4f7f\u5c4e\u9a76\u59cb\u5f0f\u793a\u58eb\u4e16\u67ff\u4e8b\u62ed\u8a93\u901d\u52bf\u662f\u55dc\u566c\u9002\u4ed5\u4f8d\u91ca\u9970\u6c0f\u5e02\u6043\u5ba4\u89c6\u8bd5\u8c25\u57d8\u83b3\u84cd\u5f11\u5511\u9963\u8f7c\u8006\u8d33\u70bb\u793b\u94c8\u94ca\u87ab\u8210\u7b6e\u8c55\u9ca5\u9cba", "shou": "\u6536\u624b\u9996\u5b88\u5bff\u6388\u552e\u53d7\u7626\u517d\u624c\u72e9\u7ef6\u824f", "shu": "\u852c\u67a2\u68b3\u6b8a\u6292\u8f93\u53d4\u8212\u6dd1\u758f\u4e66\u8d4e\u5b70\u719f\u85af\u6691\u66d9\u7f72\u8700\u9ecd\u9f20\u5c5e\u672f\u8ff0\u6811\u675f\u620d\u7ad6\u5885\u5eb6\u6570\u6f31\u6055\u500f\u587e\u83fd\u5fc4\u6cad\u6d91\u6f8d\u59dd\u7ebe\u6bf9\u8167\u6bb3\u956f\u79eb\u9e6c", "shua": "\u5237\u800d\u5530\u6dae", "shuai": "\u6454\u8870\u7529\u5e05\u87c0", "shuan": "\u6813\u62f4\u95e9", "shuang": "\u971c\u53cc\u723d\u5b40", "shui": "\u8c01\u6c34\u7761\u7a0e", "shun": "\u542e\u77ac\u987a\u821c\u6042", "shuo": "\u8bf4\u7855\u6714\u70c1\u84b4\u6420\u55cd\u6fef\u5981\u69ca\u94c4", "si": "\u65af\u6495\u5636\u601d\u79c1\u53f8\u4e1d\u6b7b\u8086\u5bfa\u55e3\u56db\u4f3a\u4f3c\u9972\u5df3\u53ae\u4fdf\u5155\u83e5\u549d\u6c5c\u6cd7\u6f8c\u59d2\u9a77\u7f0c\u7940\u7960\u9536\u9e36\u801c\u86f3\u7b25", "song": "\u677e\u8038\u6002\u9882\u9001\u5b8b\u8bbc\u8bf5\u51c7\u83d8\u5d27\u5d69\u5fea\u609a\u6dde\u7ae6", "sou": "\u641c\u8258\u64de\u55fd\u53df\u55d6\u55fe\u998a\u6eb2\u98d5\u778d\u953c\u878b", "su": "\u82cf\u9165\u4fd7\u7d20\u901f\u7c9f\u50f3\u5851\u6eaf\u5bbf\u8bc9\u8083\u5919\u8c21\u850c\u55c9\u612b\u7c0c\u89eb\u7a23", "suan": "\u9178\u849c\u7b97", "sui": "\u867d\u968b\u968f\u7ee5\u9ad3\u788e\u5c81\u7a57\u9042\u96a7\u795f\u84d1\u51ab\u8c07\u6fc9\u9083\u71e7\u772d\u7762", "sun": "\u5b59\u635f\u7b0b\u836a\u72f2\u98e7\u69ab\u8de3\u96bc", "suo": "\u68ad\u5506\u7f29\u7410\u7d22\u9501\u6240\u5522\u55e6\u5a11\u686b\u7743\u7fa7", "ta": "\u584c\u4ed6\u5b83\u5979\u5854\u736d\u631e\u8e4b\u8e0f\u95fc\u6ebb\u9062\u69bb\u6c93", "tai": "\u80ce\u82d4\u62ac\u53f0\u6cf0\u915e\u592a\u6001\u6c70\u90b0\u85b9\u80bd\u70b1\u949b\u8dc6\u9c90", "tan": "\u574d\u644a\u8d2a\u762b\u6ee9\u575b\u6a80\u75f0\u6f6d\u8c2d\u8c08\u5766\u6bef\u8892\u78b3\u63a2\u53f9\u70ad\u90ef\u8548\u6619\u94bd\u952c\u8983", "tang": "\u6c64\u5858\u642a\u5802\u68e0\u819b\u5510\u7cd6\u50a5\u9967\u6e8f\u746d\u94f4\u9557\u8025\u8797\u87b3\u7fb0\u91a3", "thang": "\u5018\u8eba\u6dcc", "theng": "\u8d9f\u70eb", "tao": "\u638f\u6d9b\u6ed4\u7ee6\u8404\u6843\u9003\u6dd8\u9676\u8ba8\u5957\u6311\u9f17\u5555\u97ec\u9955", "te": "\u7279", "teng": "\u85e4\u817e\u75bc\u8a8a\u6ed5", "ti": "\u68af\u5254\u8e22\u9511\u63d0\u9898\u8e44\u557c\u4f53\u66ff\u568f\u60d5\u6d95\u5243\u5c49\u8351\u608c\u9016\u7ee8\u7f07\u9e48\u88fc\u918d", "tian": "\u5929\u6dfb\u586b\u7530\u751c\u606c\u8214\u8146\u63ad\u5fdd\u9617\u6b84\u754b\u94bf\u86ba", "tiao": "\u6761\u8fe2\u773a\u8df3\u4f7b\u7967\u94eb\u7a95\u9f86\u9ca6", "tie": "\u8d34\u94c1\u5e16\u841c\u992e", "ting": "\u5385\u542c\u70c3\u6c40\u5ef7\u505c\u4ead\u5ead\u633a\u8247\u839b\u8476\u5a77\u6883\u8713\u9706", "tong": "\u901a\u6850\u916e\u77b3\u540c\u94dc\u5f64\u7ae5\u6876\u6345\u7b52\u7edf\u75db\u4f5f\u50ee\u4edd\u833c\u55f5\u6078\u6f7c\u783c", "tou": "\u5077\u6295\u5934\u900f\u4ea0", "tu": "\u51f8\u79c3\u7a81\u56fe\u5f92\u9014\u6d82\u5c60\u571f\u5410\u5154\u580d\u837c\u83df\u948d\u9174", "tuan": "\u6e4d\u56e2\u7583", "tui": "\u63a8\u9893\u817f\u8715\u892a\u9000\u5fd2\u717a", "tun": "\u541e\u5c6f\u81c0\u9968\u66be\u8c5a\u7a80", "tuo": "\u62d6\u6258\u8131\u9e35\u9640\u9a6e\u9a7c\u692d\u59a5\u62d3\u553e\u4e47\u4f57\u5768\u5eb9\u6cb1\u67dd\u7823\u7ba8\u8204\u8dce\u9f0d", "wa": "\u6316\u54c7\u86d9\u6d3c\u5a03\u74e6\u889c\u4f64\u5a32\u817d", "wai": "\u6b6a\u5916", "wan": "\u8c4c\u5f2f\u6e7e\u73a9\u987d\u4e38\u70f7\u5b8c\u7897\u633d\u665a\u7696\u60cb\u5b9b\u5a49\u4e07\u8155\u525c\u8284\u82cb\u83c0\u7ea8\u7efe\u742c\u8118\u7579\u873f\u7ba2", "wang": "\u6c6a\u738b\u4ea1\u6789\u7f51\u5f80\u65fa\u671b\u5fd8\u5984\u7f54\u5c22\u60d8\u8f8b\u9b4d", "wei": "\u5a01\u5dcd\u5fae\u5371\u97e6\u8fdd\u6845\u56f4\u552f\u60df\u4e3a\u6f4d\u7ef4\u82c7\u840e\u59d4\u4f1f\u4f2a\u5c3e\u7eac\u672a\u851a\u5473\u754f\u80c3\u5582\u9b4f\u4f4d\u6e2d\u8c13\u5c09\u6170\u536b\u502d\u504e\u8bff\u9688\u8473\u8587\u5e0f\u5e37\u5d34\u5d6c\u7325\u732c\u95f1\u6ca9\u6d27\u6da0\u9036\u5a13\u73ae\u97ea\u8ece\u709c\u7168\u71a8\u75ff\u8249\u9c94", "wen": "\u761f\u6e29\u868a\u6587\u95fb\u7eb9\u543b\u7a33\u7d0a\u95ee\u520e\u6120\u960c\u6c76\u74ba\u97eb\u6b81\u96ef", "weng": "\u55e1\u7fc1\u74ee\u84ca\u8579", "wo": "\u631d\u8717\u6da1\u7a9d\u6211\u65a1\u5367\u63e1\u6c83\u83b4\u5e44\u6e25\u674c\u809f\u9f8c", "wu": "\u5deb\u545c\u94a8\u4e4c\u6c61\u8bec\u5c4b\u65e0\u829c\u68a7\u543e\u5434\u6bcb\u6b66\u4e94\u6342\u5348\u821e\u4f0d\u4fae\u575e\u620a\u96fe\u6664\u7269\u52ff\u52a1\u609f\u8bef\u5140\u4ef5\u9622\u90ac\u572c\u82b4\u5e91\u6003\u5fe4\u6d6f\u5be4\u8fd5\u59a9\u9a9b\u727e\u7110\u9e49\u9e5c\u8708\u92c8\u9f2f", "xi": "\u6614\u7199\u6790\u897f\u7852\u77fd\u6670\u563b\u5438\u9521\u727a\u7a00\u606f\u5e0c\u6089\u819d\u5915\u60dc\u7184\u70ef\u6eaa\u6c50\u7280\u6a84\u88ad\u5e2d\u4e60\u5ab3\u559c\u94e3\u6d17\u7cfb\u9699\u620f\u7ec6\u50d6\u516e\u96b0\u90d7\u831c\u8478\u84f0\u595a\u550f\u5f99\u9969\u960b\u6d60\u6dc5\u5c63\u5b09\u73ba\u6a28\u66e6\u89cb\u6b37\u71b9\u798a\u79a7\u94b8\u7699\u7a78\u8725\u87cb\u823e\u7fb2\u7c9e\u7fd5\u91af\u9f37", "xia": "\u778e\u867e\u5323\u971e\u8f96\u6687\u5ce1\u4fa0\u72ed\u4e0b\u53a6\u590f\u5413\u6380\u846d\u55c4\u72ce\u9050\u7455\u7856\u7615\u7f45\u9ee0", "xian": "\u9528\u5148\u4ed9\u9c9c\u7ea4\u54b8\u8d24\u8854\u8237\u95f2\u6d8e\u5f26\u5acc\u663e\u9669\u73b0\u732e\u53bf\u817a\u9985\u7fa1\u5baa\u9677\u9650\u7ebf\u51bc\u85d3\u5c98\u7303\u66b9\u5a34\u6c19\u7946\u9e47\u75eb\u86ac\u7b45\u7c7c\u9170\u8df9", "xiang": "\u76f8\u53a2\u9576\u9999\u7bb1\u8944\u6e58\u4e61\u7fd4\u7965\u8be6\u60f3\u54cd\u4eab\u9879\u5df7\u6a61\u50cf\u5411\u8c61\u8297\u8459\u9977\u5ea0\u9aa7\u7f03\u87d3\u9c9e\u98e8", "xiao": "\u8427\u785d\u9704\u524a\u54ee\u56a3\u9500\u6d88\u5bb5\u6dc6\u6653\u5c0f\u5b5d\u6821\u8096\u5578\u7b11\u6548\u54d3\u54bb\u5d24\u6f47\u900d\u9a81\u7ee1\u67ad\u67b5\u7b71\u7bab\u9b48", "xie": "\u6954\u4e9b\u6b47\u874e\u978b\u534f\u631f\u643a\u90aa\u659c\u80c1\u8c10\u5199\u68b0\u5378\u87f9\u61c8\u6cc4\u6cfb\u8c22\u5c51\u5055\u4eb5\u52f0\u71ee\u85a4\u64b7\u5ee8\u7023\u9082\u7ec1\u7f2c\u69ad\u698d\u6b59\u8e9e", "xin": "\u85aa\u82af\u950c\u6b23\u8f9b\u65b0\u5ffb\u5fc3\u4fe1\u8845\u56df\u99a8\u8398\u6b46\u94fd\u946b", "xing": "\u661f\u8165\u7329\u60fa\u5174\u5211\u578b\u5f62\u90a2\u884c\u9192\u5e78\u674f\u6027\u59d3\u9649\u8347\u8365\u64e4\u60bb\u784e", "xiong": "\u5144\u51f6\u80f8\u5308\u6c79\u96c4\u718a\u828e", "xiu": "\u4f11\u4fee\u7f9e\u673d\u55c5\u9508\u79c0\u8896\u7ee3\u83a0\u5cab\u9990\u5ea5\u9e3a\u8c85\u9af9", "xu": "\u589f\u620c\u9700\u865a\u5618\u987b\u5f90\u8bb8\u84c4\u9157\u53d9\u65ed\u5e8f\u755c\u6064\u7d6e\u5a7f\u7eea\u7eed\u8bb4\u8be9\u5729\u84ff\u6035\u6d2b\u6e86\u987c\u6829\u7166\u7809\u76f1\u80e5\u7cc8\u9191", "xuan": "\u8f69\u55a7\u5ba3\u60ac\u65cb\u7384\u9009\u7663\u7729\u7eda\u5107\u8c16\u8431\u63ce\u9994\u6ceb\u6d35\u6e32\u6f29\u7487\u6966\u6684\u70ab\u714a\u78b9\u94c9\u955f\u75c3", "xue": "\u9774\u859b\u5b66\u7a74\u96ea\u8840\u5671\u6cf6\u9cd5", "xun": "\u52cb\u718f\u5faa\u65ec\u8be2\u5bfb\u9a6f\u5de1\u6b89\u6c5b\u8bad\u8baf\u900a\u8fc5\u5dfd\u57d9\u8340\u85b0\u5ccb\u5f87\u6d54\u66db\u7aa8\u91ba\u9c9f", "ya": "\u538b\u62bc\u9e26\u9e2d\u5440\u4e2b\u82bd\u7259\u869c\u5d16\u8859\u6daf\u96c5\u54d1\u4e9a\u8bb6\u4f22\u63e0\u5416\u5c88\u8fd3\u5a05\u740a\u6860\u6c29\u7811\u775a\u75d6", "yan": "\u7109\u54bd\u9609\u70df\u6df9\u76d0\u4e25\u7814\u8712\u5ca9\u5ef6\u8a00\u989c\u960e\u708e\u6cbf\u5944\u63a9\u773c\u884d\u6f14\u8273\u5830\u71d5\u538c\u781a\u96c1\u5501\u5f66\u7130\u5bb4\u8c1a\u9a8c\u53a3\u9765\u8d5d\u4fe8\u5043\u5156\u8ba0\u8c33\u90fe\u9122\u82ab\u83f8\u5d26\u6079\u95eb\u960f\u6d07\u6e6e\u6edf\u598d\u5ae3\u7430\u664f\u80ed\u814c\u7131\u7f68\u7b75\u917d\u9b47\u990d\u9f39", "yang": "\u6b83\u592e\u9e2f\u79e7\u6768\u626c\u4f6f\u75a1\u7f8a\u6d0b\u9633\u6c27\u4ef0\u75d2\u517b\u6837\u6f3e\u5f89\u600f\u6cf1\u7080\u70ca\u6059\u86d8\u9785", "yao": "\u9080\u8170\u5996\u7476\u6447\u5c27\u9065\u7a91\u8c23\u59da\u54ac\u8200\u836f\u8981\u8000\u592d\u723b\u5406\u5d3e\u5fad\u7039\u5e7a\u73e7\u6773\u66dc\u80b4\u9e5e\u7a88\u7e47\u9cd0", "ye": "\u6930\u564e\u8036\u7237\u91ce\u51b6\u4e5f\u9875\u6396\u4e1a\u53f6\u66f3\u814b\u591c\u6db2\u8c12\u90ba\u63f6\u9980\u6654\u70e8\u94d8", "yi": "\u4e00\u58f9\u533b\u63d6\u94f1\u4f9d\u4f0a\u8863\u9890\u5937\u9057\u79fb\u4eea\u80f0\u7591\u6c82\u5b9c\u59e8\u5f5d\u6905\u8681\u501a\u5df2\u4e59\u77e3\u4ee5\u827a\u6291\u6613\u9091\u5c79\u4ebf\u5f79\u81c6\u9038\u8084\u75ab\u4ea6\u88d4\u610f\u6bc5\u5fc6\u4e49\u76ca\u6ea2\u8be3\u8bae\u8c0a\u8bd1\u5f02\u7ffc\u7fcc\u7ece\u5208\u5293\u4f7e\u8bd2\u572a\u572f\u57f8\u61ff\u82e1\u858f\u5f08\u5955\u6339\u5f0b\u5453\u54a6\u54bf\u566b\u5cc4\u5db7\u7317\u9974\u603f\u6021\u6092\u6f2a\u8fe4\u9a7f\u7f22\u6baa\u8d3b\u65d6\u71a0\u9487\u9552\u9571\u75cd\u7617\u7654\u7fca\u8864\u8734\u8223\u7fbf\u7ff3\u914f\u9edf", "yin": "\u8335\u836b\u56e0\u6bb7\u97f3\u9634\u59fb\u541f\u94f6\u6deb\u5bc5\u996e\u5c39\u5f15\u9690\u5370\u80e4\u911e\u5819\u831a\u5591\u72fa\u5924\u6c24\u94df\u763e\u8693\u972a\u9f88", "ying": "\u82f1\u6a31\u5a74\u9e70\u5e94\u7f28\u83b9\u8424\u8425\u8367\u8747\u8fce\u8d62\u76c8\u5f71\u9896\u786c\u6620\u5b34\u90e2\u8314\u83ba\u8426\u6484\u5624\u81ba\u6ee2\u6f46\u701b\u745b\u748e\u6979\u9e66\u763f\u988d\u7f42", "yo": "\u54df\u5537", "yong": "\u62e5\u4f63\u81c3\u75c8\u5eb8\u96cd\u8e0a\u86f9\u548f\u6cf3\u6d8c\u6c38\u607f\u52c7\u7528\u4fd1\u58c5\u5889\u6175\u9095\u955b\u752c\u9cd9\u9954", "you": "\u5e7d\u4f18\u60a0\u5fe7\u5c24\u7531\u90ae\u94c0\u72b9\u6cb9\u6e38\u9149\u6709\u53cb\u53f3\u4f51\u91c9\u8bf1\u53c8\u5e7c\u5363\u6538\u4f91\u83b8\u5466\u56ff\u5ba5\u67da\u7337\u7256\u94d5\u75a3\u8763\u9c7f\u9edd\u9f2c", "yu": "\u8fc2\u6de4\u4e8e\u76c2\u6986\u865e\u611a\u8206\u4f59\u4fde\u903e\u9c7c\u6109\u6e1d\u6e14\u9685\u4e88\u5a31\u96e8\u4e0e\u5c7f\u79b9\u5b87\u8bed\u7fbd\u7389\u57df\u828b\u90c1\u5401\u9047\u55bb\u5cea\u5fa1\u6108\u6b32\u72f1\u80b2\u8a89\u6d74\u5bd3\u88d5\u9884\u8c6b\u9a6d\u79ba\u6bd3\u4f1b\u4fe3\u8c00\u8c15\u8438\u84e3\u63c4\u5581\u5704\u5709\u5d5b\u72f3\u996b\u5ebe\u9608\u59aa\u59a4\u7ea1\u745c\u6631\u89ce\u8174\u6b24\u65bc\u715c\u71e0\u807f\u94b0\u9e46\u7610\u7600\u7ab3\u8753\u7afd\u8201\u96e9\u9f89", "yuan": "\u9e33\u6e0a\u51a4\u5143\u57a3\u8881\u539f\u63f4\u8f95\u56ed\u5458\u5706\u733f\u6e90\u7f18\u8fdc\u82d1\u613f\u6028\u9662\u586c\u6c85\u5a9b\u7457\u6a7c\u7230\u7722\u9e22\u8788\u9f0b", "yue": "\u66f0\u7ea6\u8d8a\u8dc3\u94a5\u5cb3\u7ca4\u6708\u60a6\u9605\u9fa0\u6a3e\u5216\u94ba", "yun": "\u8018\u4e91\u90e7\u5300\u9668\u5141\u8fd0\u8574\u915d\u6655\u97f5\u5b55\u90d3\u82b8\u72c1\u607d\u7ead\u6b92\u6600\u6c32", "za": "\u531d\u7838\u6742\u62f6\u5482", "zai": "\u683d\u54c9\u707e\u5bb0\u8f7d\u518d\u5728\u54b1\u5d3d\u753e", "zan": "\u6512\u6682\u8d5e\u74d2\u661d\u7c2a\u7ccc\u8db1\u933e", "zang": "\u8d43\u810f\u846c\u5958\u6215\u81e7", "zao": "\u906d\u7cdf\u51ff\u85fb\u67a3\u65e9\u6fa1\u86a4\u8e81\u566a\u9020\u7682\u7076\u71e5\u5523\u7f2b", "ze": "\u8d23\u62e9\u5219\u6cfd\u4ec4\u8d5c\u5567\u8fee\u6603\u7b2e\u7ba6\u8234", "zei": "\u8d3c", "zen": "\u600e\u8c2e", "zeng": "\u589e\u618e\u66fe\u8d60\u7f2f\u7511\u7f7e\u9503", "zha": "\u624e\u55b3\u6e23\u672d\u8f67\u94e1\u95f8\u7728\u6805\u69a8\u548b\u4e4d\u70b8\u8bc8\u63f8\u5412\u54a4\u54f3\u600d\u781f\u75c4\u86b1\u9f44", "zhai": "\u6458\u658b\u5b85\u7a84\u503a\u5be8\u7826", "zhan": "\u77bb\u6be1\u8a79\u7c98\u6cbe\u76cf\u65a9\u8f97\u5d2d\u5c55\u8638\u6808\u5360\u6218\u7ad9\u6e5b\u7efd\u8c35\u640c\u65c3", "zhang": "\u6a1f\u7ae0\u5f70\u6f33\u5f20\u638c\u6da8\u6756\u4e08\u5e10\u8d26\u4ed7\u80c0\u7634\u969c\u4ec9\u9123\u5e5b\u5d82\u7350\u5adc\u748b\u87d1", "zhao": "\u62db\u662d\u627e\u6cbc\u8d75\u7167\u7f69\u5146\u8087\u53ec\u722a\u8bcf\u68f9\u948a\u7b0a", "zhe": "\u906e\u6298\u54f2\u86f0\u8f99\u8005\u9517\u8517\u8fd9\u6d59\u8c2a\u966c\u67d8\u8f84\u78d4\u9e67\u891a\u8707\u8d6d", "zhen": "\u73cd\u659f\u771f\u7504\u7827\u81fb\u8d1e\u9488\u4fa6\u6795\u75b9\u8bca\u9707\u632f\u9547\u9635\u7f1c\u6862\u699b\u8f78\u8d48\u80d7\u6715\u796f\u755b\u9e29", "zheng": "\u84b8\u6323\u7741\u5f81\u72f0\u4e89\u6014\u6574\u62ef\u6b63\u653f\u5e27\u75c7\u90d1\u8bc1\u8be4\u5ce5\u94b2\u94ee\u7b5d", "zhi": "\u829d\u679d\u652f\u5431\u8718\u77e5\u80a2\u8102\u6c41\u4e4b\u7ec7\u804c\u76f4\u690d\u6b96\u6267\u503c\u4f84\u5740\u6307\u6b62\u8dbe\u53ea\u65e8\u7eb8\u5fd7\u631a\u63b7\u81f3\u81f4\u7f6e\u5e1c\u5cd9\u5236\u667a\u79e9\u7a1a\u8d28\u7099\u75d4\u6ede\u6cbb\u7a92\u536e\u965f\u90c5\u57f4\u82b7\u646d\u5e19\u5fee\u5f58\u54ab\u9a98\u6809\u67b3\u6800\u684e\u8f75\u8f7e\u6534\u8d3d\u81a3\u7949\u7957\u9ef9\u96c9\u9e37\u75e3\u86ed\u7d77\u916f\u8dd6\u8e2c\u8e2f\u8c78\u89ef", "zhong": "\u4e2d\u76c5\u5fe0\u949f\u8877\u7ec8\u79cd\u80bf\u91cd\u4ef2\u4f17\u51a2\u953a\u87bd\u8202\u822f\u8e35", "zhou": "\u821f\u5468\u5dde\u6d32\u8bcc\u7ca5\u8f74\u8098\u5e1a\u5492\u76b1\u5b99\u663c\u9aa4\u5544\u7740\u501c\u8bf9\u836e\u9b3b\u7ea3\u80c4\u78a1\u7c40\u8233\u914e\u9cb7", "zhu": "\u73e0\u682a\u86db\u6731\u732a\u8bf8\u8bdb\u9010\u7af9\u70db\u716e\u62c4\u77a9\u5631\u4e3b\u8457\u67f1\u52a9\u86c0\u8d2e\u94f8\u7b51\u4f4f\u6ce8\u795d\u9a7b\u4f2b\u4f8f\u90be\u82ce\u8331\u6d19\u6e1a\u6f74\u9a7a\u677c\u69e0\u6a65\u70b7\u94e2\u75b0\u7603\u86b0\u7afa\u7bb8\u7fe5\u8e85\u9e88", "zhua": "\u6293", "zhuai": "\u62fd", "zhuan": "\u4e13\u7816\u8f6c\u64b0\u8d5a\u7bc6\u629f\u556d\u989b", "zhuang": "\u6869\u5e84\u88c5\u5986\u649e\u58ee\u72b6\u4e2c", "zhui": "\u690e\u9525\u8ffd\u8d58\u5760\u7f00\u8411\u9a93\u7f12", "zhun": "\u8c06\u51c6", "zhuo": "\u6349\u62d9\u5353\u684c\u7422\u8301\u914c\u707c\u6d4a\u502c\u8bfc\u5ef4\u855e\u64e2\u555c\u6d5e\u6dbf\u6753\u712f\u799a\u65ab", "zi": "\u5179\u54a8\u8d44\u59ff\u6ecb\u6dc4\u5b5c\u7d2b\u4ed4\u7c7d\u6ed3\u5b50\u81ea\u6e0d\u5b57\u8c18\u5d6b\u59ca\u5b73\u7f01\u6893\u8f8e\u8d40\u6063\u7726\u9531\u79ed\u8014\u7b2b\u7ca2\u89dc\u8a3e\u9cbb\u9aed", "zong": "\u9b03\u68d5\u8e2a\u5b97\u7efc\u603b\u7eb5\u8159\u7cbd", "zou": "\u90b9\u8d70\u594f\u63cd\u9139\u9cb0", "zu": "\u79df\u8db3\u5352\u65cf\u7956\u8bc5\u963b\u7ec4\u4fce\u83f9\u5550\u5f82\u9a75\u8e74", "zuan": "\u94bb\u7e82\u6525\u7f35", "zui": "\u5634\u9189\u6700\u7f6a", "zun": "\u5c0a\u9075\u6499\u6a3d\u9cdf", "zuo": "\u6628\u5de6\u4f50\u67de\u505a\u4f5c\u5750\u5ea7\u961d\u963c\u80d9\u795a\u9162", "cou": "\u85ae\u6971\u8f8f\u8160", "nang": "\u652e\u54dd\u56d4\u9995\u66e9", "o": "\u5594", "dia": "\u55f2", "chuai": "\u562c\u81aa\u8e39", "cen": "\u5c91\u6d94", "diu": "\u94e5", "nou": "\u8028", "fou": "\u7f36", "bia": "\u9adf"&#125;;function ConvertPinyin(l1) &#123; var l2 = l1.length; var I1 = ""; var reg = new RegExp('[a-zA-Z0-9\- ]'); for (var i = 0; i &lt; l2; i++) &#123; var val = l1.substr(i, 1); var name = arraySearch(val, PinYin); if (reg.test(val)) &#123; I1 += val; &#125; else if (name !== false) &#123; I1 += name; &#125; &#125; I1 = I1.replace(/ /g, '-'); while (I1.indexOf('--') &gt; 0) &#123; I1 = I1.replace('--', '-'); &#125; return I1;&#125;function arraySearch(l1) &#123; for (var name in PinYin) &#123; if (PinYin[name].indexOf(l1) != -1) &#123; return name; break; &#125; &#125; return false;&#125;function checkName(name1,name2) &#123; let checkName ; let name ; let s = name1; let sp = name2; let re = new RegExp("^[a-zA-Z]+$"); let flag = re.test(s); let flagp = re.test(sp); if(flag)&#123; checkName = s; &#125;else&#123; checkName = ConvertPinyin(s); &#125; if(flagp)&#123; name = sp; &#125;else&#123; name = ConvertPinyin(sp); &#125; //判断是否匹配 let pipei = new RegExp(checkName); let page = pipei.test(name); return page&#125;export &#123; checkName&#125;]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[报错信息]]></title>
    <url>%2Fpost%2F624671ed.html</url>
    <content type="text"><![CDATA[报错项目11No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK? 原因：环境变量配置错误，配置到了jdk下面 21Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.18.1:test (default-test) 解决方案： 1mvn clean install -DskipTests 31Could not resolve dependencies for project com.easytoolsoft:easyreport-engine:jar:2.1-SNAPSHOT: The following artifacts could not be resolved: com.microsoft.sqlserver:sqljdbc4:jar:4.0, com.oracle:ojdbc6:jar:11.2.0.3: Failure to find com.microsoft.sqlserver:sqljdbc4:jar:4.0 in https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempted until the update interval of central has elapsed or updates are forced 原因： 微软不允许以maven的方式直接下载该文件 解决办法：下载sqljdbc4.jar(密码：hrt0)改名为sqljdbc4-4.0.jar，放到maven库里 1mvn help:effective-settings //查找本地maven库 1C:\Users\admin\.m2\repository //我的库的地址（默认） 根据上面找到下面的目录，将sqljdbc4-4.0.jar放入 1C:\Users\admin\.m2\repository\com\microsoft\sqlserver\sqljdbc4\4.0 41Could not resolve dependencies for project com.easytoolsoft:easyreport-engine:jar:2.1-SNAPSHOT: Failure to find com.oracle:ojdbc6:jar:11.2.0.3 in https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempted until the update interval of central has elapsed or updates are forced 原因：Oracle的ojdbc.jar是收费的，所以maven的中央仓库中没有这个资源，只能通过配置本地库才能加载到项目中去。 下载http://central.maven.org/maven2/com/jslsolucoes/ojdbc6/11.2.0.1.0/ojdbc6-11.2.0.1.0.jar 输入下面的命名（记得改成合适自己的版本号） 1mvn install:install-file -Dfile=D:\\ojdbc6-11.2.0.3.jar -DgroupId=com.oracle -DartifactId=ojdbc6 -Dversion=11.2.0.3 -Dpackaging=jar 打包后的war包在EasyReport\easyreport-web\target下 结果你发现是jar包，打开easyreport-web下的pom.xml修改 1234&lt;packaging&gt;jar&lt;/packaging&gt;&lt;artifactId&gt;easyreport-web&lt;/artifactId&gt;&lt;name&gt;easyreport-web&lt;/name&gt;&lt;description&gt;controller与web视图模块&lt;/description&gt; 1234&lt;packaging&gt;war&lt;/packaging&gt;&lt;artifactId&gt;easyreport-web&lt;/artifactId&gt;&lt;name&gt;easyreport-web&lt;/name&gt;&lt;description&gt;controller与web视图模块&lt;/description&gt;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10配置JAVA环境变量]]></title>
    <url>%2Fpost%2F6b40fbfe.html</url>
    <content type="text"><![CDATA[在系统变量中添加 JAVA_HOME 1C:\Program Files\Java\jdk1.8.0_144 CLASSPATH 1.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 编辑已存在的变量 Path 添加两行 1234%JAVA_HOME%\Bin%JAVA_HOME%\jre\Bin]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vbs文件]]></title>
    <url>%2Fpost%2F4ff37e9a.html</url>
    <content type="text"><![CDATA[从某知名短视频网站学习到的 源码 新建一个txt文件 粘贴如下代码 123msgbox("都是腰间盘")msgbox("你咋就这么突出") 保存退出，修改文件格式为vbs 点击使用]]></content>
      <categories>
        <category>趣闻</category>
      </categories>
      <tags>
        <tag>趣闻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构的中文翻译]]></title>
    <url>%2Fpost%2Ff8677495.html</url>
    <content type="text"><![CDATA[JavaScript 算法与数据结构中的数据结构的中文翻译 链表 在计算机科学中，链表是数据元素的线性集合，其中线性顺序不是由它们在内存中的物理位置所给出的。相反，每个元素指向下一个元素。它是由一组节点组成的数据结构，这些节点一起表示一个序列。在最简单的形式下，每个节点由数据和指向序列中下一个节点的引用(换句话说，链接)组成。这种结构允许在迭代过程中从序列的任何位置高效地插入或删除元素。更复杂的变体添加额外的链接，允许有效地插入或删除任意元素引用。链表的一个缺点是访问时间是线性的(并且很难进行流水线操作)。更快的访问，如随机访问，是不可行的。与链表相比，数组具有更好的缓存局部性。 队列 在计算机科学中,一个队列是一种特殊的抽象数据类型或集合的实体集保存在秩序和原则(或)操作集合的实体后终端位置,称为排队,从前面和删除实体终端位置,称为出列。这使队列成为先进先出(FIFO)数据结构。在FIFO数据结构中，添加到队列的第一个元素将是要删除的第一个元素。这等价于一旦添加了一个新元素，之前添加的所有元素都必须在新元素删除之前删除。通常还会输入一个peek或front操作，返回front元素的值，而不需要对其进行排序。队列是线性数据结构的一个例子，或者更抽象地说是顺序集合。 表示一个FIFO(先入先出)队列: 堆栈 在计算机科学中，堆栈是一种抽象的数据类型，作为元素的集合，有两个主要操作: push，将元素添加到集合中 pop，它删除了尚未删除的最近添加的元素。元素从堆栈中出来的顺序产生了它的替代名称LIFO(最后一个进入，首先退出)。此外，peek操作可以在不修改堆栈的情况下访问顶部。这种类型的结构“堆栈”这个名字来自于类比一组物理产品堆叠在彼此之上,这使得它很容易把一件事情从堆栈的顶部,在开始一个项目深入堆栈可能需要多个其他项目第一次起飞栈运行时的简单表示，带有push和pop操作。 哈希表 在计算中，哈希表是实现关联数组抽象数据类型的数据结构，可以将键映射到值。哈希表使用哈希函数将索引计算到桶或槽数组中，从中可以找到所需的值 理想情况下，哈希函数会将每个键分配给一个唯一的桶，但是大多数哈希表设计都使用不完美的哈希函数，这可能导致哈希函数为多个键生成相同的索引，从而导致哈希冲突。这种碰撞必须以某种方式加以适应。 通过单独的链接解决哈希冲突: 堆(数据结构) 在计算机科学中,堆是专门的树型数据结构,满足堆属性:如果P是C的父节点,那么关键(P值)是大于或等于(max堆)或小于或等于(在一个最小堆)C的关键节点的“顶级”堆(没有父母)称为根节点。 优先队列 在计算机科学中，优先级队列是一种抽象数据类型，它类似于常规队列或堆栈数据结构，但是每个元素都有与之相关联的“优先级”。在优先级队列中，高优先级的元素在低优先级的元素之前被服务。如果两个元素具有相同的优先级，则根据它们在队列中的顺序提供服务。 虽然优先级队列通常使用堆实现，但它们在概念上与堆是不同的。优先队列是一个抽象概念，如“列表”或“地图”;正如可以使用链表或数组实现列表一样，可以使用堆或其他方法(如无序数组)实现优先级队列。 字典树 在计算机科学中，trie也称为数字树，有时也称为基数树或前缀树(可以用前缀搜索)，是一种搜索树——一种有序的树数据结构，用于存储动态集或关联数组，其中的键通常是字符串。与二叉搜索树不同，树中没有节点存储与该节点关联的键;相反，它在树中的位置定义了关联的键。节点的所有后代都有与该节点相关联的字符串的公共前缀，而根则与空字符串相关联。值不一定与每个节点相关联。相反，值往往只与叶子和一些与感兴趣的键相对应的内部节点相关联。有关前缀树的空间优化表示，请参见紧凑前缀树。 树 二叉搜索树 AVL树 在计算机科学中，树是一种广泛使用的抽象数据类型(ADT)——或实现此ADT的数据结构——它模拟一个层次树结构，具有根值，子树带有父节点，表示为一组链接节点。树的数据结构可以定义递归(本地)作为节点的集合(从根节点开始),其中每个节点是一种数据结构组成的一个值,与参考节点的列表(“孩子”),与约束,没有引用是重复的,没有根。 一个简单的无序树;在这个图中，标记为7的节点有两个子节点，标记为2和6，一个父节点标记为2。顶部的根节点没有父节点。 二叉搜索树 在计算机科学中，二叉搜索树(BST)，有时被称为有序或排序的二叉树，是一种特殊类型的容器:数据结构，在内存中存储“项目”(如数字、名称等)。它们允许快速查找、添加和删除项，并且可以用于实现动态项集，或者查找表，以便按键查找项(例如，按人名查找某人的电话号码)。 二叉搜索树保持键排序顺序,以便查找和其他操作可以使用二分查找的原则:在寻找钥匙在树上(或插入一个新的密钥)的地方,他们遍历这棵树从根到叶,使比较键存储在树的节点和决定,比较的基础上,继续向左或向右子树中搜索。平均而言，这意味着每次比较都允许操作跳过树的大约一半，因此每次查找、插入或删除所花费的时间与树中存储的项的数量的对数成正比。这比在一个(未排序的)数组中按键查找项所需的线性时间要好得多，但比在哈希表上对应的操作要慢。 一个大小为9和深度为3的二叉搜索树，根为8。树叶没有被画出来。 AVL树 在计算机科学中，AVL树(以发明者Adelson-Velsky和Landis命名)是一种自平衡的二叉搜索树。这是第一个被发明的数据结构。在AVL树中，任何节点的两个子树的高度在最多的时候是不同的;如果在任何时候，它们之间的差异不止一个，那么重新平衡就是为了恢复这一资产。查找、插入和删除在平均和最坏的情况下都需要O(log n)时间，其中n是操作之前树中的节点数。插入和删除可能需要树被一个或多个树旋转重新平衡。 显示在AVL树中插入几个元素的动画。它包括左、右、左、右和左旋转。 AVL树平衡因子(绿色) AVL树旋转Left-Left Rotation Right-Right Rotation Left-Right Rotation Right-Left Rotation 红黑树 红黑树是计算机科学中的一种自平衡二叉搜索树。二叉树的每个节点都有一个额外的位，这个位通常被解释为节点的颜色(红色或黑色)。这些颜色位用于确保树在插入和删除过程中保持近似平衡。 平衡是通过用两种颜色中的一种来绘制树的每个节点，以满足某些属性，这些属性共同限制了树在最坏情况下的不平衡程度。当修改树时，新树随后被重新排列并重新绘制，以恢复着色属性。这些属性的设计方式使重新排列和重新上色能够有效地进行。 树的平衡并不完美，但是它足够好，可以保证在O(log n)时间内进行搜索，其中n是树中元素的总数。插入和删除操作以及树的重新排列和重新上色也在O(log n)时间内执行。 红黑树的一个例子: 属性 除了对二叉搜索树施加的要求之外，红黑树还必须满足以下条件: 每个节点要么是红色的，要么是黑色的。 根是黑色的。这条规则有时被省略。因为根总是可以从红色变为黑色，但也不一定相反，这个规则对分析没有什么影响。 所有的叶子(NIL)都是黑色的。 如果一个节点是红色的，那么它的子节点都是黑色的。 从给定节点到其任何子代NIL节点的每条路径都包含相同数量的黑节点。 一些定义:从根节点到节点的黑节点数是节点的黑深度;从根到叶的所有路径中黑色节点的统一数量称为红黑树的黑高度。 这些约束强化了红黑树的一个关键属性:从根到最远叶子的路径不超过从根到最近叶子的路径的两倍。结果是，这棵树大概是高度平衡的。由于插入、删除和查找值等操作需要最坏情况下的时间与树的高度成正比，因此在最坏情况下，与普通的二叉搜索树不同，红黑树在树的高度上的理论上界允许红黑树高效工作。 平衡插入If uncle is RED If uncle is BLACK Left Left Case (p is left child of g and x is left child of p) Left Right Case (p is left child of g and x is right child of p) Right Right Case (p is right child of g and x is right child of p) Right Left Case (p is right child of g and x is left child of p) – Left Left Case (See g, p and x) – Left Right Case (See g, p and x) – Right Right Case (See g, p and x) – Right Left Case (See g, p and x) 图(有向图与无向图) 在计算机科学中，图是一种抽象的数据类型，用于实现数学中的无向图和有向图概念，特别是图论领域 图数据结构由一个有限的(且可能是可变的)顶点或节点或点集组成，以及一组非向图或一组有向图的有序对。这些对称为无向图的边、弧或线，以及有向图的箭头、有向边、有向弧或有向线。顶点可以是图结构的一部分，也可以是由整数索引或引用表示的外部实体。 并查集 非联合集数据结构(也称为单点查找数据结构或合并查找集)是一种数据结构，它跟踪一组划分为若干不相交(不重叠)子集的元素。它提供near-constant-time操作(由阿克曼的逆函数有界)添加新的集,合并现有集,并确定是否在同一组元素。除了许多其他用途(请参见应用部分),分离集扮演着一个关键角色,克鲁斯卡算法寻找图的最小生成树。 MakeSet创建8单例 在联合的一些操作之后，一些集合被分组在一起。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据埋点代码结构]]></title>
    <url>%2Fpost%2Ffa1a30ae.html</url>
    <content type="text"><![CDATA[埋点原始数分析 技术选型前端框架： rollup.js 服务器： nginx 数据导入脚本： python 数据库： mysql 数据埋点分类内容： 数据埋点主要是为了采集用户行为的数据，根据用户应用的使用行为，各应用埋点大体包括以下几个方面 产品活跃状态分析 产品活跃状态监控，留存分析、流失分析、新增变化等，次日留存率、七日留存率、月留存率 事件分析 比如你想统计某个页面的UV、PV、元素的点击量、用户停留时长、页面跳出率等数据指标等等 基本信息获取 基本信息获取，例如浏览器类型、网络类型、操作系统，IP地域等，绘制基础用户人群画像。 漏斗模型 对产品的关键路径进行漏斗模型分析，比如注册路径，从用户输入注册手机号到注册成功，中间可能会有几个步骤，最后有几个人注册成功？在哪一个步骤注册失败的。 代码结构产品活跃状态分析代码 （liveness.js） 一个用户的唯一标识uid 参数传递uid 产品的唯一标识pid 事件分析 (event.js) URL 页面标题 分辨率 点击位置 referrer/hashchange 监听跳出页面 当前点击元素的基本信息 cookie 基本信息获取 (basic.js) 浏览器类型 ip 域名 网络类型 操作系统 漏斗模型 (funnel.js) 参数传递(具体业务具体分析)]]></content>
      <categories>
        <category>埋点</category>
      </categories>
      <tags>
        <tag>埋点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2Fpost%2F14e6f1eb.html</url>
    <content type="text"><![CDATA[原理 其基本思想是分治策略，先进行划分，然后再进行合并 12345678910111213141516171819202122function merge(left, right) &#123; var result = []; while(left.length &gt; 0 &amp;&amp; right.length &gt; 0) &#123; if(left[0] &lt; right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; /* 当左右数组长度不等.将比较完后剩下的数组项链接起来即可 */ return result.concat(left).concat(right); &#125;function mergeSort(arr)&#123; if(arr.length==1) &#123;return arr&#125;; var mid=Math.floor(arr.length/2); var left_arr=arr.slice(0,mid),right_arr=arr.slice(mid); return merge(mergeSort(left_arr),mergeSort(right_arr));&#125;var arr=[12,20,30,21,15,33,26,19,40,25];console.log(mergeSort(arr));]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2Fpost%2Fff8068c0.html</url>
    <content type="text"><![CDATA[原理 1、找基准（一般是以中间项为基准） 2、遍历数组，小于基准的放在left，大于基准的放在right 3、递归 12345678910111213141516171819202122function quickSort(arr)&#123; //如果数组&lt;=1,则直接返回 if(arr.length&lt;=1)&#123;return arr;&#125; var pivotIndex=Math.floor(arr.length/2); //找基准，并把基准从原数组删除 var pivot=arr.splice(pivotIndex,1)[0]; //定义左右数组 var left=[]; var right=[]; //比基准小的放在left，比基准大的放在right for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;=pivot)&#123; left.push(arr[i]); &#125; else&#123; right.push(arr[i]); &#125; &#125; //递归 return quickSort(left).concat([pivot],quickSort(right));&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大O表示法]]></title>
    <url>%2Fpost%2Ffd43a581.html</url>
    <content type="text"><![CDATA[作用 用来衡量算法的效率 通常是用资源，例如CPU(时间)占用，内存占用，硬盘占用，网络占用 理解 O(1) 123function o1(num)&#123; return ++num;&#125; 运行这个函数，执行时间是X ，不用管num值是多少，它的运行时间都是X，，因此它的复杂度是O(1)（常数） O(n) 12345678function sequentialSearch(array,item)&#123; for(var i=0; i&lt;array.length; i++)&#123; if( item == array[i])&#123; return i; &#125; &#125; retuen -1;&#125; 这个函数的执行的总开销取决于数组元素的个数，而且和搜索的值有关，所以它的时间复杂度是O(n); O(n^2) 12345678910111213141516171819function swap (array,index1,index2)&#123; var temp = array[index1]; array[index1] = array[index2]; array[index2] = temp;&#125;function bubbleSort (array)&#123; var length = array.lenth; var cost = 0; for (var i=0; i&lt;length; i++)&#123; cost ++; for(var j=0; j&lt;length-1; j++)&#123; cost ++; if(array[i] &gt; array[j])&#123; swap(array,i,j); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2Fpost%2Fa80d0031.html</url>
    <content type="text"><![CDATA[漫画什么是动态规划 所谓的动态规划就是将复杂问题分解成更小的子问题来解决的优化技术,大事化小，小事化了。 步骤 定义子问题 实现要反复执行而解决子问题的部分 识别并求解出边界条件 题目 有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。 第一步，假设现在是最后一步，那么有两种情况，一种是你在第八阶，另一种是你在第九阶，假设走到第八阶有X种走法，走到第九阶有Y种走法，那么总共有X+Y种走法，以此类推。递归 12345678910111213141516171819202122F(n) = F(n-1)+F(n-2) (n&gt;=3)function step(n)&#123; if(n &lt; 1)&#123; return 0; &#125;else if(n == 1)&#123; return 1; &#125;else if(n == 2)&#123; return 2; &#125;else &#123; return step(n-1) + step (n-2); &#125;&#125; 上面的解法类似一个二叉树，树的高度是n-1个，节点个数是2的n-1次方，时间复杂度O(2^n); 备忘录算法123456789101112131415161718192021222324252627'use strict'; var map = &#123;&#125;; function step(n)&#123; if(n &lt; 1)&#123; return 0; &#125;else if(n == 1)&#123; return 1; &#125;else if(n == 2)&#123; return 2; &#125;else &#123; var value; if(map[n-1] != undefined)&#123; value = map[n-1] + step (n-2); &#125;else&#123; value = step(n-1) + step (n-2); map[n] = value; &#125; return value; &#125; &#125; console.log(step(10)); 动态规划123456789101112131415161718192021222324252627function step(n)&#123; if(n &lt; 1)&#123; return 0; &#125;else if(n == 1)&#123; return 1; &#125;else if(n == 2)&#123; return 2; &#125;else &#123; var a = 1; var b = 2; var temp = 0; for(var i=0; i&lt;=n; i++)&#123; temp = a+b; a = b; b = temp; &#125; return temp; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法]]></title>
    <url>%2Fpost%2F4f9a43e7.html</url>
    <content type="text"><![CDATA[迭代器函数every 会返回第一个false后中断执行 12345678function isEven(x) &#123; console.log(x); return (x % 2 == 0) ? true : false;&#125;let num = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];num.every(isEven); some 会返回第一个true后中断执行 12345678function isEven(x) &#123; console.log(x); return (x % 2 == 0) ? true : false;&#125;let num = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];num.some(isEven); forEach 与for的结果相同 12345678let num = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];num.forEach(function(item,index)&#123; console.log(x % 2 == 0); &#125;); map myMap的值为[false,true,false,true,false,true,false,true,false,true,false,true,false,true,false],它保存了传入map方法的isEven函数的运行结果。 12345678function isEven(x) &#123; console.log(x); return (x % 2 == 0) ? true : false;&#125;let num = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];let myMap = num.map(isEven); filter myFilter返回的值为 [2,4,6,8,10,12,14] 12345678function isEven(x) &#123; console.log(x); return (x % 2 == 0) ? true : false;&#125;let num = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];let myFilter = num.filter(isEven); reduce targ 的值为200 ，可以获取前一个和后一个值 12345let num = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];let targ = num.reduce(function (previsor, current, index) &#123; return previsor + current;&#125;); 搜索和排序reverse res为 [ 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]，数组内的元素发生反序 12let num = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];let res = num.reverse(); sort 排序 12345let num = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];function compare(a,b) &#123; return a-b;&#125;num.sort(compare); 自定义排序 123456789let info = [ &#123;name:'yinxs',age:25&#125;, &#123;name:'yu',age:28&#125;, &#123;name:'pan',age:27&#125;];function compare(a,b) &#123; return a.age - b.age;&#125;info.sort(compare); 字符串排序 1234567891011let info = ['Ana','John','ana'];function compare(a,b) &#123; if(a.toLowerCase() &lt; b.toLowerCase())&#123; return -1; &#125;else if(a.toLowerCase() &gt; b.toLowerCase())&#123; return 1; &#125;else&#123; return 0; &#125;&#125;info.sort(compare); 搜索(lastIndexOf,indexOf) indexOf返回第一个匹配的索引，lastIndexOf返回最后一个匹配的索引]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react中的dva的使用]]></title>
    <url>%2Fpost%2F3fb51549.html</url>
    <content type="text"><![CDATA[参考参考 dva介绍 框架: dva是个框架，集成了redux、redux-saga、react-router-redux、react-router快速初始化: 可以快速实现项目的初始化，不需要繁琐地配置简化开发：将initState、saga、reducer集成到一个model里面统一管理，避免文件散落在各个文件里面，便于快速查找与开发简洁的API：整个项目中只有dva、app.model、app.router、app.use、app.start几个API无缝对接：跟react的生态没有冲突，例如可以直接使用redux devtool工具动态机制：app.start以后，仍然可以注册model，灵活性较高 安装dva npm install dva-cli -g 使用 dva new react-dva dva 的命令常用命令 生成路由： dva g route users 生成model: dva g model users 生成组件： dva g component Users/Users 增加service 1234import request from '../utils/request';// export function fetch(&#123; page = 1 &#125;) &#123;// return request(`/api/users?_page=$&#123;page&#125;&amp;_limit=5`);// &#125; 启动 npm start80端口可以启用 使用的框架antd 使用 ： npm install antd-init -g babel-plugin-import 是用来按需加载 antd 的脚本和样式的 npm install antd babel-plugin-import –save 注释：nvm alias defalut v6.10.0 可以设置ndoe的默认版本]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2Fpost%2F43d00a99.html</url>
    <content type="text"><![CDATA[原理 先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 12345678910111213141516171819function selectSort(arr)&#123; var len = arr.length; var index,temp; for(var i = 0; i &lt; len-1 ;i++)&#123; index = i; for(var j = i + 1 ; j&lt;len; j++)&#123; if(arr[j] &lt; arr[index])&#123;//寻找最小的数 index = j;//保存最小数的索引 &#125; &#125; temp = arr[i]; arr[i] = arr[index]; arr[index] = temp; &#125; return arr; &#125; var arr=[1,45,37,5,48,15,37,26,29,2,46,4,17,50,52]; console.log(selectSort(arr));]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心]]></title>
    <url>%2Fpost%2F34811d5f.html</url>
    <content type="text"><![CDATA[理解 贪心是一种特殊的动态规划，动态规划的本质是独立的子问题，而贪心则是每次可以找到最优的独立子问题。 贪心和动归不是互斥的，而是包含的，贪心更快，但约束更强，适应范围更小。 最小硬币找零法12345678910111213function Mincoinchange(coins,amount)&#123; var change = [], total = 0; for (var i=coins.length; i&gt;=0; i--)&#123; var coin = coins[i]; while (total + coin &lt;= amount)&#123; change.push(coin); total += coin; &#125; &#125; return change ;&#125;console.log(Mincoinchange([5,1,2,10,100],516));]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2Fpost%2F14e6f1eb.html</url>
    <content type="text"><![CDATA[原理 依次比较相邻的两个值，如果后面的比前面的小，则将小的元素排到前面。依照这个规则进行多次并且递减的迭代，直到顺序正确。时间复杂度，空间复杂度，稳定性 平均时间复杂度O(n*n) 最好情况O(n) 最差情况O(n*n) 空间复杂度O(1) 稳定性：稳定 123456789101112131415var examplearr=[8,94,15,88,55,76,21,39];function sortarr(arr)&#123; for(i=0;i&lt;arr.length-1;i++)&#123; for(j=0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; var temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; return arr;&#125;sortarr(examplearr);console.log(examplearr);]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2Fpost%2Fc6654282.html</url>
    <content type="text"><![CDATA[函数调用自身 比较著名的斐波那契 js调用栈大小的限制 chrome 20955 firefox 343429 1234567function fn(n)&#123;if(n==1|n==2)&#123;return 1;&#125;//因为斐波那契数列格式为：1、1、2、3、5、8、13、21、34、......,n=1和n=2的时候都是输出1return fn(n-1)+fn(n-2);//不断调用自身函数，n-1是穿进去的参数的前一次，就是最后n的前一个数字。所以n-2是最后传入参数的前两个数字。&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM操作和数据操作]]></title>
    <url>%2Fpost%2F1e0e36a0.html</url>
    <content type="text"><![CDATA[js的DOM操作 DOM操作会导致导致用户阻塞的重构(reflow)和重绘(repaint).在页面上的任何操作都是有代价的.reflow和repaint就是我们在改变页面或者说操作DOM时,会带来的两种后果. reflow意味着结构的改变,比如一堆元素堆叠,改变其中一个的宽高,那么相应的所有元素的位置都要改变.repaint意味着样式的改变比如div调整了背景色等,但是位置不变,只改变我们操作的元素.所以通常来看repaint的代价要远小于reflow,速度也更快. 虚拟DOM 对复杂的文档DOM结构，提供一种方便的工具，进行最小化地DOM操作 虚拟DOM快 js很快 DOM很慢 其实是由于每次生成virtual dom很快，diff生成patch也比较快，而在对DOM进行patch的时候，我能够根据Patch的内容，优化一部分DOM操作 为什么虚拟dom更胜一筹]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序搜索]]></title>
    <url>%2Fpost%2Fbc56fb70.html</url>
    <content type="text"><![CDATA[原理 顺序或线性搜索是最基本的搜索算法。它的机制是将每一个数据结构中的元素和我们要找的元素做比较。效率低下 12345678function search(item)&#123; for(var i=0; i&lt;array.length; i++)&#123; if(item === array[i])&#123; return i; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分搜索]]></title>
    <url>%2Fpost%2F98b35abd.html</url>
    <content type="text"><![CDATA[需求 需要被搜索的数据结构进行过排序 步骤 选择数组的中间值 如果选中值是待搜索值，那么算法执行完毕（值找到了） 如果待搜索值比选中值要小，则返回步骤一并在选中值左边的子数组中寻找 如果待搜索值比选中值要大，则返回步骤一并在选中值右边的子数组中寻找。 12345678910111213141516171819function binarySearch(item)&#123; this.quickSort();//首先需要进行排序，这里选择了快速排序 var low = 0, high =array.length - 1; mid,element; while (low &lt;= high)&#123; mid = Math.floor(low + high)/2; element = array(mid); if(element &lt; item)&#123; low = mid + 1; &#125;else if (element &gt; item)&#123; high = mid -1; &#125;else &#123; return mid; &#125; &#125; return -1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2Fpost%2F96555fb2.html</url>
    <content type="text"><![CDATA[效率： 最好：n 最坏：O(n^2) 12345678910111213141516171819202122232425262728function sort(elements)&#123; //假设第0个元素是一个有序的数列，第1个以后的是无序的序列， //所以从第1个元素开始将无序数列的元素插入到有序数列中 for(var i = 1; i &lt; elements.length; i++)&#123; //升序 if(elements[i] &lt; elements[i-1])&#123; //取出无序数列中的第i个作为被插入元素 var guard = elements[i]; //记住有序数列的最后一个位置，并且将有序数列位置扩大一个 var j = i - 1; elements[i] = elements[j]; //比大小，找到被插入元素所在的位置 while(j &gt;= 0 &amp;&amp; guard &lt; elements[j])&#123; elements[j+1] = elements[j]; j--; &#125; //插入 elements[j+1] = guard; &#125; &#125;&#125;var elements = [10, 9, 8, 7, 6, 5];console.log('before: ' + elements);sort(elements);console.log(' after: ' + elements); 如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需（n-1）次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。插入排序的赋值操作是比较操作的次数加上 (n-1）次。平均来说插入排序算法的时间复杂度为O(n^2）。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python导数据脚本]]></title>
    <url>%2Fpost%2F5dd43de5.html</url>
    <content type="text"><![CDATA[刚刚上手，代码很不优雅，有待优化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141# encoding: utf-8# get yesterday's dateimport datetimeimport xlwtimport os#import smtplib#from email.mime.text import MIMEText#from email.mime.multipart import MIMEMultipart#from email.header import Headertoday = datetime.date.today()yesterday = today - datetime.timedelta(days=1)day = yesterday.strftime("%Y-%m-%d")# create excelworkbook = xlwt.Workbook(encoding = 'utf-8')worksheet = workbook.add_sheet('My Worksheet')worksheet.col(0).width = 256*20worksheet.col(3).width = 256*20worksheet.col(4).width = 256*20worksheet.write(0, 0, label = '日期')worksheet.write(0, 1, label = 'PV')worksheet.write(0, 2, label = 'UV')worksheet.write(0, 3, label = '生成报告数')worksheet.write(0, 4, label = '生成报告人数')def date(time): rep_data_pv = 0 rep_data_uv = 0 rep_data_report = 0 rep_data_vistor = 0 for index in range(time): flag = index + 1 date_time = today - datetime.timedelta(days=flag) day_time = date_time.strftime("%Y-%m-%d") response_name = 'response-' + day_time + '.log' if os.path.exists(response_name): # Open the file for the day. f = open(response_name,'r') # Gets the statistics of the day's response file. str = f.read() f.close() # Divide by blank lines. arr = str.split('\n'); # whitespace base_data = [] for base in arr: base_data.append(base.split(' ')) # Statistical PV UV page = [] ip = [] for index in range(len(base_data)): for indexs in range(len(base_data[index])): if indexs == 5: ip.append(base_data[index][indexs]) elif indexs == 4: page.append(base_data[index][indexs]) # get page view and report pv = 0 report = 0 for init in page: target = init.split('?')[0].split('/') num = len(target)-1 if target[num] == 'getData': pv = pv + 1 elif target[num] == 'table': report = report + 1 # get unique visitor uv_arr = [] uv = 0 for init in ip: if init not in uv_arr: uv = uv + 1 uv_arr.append(init) # get report visitor view_ip = [] for index in range(len(page)): target = page[index].split('?')[0].split('/') num = len(target)-1 if target[num] == 'table': view_ip.append(ip[index]) vistor_arr = [] vistor = 0 for init in view_ip: if init not in vistor_arr: vistor = vistor + 1 vistor_arr.append(init) rep_data_pv = rep_data_pv + pv rep_data_uv = rep_data_uv + uv rep_data_report = rep_data_report + report rep_data_vistor = rep_data_vistor + vistor worksheet.write(flag, 0, label = day_time) worksheet.write(flag, 1, label = pv) worksheet.write(flag, 2, label = uv) worksheet.write(flag, 3, label = report) worksheet.write(flag, 4, label = vistor) else: data = &#123;'pv':0,'uv':0,'report':0,'vistor':0&#125; worksheet.write(flag, 0, label = day_time) worksheet.write(flag, 1, label = 0) worksheet.write(flag, 2, label = 0) worksheet.write(flag, 3, label = 0) worksheet.write(flag, 4, label = 0) sum = time+1 worksheet.write(sum, 0, label = '合计') worksheet.write(sum, 1, label = rep_data_pv) worksheet.write(sum, 2, label = rep_data_uv) worksheet.write(sum, 3, label = rep_data_report) worksheet.write(sum, 4, label = rep_data_vistor) date(27) workbook.save('报告--'+yesterday.strftime("%Y-%m-%d")+'.xls')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg]]></title>
    <url>%2Fpost%2F3452590.html</url>
    <content type="text"><![CDATA[svg SVG 意为可缩放矢量图形（Scalable Vector Graphics）。 SVG 使用 XML 格式定义图像。 SVG 是使用 XML 来描述二维图形和绘图程序的语言。 SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用来定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 SVG 是万维网联盟的标准 SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体 在html中使用SVG 方法一：123&lt;embed src="rect.svg" width="300" height="100" type="image/svg+xml"pluginspage="http://www.adobe.com/svg/viewer/install/" /&gt; 标签被所有主流的浏览器支持，并允许使用脚本。 当在 HTML 页面中嵌入 SVG 时使用 标签是 Adobe SVG Viewer 推荐的方法！然而，如果需要创建合法的 XHTML，就不能使用 。任何 HTML 规范中都没有 标签。 方法二：123&lt;object data="rect.svg" width="300" height="100" type="image/svg+xml"codebase="http://www.adobe.com/svg/viewer/install/" /&gt; 标签是 HTML 4 的标准标签，被所有较新的浏览器支持。它的缺点是不允许使用脚本。 假如您安装了最新版本的 Adobe SVG Viewer，那么当使用 标签时 SVG 文件无法工作（至少不能在 IE 中工作）！ 方法三：使用 标签 标签可工作在大部分的浏览器中。 12&lt;iframe src="rect.svg" width="300" height="100"&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文乱码问题]]></title>
    <url>%2Fpost%2F3b99456.html</url>
    <content type="text"><![CDATA[原因一1&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; 原因二 编辑器保存时要用UTF-8应该把记事本点击另存为，在保存左边有个编码 选择utf-8。 然后保存（代码的charset=utf-8 不变）]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Progressive Web Apps]]></title>
    <url>%2Fpost%2Fa9b40ecc.html</url>
    <content type="text"><![CDATA[今天想把muses项目升级为pwa，在本地运行还可以，但布到线上的时候，发现一直在报一个错误（Only secure origins are allowed (see: https://goo.gl/Y0ZkNV)），解决办法是将http协议升级为https，可以用nginx实现，但是需要证书 这是我们可以使用node创建一个， 这是如何利用node启动https 下面是app.js的代码 1234567891011121314151617const express = require('express')const path = require('path')const app = express()app.use(express.static(path.join(__dirname, 'public')))var https = require('https') ,fs = require("fs");var options = &#123; key: fs.readFileSync('./privatekey.pem'), cert: fs.readFileSync('./certificate.pem')&#125;;https.createServer(options, app).listen(3011, function () &#123; console.log('Https server listening on port ' + 3011);&#125;); 介绍 Progressive Web Apps 是 Google 提出的用前沿的 Web 技术为网页提供 App 般使用体验的一系列方案。这篇文章里我们来完成一个非常简单的 PWA 页面。 一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能 这是一个案例 这是一个比较复杂的案例 使用方法，http-server启动，打开80端口，kill掉服务，再刷新，发现仍然存在 service worker生命周期 参考 安装 需要安装http-server和ngrok以便调试和查看 准备一个HTML文件 添加manifest.json文件 使用manifest.json定义应用的名称，图标等等信息。 123456789101112131415&#123; "name": "Minimal app to try PWA", "short_name": "Minimal PWA", "display": "standalone", "start_url": "/", "theme_color": "#8888ff", "background_color": "#aaaaff", "icons": [ &#123; "src": "e.png", "sizes": "256x256", "type": "image/png" &#125; ]&#125; 然后引入到html文件之中 1&lt;link rel="manifest" href="manifest.json" /&gt; 添加Service Worker Service Worker 在网页已经关闭的情况下还可以运行, 用来实现页面的缓存和离线, 后台通知等等功能。sw.js 文件需要在 HTML 当中引入: 12345678&lt;script&gt; if (navigator.serviceWorker != null) &#123; navigator.serviceWorker.register('sw.js') .then(function(registration) &#123; console.log('Registered events at scope: ', registration.scope); &#125;); &#125;&lt;/script&gt; 后面我们会往 sw.js 文件当中添加逻辑代码。在 Service Worker 当中会用到一些全局变量: self: 表示 Service Worker 作用域, 也是全局变量 caches: 表示缓存 skipWaiting: 表示强制当前处在 waiting 状态的脚本进入 activate 状态 clients: 表示 Service Worker 接管的页面 处理静态缓存首先定义需要缓存的路径, 以及需要缓存的静态文件的列表, 这个列表也可以通过 Webpack 插件生成。12345678var cacheStorageKey = 'minimal-pwa-1'var cacheList = [ '/', "index.html", "main.css", "e.png"] 借助 Service Worker, 可以在注册完成安装 Service Worker 时, 抓取资源写入缓存:1234567self.addEventListener('install', e =&gt; &#123; e.waitUntil( caches.open(cacheStorageKey) .then(cache =&gt; cache.addAll(cacheList)) .then(() =&gt; self.skipWaiting()) )&#125;) 调用 self.skipWaiting() 方法是为了在页面更新的过程当中, 新的 Service Worker 脚本能立即激活和生效。处理动态缓存网页抓取资源的过程中, 在 Service Worker 可以捕获到 fetch 事件, 可以编写代码决定如何响应资源的请求:12345678910self.addEventListener('fetch', function(e) &#123; e.respondWith( caches.match(e.request).then(function(response) &#123; if (response != null) &#123; return response &#125; return fetch(e.request.url) &#125;) )&#125;) 真实的项目当中, 可以根据资源的类型, 站点的特点, 可以专门设计复杂的策略。fetch 事件当中甚至可以手动生成 Response 返回给页面。更新静态资源缓存的资源随着版本的更新会过期, 所以会根据缓存的字符串名称(这里变量为 cacheStorageKey, 值用了 “minimal-pwa-1”)清除旧缓存, 可以遍历所有的缓存名称逐一判断决决定是否清除(备注: 简化的写法, Promise.all 中 return undefined 可能出错):12345678910111213141516self.addEventListener('activate', function(e) &#123; e.waitUntil( Promise.all( caches.keys().then(cacheNames =&gt; &#123; return cacheNames.map(name =&gt; &#123; if (name !== cacheStorageKey) &#123; return caches.delete(name) &#125; &#125;) &#125;) ).then(() =&gt; &#123; return self.clients.claim() &#125;) )&#125;) 在新安装的 Service Worker 中通过调用 self.clients.claim() 取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面之后会被停止查看 Demo执行命令 http-server -c-1 # 注意设置关闭缓存, 这里用参数 -c-1 #用另一个终端ngrok http 8080 桌面浏览器可以直接通过 http://localhost:8080 访问, 从 DevTools 的 Application 标签可以看到 Service Worker。 由于 Service Worker 限制了使用 HTTPS 地址或者 localhost 地址, 在 Android Chrome 打开需要借助 ngrok 生成的 HTTPS 地址, 这样才能把 demo 添加到首屏。添加到首屏之后, 即便在离线状态下, 页面也可以打开。]]></content>
      <categories>
        <category>PWA</category>
      </categories>
      <tags>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo高级使用]]></title>
    <url>%2Fpost%2F3fb51549.html</url>
    <content type="text"><![CDATA[添加新的页面$ hexo new page about 配置目录在next下的_config.yml 12345678910menu: home: / || home archives: /archives || archive tags: /tags || tags message: /message || comment about: /about || user# Enable/Disable menu icons.menu_icons: enable: true 给一篇文章加入各种属性12345678---title: 归并排序categories: 算法tags: 算法abbrlink: 14e6f1ebdate: 2018-06-14 11:15:00--- 本地添加搜索菜单（功能）1npm install hexo-generator-searchdb --save 打开 站点配置文件 找到Extensions在下面添加 12345search: path: search.xml field: post format: html limit: 10000 添加字数统计、阅读时长、友情链接 第一步：安装word_count插件，在博客根目录下打开终端:npm install hexo-wordcount –save 第二步：在主题配置文件(themes\next\config.yml)中打开wordcount 统计功能 123456# Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true wordcount: true min2read: true 第三步： themes\next\layout_macro\post.swig将“字”、“分钟” 字样添加到如下位置即可。 12345678&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; ...&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 分类和标签123在该功能下的index.md中添加type: "categories" 首页显示一部分 进入themes/next目录下的_config.yml文件 搜索”auto_excerpt”： 12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 添加RSS1npm install hexo-generator-feed --save 打开 站点配置文件 找到Extensions在下面添加 12345678910# RSS订阅feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' 打开 主题配置文件 找到rss，设置为 1rss: /atom.xml]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>构建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ng4修仙大佬合集]]></title>
    <url>%2Fpost%2F2131f85.html</url>
    <content type="text"><![CDATA[一条不错的修仙体系 ng官网 ng配置路由 PM2 ng-cli命令 ng-echarts：npm install –save echarts ng2-echarts 使用echarts ng4中使用jquery ng的组成 node sql增删改查 资料 md5 node中es（elasticsearch） 关于es（elasticsearch）（看这个比较好懂） ngx-bootstrap ngx-bootstrap官网 ng4引入echarts node-pm2使用 node-热加载（supervisor node.js 为启动方式） bootstrap-module用法 ng中使用prototype]]></content>
      <categories>
        <category>ng4</category>
      </categories>
      <tags>
        <tag>ng4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为博客添加评论功能]]></title>
    <url>%2Fpost%2F1466266d.html</url>
    <content type="text"><![CDATA[注册https://github.com/settings/applications/new 在Authorization callback URL填写自己的网站 记录下来Client ID 和 Client Secret 在themes/next/_config.yml进行配置123456789101112enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: true # Comments lazy loading with a button cleanly: false # Hide 'Powered by ...' on footer, and more language: # Force language, or auto switch by theme github_user: Hughendman # MUST HAVE, Your Github ID github_repo: Hughendman.github.io # MUST HAVE, The repo you use to store Gitment comments client_id: Client ID # MUST HAVE, Github client id for the Gitment client_secret: Client Secret # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 解决中文问题1npm install hexo-abbrlink --save 站点配置文件里: 1234permalink: post/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>构建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3基础语法]]></title>
    <url>%2Fpost%2Fe5ac5920.html</url>
    <content type="text"><![CDATA[条件判断1234567age = 3if age &gt;= 18: print('adult')elif age &gt;= 6: print('teenager')else: print('kid') 循环语句123for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + xprint(sum) 123456sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) 1234567n = 1while n &lt;= 100: if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1print('END') 123456n = 0while n &lt; 10: n = n + 1 if n % 2 == 0: # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print(n) dict(字典)12d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;d['Michael'] get()12d.get("Michael");#key不存在返回None，或者自己指定的value pop(key)123d.pop('Bob')# 要删除一个key，用pop(key)方法，对应的value也会从dict中删除： 请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。 和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是用空间来换取时间的一种方法。 dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。 这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。 要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key set set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 123&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125; add(key) 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果： 123456&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125; remove(key) 通过remove(key)方法可以删除元素： 123&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s&#123;1, 2, 3&#125; set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： 123456&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125; set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。 数据类型转换int()函数可以把其他数据类型转换为整数1234567891011121314&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float('12.34')12.34&gt;&gt;&gt; str(1.23)'1.23'&gt;&gt;&gt; str(100)'100'&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool('')False]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反向代理+axios]]></title>
    <url>%2Fpost%2F1466265d.html</url>
    <content type="text"><![CDATA[反向代理 代理有两种一种是正向代理，一种是反向代理，正向代理代理的书客户端，反向代理代理的是服务端。 听过一个有意思的解释，凶手&gt;&gt; 毛利叔叔 &gt;&gt; 柯南，这里面毛利叔叔就是反向代理。也就是说真正的服务端是不可见的。]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eslint语法解决]]></title>
    <url>%2Fpost%2Fef695a00.html</url>
    <content type="text"><![CDATA[12345678910111213141516在webpack.base.conf.js里面删掉下面:preLoaders: [ &#123; test: /\.vue$/, loader: 'eslint', include: projectRoot, exclude: [/node_modules/, /ignore_lib/] &#125;, &#123; test: /\.js$/, loader: 'eslint', include: projectRoot, exclude: [/node_modules/, /ignore_lib/] &#125; ] 1234567891011删除以下代码就可以&#123; test: /\.(js|vue)$/, loader: 'eslint-loader', enforce: 'pre', include: [resolve('src'), resolve('test')], options: &#123; formatter: require('eslint-friendly-formatter') &#125; 然后需要重新编辑生效]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python高级特性]]></title>
    <url>%2Fpost%2F442f777e.html</url>
    <content type="text"><![CDATA[切片12345678910L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']# 取前三个元素r = []n = 3for i in range(n): r.append(L[i]) # &gt;&gt;&gt; r# ['Michael', 'Sarah', 'Tracy'] 也可以用一行代码实现 123456789101112131415161718192021222324&gt;&gt;&gt; L[0:3]['Michael', 'Sarah', 'Tracy']# 0 也可以省略&gt;&gt;&gt; L[:3]['Michael', 'Sarah', 'Tracy']# 也可以从索引1开始&gt;&gt;&gt; L[1:3]['Sarah', 'Tracy']# 也可以倒着取&gt;&gt;&gt; L[-2:]['Bob', 'Jack']&gt;&gt;&gt; L[-2:-1]['Bob']# 每五个取一个&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]# 也可以隔着取，每两个取一个&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8] 注：字符串也可以看成一种list 迭代123456&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:... print(x, y)...1 12 43 9 列表生成式12345678910111213141516&gt;&gt;&gt; list(range(1, 11))[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# 生成[1x1, 2x2, 3x3, ..., 10x10]&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)...&gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]# 上面的简写&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]#还可以这么写&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 生成器(generator)12345678&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;# 可以通过next()函数获得generator的下一个返回值 generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。 当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象： 1234567891011121314&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; for n in g:... print(n)... 0149162536496481 断点》》》》》》》》》》》》》》》》》]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[element-ui]]></title>
    <url>%2Fpost%2Fd0acb7fa.html</url>
    <content type="text"><![CDATA[安装1cnpm i element-ui --save 引入 在main.js 中 123456789101112import Vue from 'vue'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import App from './App.vue'Vue.use(ElementUI)new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;) 使用菜单导航123456&lt;el-menu :router="true" :default-active="$route.path" class="el-menu-demo" mode="horizontal" @select="handleSelect"&gt; &lt;el-menu-item index="/table"&gt;表格&lt;/el-menu-item&gt; &lt;el-menu-item index="/form"&gt;表单&lt;/el-menu-item&gt; &lt;el-menu-item index="/graph"&gt;图形&lt;/el-menu-item&gt; &lt;/el-menu&gt; index里面添加路由， router是使用路由模式为true 但是还会发现一个新的问题，它不默认选中了，所以这里要修改一下 12345&lt;el-menu :router="true" :default-active="$route.path" class="el-menu-demo" mode="horizontal" @select="handleSelect"&gt; &lt;el-menu-item index="/table"&gt;表格&lt;/el-menu-item&gt; &lt;el-menu-item index="/form"&gt;表单&lt;/el-menu-item&gt; &lt;el-menu-item index="/graph"&gt;图形&lt;/el-menu-item&gt; &lt;/el-menu&gt; elementUI关于树状图的增删改查，局部刷新问题链接在这里 elementUI关于tree的使用getCheckedKeys不能获取父节点的key]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHubPages + Hexo+Next构建你自己的博客]]></title>
    <url>%2Fpost%2F3609924.html</url>
    <content type="text"><![CDATA[github准备新建一个项目：你的用户名.github.io（项目名称） Hexo 安装node npm install hexo-cli -g hexo init 你的用户名.github.io // 尽量和Github仓库使用同一个名称 cd 你的用户名.github.io hexo s 打开http://localhost:4000/ Next主题安装 Next主题是iissnan所创作的一个Hexo主题，以简洁为主 cd xxx.github.io git clone https://github.com/iissnan/hexo-theme-next themes/next _config.yml站点配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Hexo Configuration ## Docs: https://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: 最晚的开始 #站点名称 subtitle: 所有的为时已晚都是开始的最好时候 #副标题 #个人描述 description: My goal is not write code.if we could ship products and make all this money without writing any code,we could.Your job is ship products EXACTLY on time.It doesn’t matter whether you are a developer,tester,program manager,product manager whatever.Everybody’s job is the same. author: Jack_lin #作者 language: zh-Hans #语言 timezone: # URL #绑定域名后，要创建 sitemap.xml 时再配置该项 ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/' url: http://yoursite.com root: / permalink: :year/:month/:day/:title/ permalink_defaults: # Directory #目录不用修改 source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing # 文章布局、写作格式的定义，不修改 new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: false tab_replace: # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format #时间格式不用修改 ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination #每页显示文章数，可以自行定义 ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page # Extensions #配置站点时，所使用的主题和插件，切换主题可以在这里设置 ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: next //在这里切换主题 # theme: landscape # 头像， 在xxx.github.io/source 下相对路径，若source文件夹下没有uploads，就新建一个名为uploads文件夹，具体见下面截图 avatar: /uploads/images/avatar.png # Deployment #这里是部署到Github上的设置 ## Docs: https://hexo.io/docs/deployment.html deploy: type: git #git提交 repo: https://github.com/123sunxiaolin/123sunxiaolin.github.io.git #已创建的Github仓库 branch: master #提交到的分支 如果报错: ERROR Deployer not found: git npm install –save hexo-deployer-git 部署 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 打包的项目在public中]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>构建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动补全私有前缀]]></title>
    <url>%2Fpost%2Fbc683d2d.html</url>
    <content type="text"><![CDATA[vue-cli 生成的项目里样式插件是自动插入的， 在 build/utils.js 里 autoprefixer 配置在 .postcssrc.js]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 函数]]></title>
    <url>%2Fpost%2Fc9c130c3.html</url>
    <content type="text"><![CDATA[定义函数12345def my_abs(x): if x &gt;= 0: return x else: return -x 调用函数1my_abs(-99) 函数的参数默认参数123456def enroll(name, gender, age=6, city='Beijing'): print('name:', name) print('gender:', gender) print('age:', age) print('city:', city) 递归函数1234def fact(n): if n==1: return 1 return n * fact(n - 1)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python2.7执行excel]]></title>
    <url>%2Fpost%2F2e50297d.html</url>
    <content type="text"><![CDATA[安装xlrd、xlwt、xlutilsxlrd：是python从excel读数据的第三方控件；xlwt：是python从excel写数据的第三方控件；xlutils：是python使用xlrd、xlwt的工具箱。若安装不成功，可能原因是需要安装setuptools。 [root@vm4 python]# pip install xlrd [root@vm4 python]# pip install xlwt [root@vm4 python]# pip install xlutils]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速构建vue项目（vue-cli）]]></title>
    <url>%2Fpost%2Ffb88d540.html</url>
    <content type="text"><![CDATA[全局安装1npm i -g vue-cli 创建项目(项目名称叫muses)1vue init webpack muses 启动(默认的是80端)1npm run dev 详细讲解 与ng4 的cli 不同 ，vue的cli比较复杂 ，但是实际上只要一直回车对后面没有影响，注意最后一项要选择npm的那个选项 build文件里面是一些操作文件,执行 npm run * 时执行的就是这里的文件 config 文件是配置文件 src 是资源文件，组件等都放在这里 assets 资源文件，同ng4 类似，放的是公共的资源，例如图片 打包1npm run build 注意 如果你是用的编辑器是webstorm 那么需要在setting中的Language选项里面的JavaScript设置为ECMAScript 6，这样才可以使用，如果还有问题，那么需要在script标签中标注type为es6]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加统计功能]]></title>
    <url>%2Fpost%2F1466267d.html</url>
    <content type="text"><![CDATA[全局配置busuanzi_count的配置项下enable: true 站点UV配置123site_uv: truesite_uv_header: 本站访客数site_uv_footer: 人次 站点PV配置123site_pv: truesite_pv_header: 本站总访问量site_pv_footer: 次 单页面PV配置123page_pv: truepage_pv_header: 本文总阅读量page_pv_footer: 次]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>构建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可维护性代码]]></title>
    <url>%2Fpost%2Fc3afef41.html</url>
    <content type="text"><![CDATA[可维护性代码有一些特征 可理解性： 其他人接手代码并理解它的意图和一般途径，而无需原开发人员的完整解释 直观性： 代码中的东西一看就能明白，不管其操作过程多么复杂 可适应性： 代码以一种数据上的变化不要求完全重写的方法撰写 可扩展性： 在代码架构上已考虑到在未来允许对核心功能进行扩展 可调试性： 当有地方出错时，代码可以给与你足够的信息来进可能直接确定问题所在]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程]]></title>
    <url>%2Fpost%2F47867b98.html</url>
    <content type="text"><![CDATA[尊重对象所有权 避免全局变量 避免与null进行比较 12345678910111213function sortSArray(values)&#123; if(values != null)&#123; //这是不可取的 &#125;&#125;//修改function sortArray(values)&#123; if(values instanceof Array)&#123; //这是可取的 &#125;&#125; 使用常量 123456789101112var time = &#123; time1: 12, time2: 13&#125;console.log(time.time1);console.log(time.time2);//而不是使用console.log(12);console.log(13);//关键在于重复值，用户界面字符串，URLs，任意可能会更改的值 避免全局查找（document等等）]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码规范]]></title>
    <url>%2Fpost%2F1adaadca.html</url>
    <content type="text"><![CDATA[1234567891011121314151617SUCCESS: 0, URL_INVALID: 1001, //请求地址无效 AUTH_FAIL: 1002, //鉴权失败 NO_PERMISSION: 1003, //无此权限 PARAM_INVALID: 1004, //参数无效 SMS_SEND_FAIL: 1005, //短信发送失败 ACT_CODE_INVALID: 1006, //验证码无效 ACCOUNT_INVALID: 1007, //帐号或密码错误 SESSION_TIMEOUT: 1009, //未登录或登录超时 DATA_EXIST: 1011, //数据已存在 DATA_INEXIST: 1012, //数据不存在 DATA_INEXIST_ON_CURR_CONDITIONS: 1013, //当前条件下数据不存在 DB_OPER: 9001, //数据库操作异常 DB_CONN: 9002, //数据库连接异常 UNKNOW: 9999 //未知异常]]></content>
      <categories>
        <category>规范</category>
      </categories>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node版本管理]]></title>
    <url>%2Fpost%2Ff9ae89b2.html</url>
    <content type="text"><![CDATA[linux下使用nvm1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash 1wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash 安装完后，如果是用xshell连远程主机的话，先重连一次，不然会发现提示找不到nvm命令 1source ~/.bashrc 列出所有版本号12nvm ls-remote 安装指定版本 1nvm install v7.9.0 切换版本 1nvm use v7.8.0 切换版本 1nvm current 查看版本 1nvm ls]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node框架简要说明（express）]]></title>
    <url>%2Fpost%2F448baf37.html</url>
    <content type="text"><![CDATA[介绍 如官网所说要使用koa就要使得node的版本在7以上，但是本人亲测6也是可以的(当然只是一部分，如果要用异步等函数，还是需要升级的) node 版本管理 如此那么对于不同版本的node，我们有一种方式可以对其进行管理nvm 安装nvm（还有一种n，暂不做介绍，但是nvm只支持mac以及linux）(安了半天，才发现n也不支持window ==)(所以windows下要使用GNVM)12345安装方式有两种：$ curl https://raw.github.com/creationix/nvm/v0.4.0/install.sh | sh或者$ wget -qO- https://raw.github.com/creationix/nvm/v0.4.0/install.sh | sh 123456nvm install 0.10 //下载0.10版本nodenvm use 0.10 // 使用指定的版本nvm ls.nvm //查看已安装版本nvm currentv //当前版本nvm run 0.10.24 server.js //指定版本运行rm -rf ~/.nvm 卸载 GNVM(需要使用管理员权限才可以使用)下载32位64位 安装 把下载下来的gnvm.exe放到node.exe所在的目录下执行gnvm version 检查是否安装成功 命令12345678910111、初始化gnvm gnvm config INIT2、查看本地安装了什么版本 gnvm ls3、安装需要的版本 gnvm 4.4.0 6.9.2 7.3.04、 gnvm ls查看所有版本后 切换到想要的版本 gnvm use 6.9.2 123456789version :: Print the version number of gnvm.exeinstall :: Install any node.exe versionuninstall :: Uninstall local node.exe versionuse :: Use any version of the local already existsupdate :: Update latest node.exels :: List show all &lt;local&gt; &lt;remote&gt; node.exe versionnode-version :: Show &lt;global&gt; &lt;latest&gt; node.exe versionconfig :: Setter and getter registryhelp [command] :: Help about any command 代码 注意koa使用了es6语法，所有需要引入bable（在node大于版本7.6以上的是这么使用） 123456789101112131415161718192021const Koa = require('koa');const app = new Koa();const main = ctx =&gt; &#123; if (ctx.request.accepts('xml')) &#123; ctx.response.type = 'xml'; ctx.response.body = '&lt;data&gt;Hello World&lt;/data&gt;'; &#125; else if (ctx.request.accepts('json')) &#123; ctx.response.type = 'json'; ctx.response.body = &#123; data: 'Hello World' &#125;; &#125; else if (ctx.request.accepts('html')) &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;p&gt;Hello World&lt;/p&gt;'; &#125; else &#123; ctx.response.type = 'text'; ctx.response.body = 'Hello World'; &#125;&#125;;app.use(main);app.listen(3000); 详解假设HTTP服务(和express没有太大区别)1234const Koa = require('koa');const app = new Koa();app.listen(3000); Context 对象 koa提供一个Context 对象，表示一次对话的上下文（res,req）。 123456789const Koa = require('koa');const app = new Koa();const main = ctx =&gt; &#123; //main函数用来设置ctx.response.body ctx.response.body = 'res';&#125;;app.use(main);//加载main函数app.listen(3000); ctx.response是响应 ctx.request是请求 response的类型 ctx.response.type可以判断类型 类型 xml json html text 文件(同express类似，koa也是fs)123456const fs = require('fs');const main = ctx =&gt; &#123; ctx.response.type = 'html'; ctx.response.body = fs.createReadStream('./demos/template.html');&#125;; 获取href ctx.request.path //这个可以用来获取get方式传参过来的参数 路由（koa-route）模块12345678910111213const route = require('koa-route');const about = ctx =&gt; &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;a href="/"&gt;Index Page&lt;/a&gt;';&#125;;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;app.use(route.get('/', main));//调用到的main函数app.use(route.get('/about', about));//调用的about函数 静态资源(路由)12345const path = require('path');const serve = require('koa-static');const main = serve(path.join(__dirname));app.use(main); 重定向12345const redirect = ctx =&gt; &#123; ctx.response.redirect('/');&#125;;app.use(route.get('/redirect', redirect)); 日志123const main = ctx =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`);&#125;; 中间件12345const logger = (ctx, next) =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); next();&#125;app.use(logger); 中间件栈 多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行。 最外层的中间件首先执行。 调用next函数，把执行权交给下一个中间件。 … 最内层的中间件最后执行。 执行结束后，把执行权交回上一层的中间件。 … 最外层的中间件收回执行权之后，执行next函数后面的代码 123456789101112131415161718192021const one = (ctx, next) =&gt; &#123; console.log('&gt;&gt; one'); next(); console.log('&lt;&lt; one');&#125;const two = (ctx, next) =&gt; &#123; console.log('&gt;&gt; two'); next(); console.log('&lt;&lt; two');&#125;const three = (ctx, next) =&gt; &#123; console.log('&gt;&gt; three'); next(); console.log('&lt;&lt; three');&#125;app.use(one);app.use(two);app.use(three); 输出：&gt;&gt; one&gt;&gt; two&gt;&gt; three&lt;&lt; three&lt;&lt; two&lt;&lt; one 异步中间件(async函数)1234const main = async function (ctx, next) &#123; ctx.response.type = 'html'; ctx.response.body = await fs.readFile('./demos/template.html', 'utf8');&#125;; 合成中间件(koa-compose)12345678910111213const compose = require('koa-compose');const logger = (ctx, next) =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); next();&#125;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;const middlewares = compose([logger, main]);//将logger和main合并成一个中间件app.use(middlewares); 500 错误1ctx.throw(500)//用来抛出500错误 返回状态1ctx.response.status = 200; 中间件错误处理1234567891011121314151617const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.response.status = err.statusCode || err.status || 500; ctx.response.body = &#123; message: err.message &#125;; &#125;&#125;;const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.use(handler);app.use(main); 运行出错会监听一个error事件123app.on('error', (err, ctx) =&gt; console.error('server error', err);); 使用try catch 是不能使用上面的方法的，这时候使用的是ctx.app.emit(‘error’, err, ctx);手动释放error 使用cookie12const n = Number(ctx.cookies.get('view') || 0) + 1;ctx.cookies.set('view', n); 获取post的请求参数123456789const koaBody = require('koa-body');const main = async function(ctx) &#123; const body = ctx.request.body; if (!body.name) ctx.throw(400, '.name required'); ctx.body = &#123; name: body.name &#125;;&#125;;app.use(koaBody()); 利用koa-body进行文件上传12345678910111213141516171819202122const os = require('os');const path = require('path');const koaBody = require('koa-body');const main = async function(ctx) &#123; const tmpdir = os.tmpdir(); const filePaths = []; const files = ctx.request.body.files || &#123;&#125;; for (let key in files) &#123; const file = files[key]; const filePath = path.join(tmpdir, file.name); const reader = fs.createReadStream(file.path); const writer = fs.createWriteStream(filePath); reader.pipe(writer); filePaths.push(filePath); &#125; ctx.body = filePaths;&#125;;app.use(koaBody(&#123; multipart: true &#125;)); 参考文献阮一峰教程 koa workshop kick-off-koa Koa Examples]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node编码规范]]></title>
    <url>%2Fpost%2F46cb4dd.html</url>
    <content type="text"><![CDATA[node编码规范 一、缩进&gt; 两个空格缩进，而不是tab缩进 二、变量声明&gt; 每一行声明必须带有var 三、空格&gt; 在操作符前后需要加空格（+，——，*，%，=等等）。此外小括号前后要加空格 123if (true) &#123; // some code&#125; 四、单双引号的使用&gt; 字符串使用单引号，json使用双引号 五、大括号的位置&gt; 大括号无需另起一行 六、逗号&gt; 逗号如果不在行尾，需要一个空格。 123var help = &#123; foo: 'hep', bar: 'me'&#125; 七、分号&gt; 给表达式结尾添加分号，不在行尾需要一个空格 八、命名规范&gt; 命名的主要范畴有变量，常量，方法，类，文件，包等 1、变量命名&gt; 采用小驼峰命名 adminUser等等 2、方法命名&gt; 方法名也是小驼峰法，但是采用的是动词或者判断性词语 3、类命名&gt; 采用大驼峰法命名 AdminUser 4、常量命名&gt; 单词的所有字母大写，用下划线分割 5、文件命名&gt; 小写，下划线分割 6、包名&gt; 不要包含node或者js的字样 九、比较操作&gt; 如果是无容忍的情况，请使用‘===’代替‘==’ 十、字面量&gt; 使用{}【】代替new Object（）和new Array（），不要调用string，bool，number对象类型。 十一、作用域&gt; 慎用with和eval · 十二、数组和对象1、字面格式量&gt; 如果对象中分行，一行只能有一个元素 2、for in循环&gt; 请对对象使用，不要对数组使用 3、 不要把数组当做对象来使用十二、异步&gt; 异步回调的第一个参数应该是错误提示 123function （err，data）&#123; &#125; &gt; 执行传入的回调函数，不能执行多次 十三、类与模块1、类继承&gt; 一般情况下，我们采用Node推荐的类继承方式 2、导出&gt; module.exports = Class; 十四、注解规范&gt; dox的注释规范。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa2跨域]]></title>
    <url>%2Fpost%2F8385bb90.html</url>
    <content type="text"><![CDATA[“koa2-cors”: “^2.0.5”, 123456789101112131415const cors = require('koa2-cors');app.use(cors(&#123; origin: function(ctx) &#123; if (ctx.url === '/test') &#123; return false; &#125; return '*'; &#125;, exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'], maxAge: 5, credentials: true, allowMethods: ['GET', 'POST', 'DELETE'], allowHeaders: ['Content-Type', 'Authorization', 'Accept'],&#125;));]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node框架简要说明（express）]]></title>
    <url>%2Fpost%2F448baf37.html</url>
    <content type="text"><![CDATA[最基础的两个后端框架（express和koa） 这两个是 Node.js 最基础的后端框架。因为太基础，所以构建一个 app 仍需要写很多脚手架代码，于是在它们基础之上出现了很多其他框架来减少编写这类代码。Express 应该是装机量最多的，而 Koa 更新一些, 使用的技术更新颖，例如 promises 和 async function，不再有回调函数嵌套的问题了。 express 框架安装 ： cnpm install -g express@3创建项目 : express -e httpsserver 安装 ： cnpm install express –save 以下三个插件最好一起和express安装 body-parser - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。（cnpm install body-parser –save） cookie-parser - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。（cnpm install cookie-parser –save） multer - node.js 中间件，用于处理 enctype=”multipart/form-data”（设置表单的MIME编码）的表单数据。（cnpm install multer –save） 以下是如何使用express插件(以下的案例是写了一个api为express的get请求的接口)12345678910111213141516//express_demo.js 文件var express = require('express');var app = express(); app.get('/api/express', function (req, res) &#123; res.send('Hello World');&#125;) var server = app.listen(8081, function () &#123; var host = server.address().address var port = server.address().port console.log("地址为http://%s:%s", host, port) &#125;) 以上的req和res分别是请求和响应，想要获取具体的值和传递具体的值都需要通过他们1234567891011121314151617181920212223242526272829303132333435363738394041以下我会介绍他们（怒想看可以略过，本人认为许多属性用不到，可以直接看最后）request 和 response 对象的具体介绍：Request 对象 - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：req.app：当callback为外部文件时，用req.app访问express的实例req.baseUrl：获取路由当前安装的URL路径req.body / req.cookies：获得「请求主体」/ Cookiesreq.fresh / req.stale：判断请求是否还「新鲜」req.hostname / req.ip：获取主机名和IP地址req.originalUrl：获取原始请求URLreq.params：获取路由的parametersreq.path：获取请求路径req.protocol：获取协议类型req.query：获取URL的查询参数串req.route：获取当前匹配的路由req.subdomains：获取子域名req.accepts()：检查可接受的请求的文档类型req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码req.get()：获取指定的HTTP请求头req.is()：判断请求头Content-Type的MIME类型Response 对象 - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：res.app：同req.app一样res.append()：追加指定HTTP头res.set()在res.append()后将重置之前设置的头res.cookie(name，value [，option])：设置Cookieopition: domain / expires / httpOnly / maxAge / path / secure / signedres.clearCookie()：清除Cookieres.download()：传送指定路径的文件res.get()：返回指定的HTTP头res.json()：传送JSON响应res.jsonp()：传送JSONP响应res.location()：只设置响应的Location HTTP头，不设置状态码或者close responseres.redirect()：设置响应的Location HTTP头，并且设置状态码302res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。res.send()：传送HTTP响应res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Typeres.set()：设置HTTP头，传入object可以一次设置多个头res.status()：设置HTTP状态码res.type()：设置Content-Type的MIME类型 在上面这些属性中我主要使用了res.json(data)来跟前端传输数据，利用req.body来进行获取post方式传来后台的数据，利用req.baseUrl获取get方式传来后台的参数 我主要使用的是express框架来构建的项目，下面的这个框架没有用过，但是他们两个都是一个团队开发的，但是koa最大的优点我认为是免除重复繁琐的回调函数嵌套 koa 安装：npm i koa 现在来对上面的express以及现在的koa进行比较 koa和express在表现上的一点不同是采用ctx一个参数来调用中间件，而不是express的req, res express的设计是串联的，设计思路超级简洁。koa的某一个中间件可以自行选择之后中间件的执行位置的。 express的社区还是大(很重要)。koa本来就小，还被从koa1转koa2一折腾，就更小了。 因为没有实际开发过所以介绍到此为止，个人认为以后的发展还是koa2比较有优势]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node]]></title>
    <url>%2Fpost%2F857fe845.html</url>
    <content type="text"><![CDATA[node文件整理 链接数据库（Mysql） 1234567891011121314var mysql = require('mysql');var connection = mysql.createConnection(&#123; //链接数据库的配置 host: 'localhost', //IP user: 'root', //用户名 password: '123456', //密码 database: 'test' //数据库名&#125;);connection.connect(); //开启链接connection.query('SELECT 1 + 1 AS solution', //写入sqlfunction(error, results) &#123; //返回的数据（result）报错信息（error） if (error) throw error; console.log('The solution is: ', results[0].solution)；&#125;);connection.end(); //关闭链接 请求接口 1234567891011121314//请求musus接口const request = require('request');const hera_api = require('../config/hera');exports.dv_dataset = function (req,res)&#123; res.status(200); var id= req.url.split("?")[1]; request(hera_api.hera_api+'lineage/dataset?' + id , function (error, response, body) &#123; console.log(hera_api.hera_api+'lineage/dataset?' + id); console.log(error); res.json(body); &#125;);&#125;; 编写接口 12345678910111213141516171819202122232425262728293031var express=require('express');var app =express();var bodyParser = require('body-parser');app.use(bodyParser.json(&#123;limit: '1mb'&#125;)); //body-parser 解析json格式数据app.use(bodyParser.urlencoded(&#123; //此项必须在 bodyParser.json 下面,为参数编码 extended: true&#125;));//mysql//mysqlconst mysql = require('mysql');const sql = require("../config/mysql");const client = sql.config_sql;exports.source_del =function (req,res) &#123; var datas = req.body; var source_del_sql = "DELETE FROM dict_datasource WHERE id = " + datas.id; client.query(source_del_sql, (err,datas) =&gt; &#123; res.status(200); if(err == null)&#123; res.json(&#123; status: true, data : datas &#125;); &#125;else &#123; res.json(&#123; status: false &#125;); &#125;&#125;);&#125;; 在server.js中引入 12345678910111213141516171819202122232425262728293031323334353637/*** Created by 尹雪松 on 2017/11/15.*/var express=require('express');var app =express();var bodyParser = require('body-parser');app.use(bodyParser.json(&#123;limit: '1mb'&#125;)); //body-parser 解析json格式数据app.use(bodyParser.urlencoded(&#123; //此项必须在 bodyParser.json 下面,为参数编码extended: true&#125;));//设置跨域访问app.all('*', function(req, res, next) &#123;res.header("Access-Control-Allow-Origin", "*");res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS");res.header("X-Powered-By",' 3.2.1');res.header("Content-Type", "application/json;charset=utf-8");next();&#125;);//引入外部文件接口const jobData = require("./job/job");app.post('/api/jobTable',jobData.job_data);//job table//配置服务端口var server = app.listen(9092, function () &#123;var host = server.address().address;var port = server.address().port;console.log('Example app listening at http://%s:%s';, host, port);&#125;); 管理(pm2) 123下载：npm -g i pm2 查看日志： pm2 logs监控： pm2 monit 12345678910111213141516171819202122启动： pm2 +nginxupstream my_nodejs_upstream &#123; server 127.0.0.1:3001;&#125;server &#123; listen 80; server_name my_nodejs_server; root /home/www/project_root; location / &#123; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_max_temp_file_size 0; proxy_pass http://my_nodejs_upstream/; proxy_redirect off; proxy_read_timeout 240s; &#125;&#125; 启动服务 12345678var express=require('express');var app =express();//配置服务端口var server = app.listen(9092, function () &#123;var host = server.address().address;var port = server.address().port;console.log('Example app listening at http://%s:%s';, host, port);&#125;);]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node日志]]></title>
    <url>%2Fpost%2F59c093b0.html</url>
    <content type="text"><![CDATA[在package.json中加入 1"log4js":"^0.6.38" 在bin下的www中加入以下代码 12345678910111213var fs = require('fs');var logConfig = require('../public/config/log_config');/** * 确定目录是否存在，如果不存在则创建目录 */var confirmPath = function(pathStr) &#123; if(!fs.existsSync(pathStr))&#123; fs.mkdirSync(pathStr); console.log('createPath: ' + pathStr); &#125;&#125; 在public下的config文件夹下创建log_config.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var path = require('path');//日志根目录var baseLogPath = path.resolve(__dirname, '../logs')//错误日志目录var errorPath = "/error";//错误日志文件名var errorFileName = "error";//错误日志输出完整路径var errorLogPath = baseLogPath + errorPath + "/" + errorFileName;// var errorLogPath = path.resolve(__dirname, "../logs/error/error");//响应日志目录var responsePath = "/response";//响应日志文件名var responseFileName = "response";//响应日志输出完整路径var responseLogPath = baseLogPath + responsePath + "/" + responseFileName;// var responseLogPath = path.resolve(__dirname, "../logs/response/response");module.exports = &#123; "appenders": [ //错误日志 &#123; "category":"errorLogger", //logger名称 "type": "dateFile", //日志类型 "filename": errorLogPath, //日志输出位置 "alwaysIncludePattern":true, //是否总是有后缀名 "pattern": "-yyyy-MM-dd.log", //后缀，每天创建一个新的日志文件 "path": errorPath //自定义属性，错误日志的根目录 &#125;, //响应日志 &#123; "category":"resLogger", "type": "dateFile", "filename": responseLogPath, "alwaysIncludePattern":true, "pattern": "-yyyy-MM-dd.log", "path": responsePath &#125; ], "levels": //设置logger名称对应的的日志等级 &#123; "errorLogger":"ERROR", "resLogger":"ALL" &#125;, "baseLogPath": baseLogPath //logs根目录&#125; 在主目录下创建utils文件夹，再创建log_util.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104var log4js = require('log4js');var log_config = require('../config/log_config');//加载配置文件log4js.configure(log_config);var logUtil = &#123;&#125;;var errorLogger = log4js.getLogger('errorLogger');var resLogger = log4js.getLogger('resLogger');//封装错误日志logUtil.logError = function (ctx, error, resTime) &#123; if (ctx &amp;&amp; error) &#123; errorLogger.error(formatError(ctx, error, resTime)); &#125;&#125;;//封装响应日志logUtil.logResponse = function (ctx, resTime) &#123; if (ctx) &#123; resLogger.info(formatRes(ctx, resTime)); &#125;&#125;;//格式化响应日志var formatRes = function (ctx, resTime) &#123; var logText = new String(); //响应日志开始 logText += "\n" + "*************** response log start ***************" + "\n"; //添加请求日志 logText += formatReqLog(ctx.request, resTime); //响应状态码 logText += "response status: " + ctx.status + "\n"; //响应内容 logText += "response body: " + "\n" + JSON.stringify(ctx.body) + "\n"; //响应日志结束 logText += "*************** response log end ***************" + "\n"; return logText;&#125;//格式化错误日志var formatError = function (ctx, err, resTime) &#123; var logText = new String(); //错误信息开始 logText += "\n" + "*************** error log start ***************" + "\n"; //添加请求日志 logText += formatReqLog(ctx.request, resTime); //错误名称 logText += "err name: " + err.name + "\n"; //错误信息 logText += "err message: " + err.message + "\n"; //错误详情 logText += "err stack: " + err.stack + "\n"; //错误信息结束 logText += "*************** error log end ***************" + "\n"; return logText;&#125;;//格式化请求日志var formatReqLog = function (req, resTime) &#123; var logText = new String(); var method = req.method; //访问方法 logText += "request method: " + method + "\n"; //请求原始地址 logText += "request originalUrl: " + req.originalUrl + "\n"; //客户端ip logText += "request client ip: " + req.ip + "\n"; //开始时间 var startTime; //请求参数 if (method === 'GET') &#123; logText += "request query: " + JSON.stringify(req.query) + "\n"; // startTime = req.query.requestStartTime; &#125; else &#123; logText += "request body: " + "\n" + JSON.stringify(req.body) + "\n"; // startTime = req.body.requestStartTime; &#125; //服务器响应时间 logText += "response time: " + resTime + "\n"; return logText;&#125;module.exports = logUtil; 在app中加入以下代码 12345678910111213141516171819202122232425262728293031const logUtil = require('./public/utils/log_util');// loggerapp.use(async (ctx, next) =&gt; &#123; //响应开始时间 const start = new Date(); //响应间隔时间 var ms; try &#123; //开始进入到下一个中间件 await next(); ms = new Date() - start; //记录响应日志 logUtil.logResponse(ctx, ms); &#125; catch (error) &#123; ms = new Date() - start; //记录异常日志 logUtil.logError(ctx, error, ms); ctx.body = &#123; success: false, data: null, message: error, status: 101 &#125; &#125;&#125;); 在public文件下面创建logs文件夹，下面创建error以及response文件夹]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2Fpost%2F7b25d017.html</url>
    <content type="text"><![CDATA[下载需要下载一个redis，或者是连接的那个服务器有redis cnpm i redis 我的本机安装目录C:\Program Files\Redis 执行：redis-server.exe 1234567891011121314151617//使用redis，用来缓存数据const redis = require('redis');const client = redis.createClient(&#123;host:'192.168.14.6', port: 6379,no_ready_check:true&#125;);client.on("error", function (err) &#123; console.log("redis client连接失败",err);&#125;);client.on('ready', function (res) &#123; console.log('client ready');&#125;);client.on('connect', function () &#123; client.set("var_2", "var_2_val", function () &#123; var read_var_2=client.get("var_2"); console.log("第二次读取到的值："+read_var_2); &#125;); client.quit();&#125;); 这个里面设置了过期时间使用的redis.expire12345678910router.get('/', function (ctx, next) &#123; let render = null; render = tableData.tableData(tableJson); render.count = render.data.length; render.num = 10; redis.set('var_2', JSON.stringify(render)); redis.expire('var_2', 300); render.data = render.data.slice(0,9); ctx.body = render;&#125;);]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node 和 文件（file）]]></title>
    <url>%2Fpost%2F7e3a5fc6.html</url>
    <content type="text"><![CDATA[fs文件读取 实现方法首先创建一个file.txt的文件 123456789var fs = require('fs'); fs.readFile('file.txt', 'utf-8', function (err, data) &#123; if (err) &#123; console.log("读取错误：" + err); return; &#125; console.log(data); &#125;) 注意这里需要指定第二个参数，否则的话会默认输出十六进制字节的格式 注意如果文件编码为ANSI格式，还用‘utf-8’会读取出错 还用这些格式utf8, ucs2,ascii, binary, base64, hex可以供我们使用 同步读取文件123var fs = require('fs'); var data = fs.readFileSync('test.txt', 'utf-8'); console.log(data); 具体的 操作可以看这里]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node启动在一个服务中]]></title>
    <url>%2Fpost%2Fea010e66.html</url>
    <content type="text"><![CDATA[在实验koa2时有这么一句话1app.use(require('koa-static')(__dirname + '/public/static')) 把打包后的文件放在这里面]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达如何模糊查询]]></title>
    <url>%2Fpost%2F1ca0c96a.html</url>
    <content type="text"><![CDATA[首先将汉字转换为拼音的方法这里有一个案例可以使用 如何在vue中引入 首先我使用的是vue框架，直接写进去也可以但是有些不美观，所以来看一看如何在vue中引入js文件 首先先将需要引入的模块抛出 123export &#123; function&#125; 然后我们进行导入 12import &#123;function&#125; from "地址"然后直接使用就可以 如上所示我们已经在vue导入了将中文转换问拼音的方法，但是我们不保证输入进来的一定是拼音，所有我们要用正则验证一下，输入进来的值是不是拼音12345678910let checkName ; let s = "尹"; let re = new RegExp("^[a-zA-Z]+$"); let flag = re.test(s); if(flag)&#123; checkName = s; &#125;else&#123; checkName = ConvertPinyin(s) &#125; console.log(checkName); 如上所示，我们对于输入的验证已经完成 最后完整的代码如下123456789101112131415161718192021222324let checkName ; let name ; let s = "yin"; let sp = "尹雪松"; let re = new RegExp("^[a-zA-Z]+$"); let flag = re.test(s); let flagp = re.test(sp); if(flag)&#123; checkName = s; &#125;else&#123; checkName = ConvertPinyin(s); &#125; if(flagp)&#123; name = sp; &#125;else&#123; name = ConvertPinyin(sp); &#125; console.log(checkName); console.log(name); //判断是否匹配 let pipei = new RegExp(checkName); let page = pipei.test(name); console.log(page); 输出的page值可以判断是否匹配 最后将代码进行封装 使用的时候直接调用 chackName(“yin”,”尹雪松”)，返回true or false； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461var PinYin = &#123; "a": "\u554a\u963f\u9515", "ai": "\u57c3\u6328\u54ce\u5509\u54c0\u7691\u764c\u853c\u77ee\u827e\u788d\u7231\u9698\u8bf6\u6371\u55f3\u55cc\u5ad2\u7477\u66a7\u7839\u953f\u972d", "an": "\u978d\u6c28\u5b89\u4ffa\u6309\u6697\u5cb8\u80fa\u6848\u8c19\u57ef\u63de\u72b4\u5eb5\u6849\u94f5\u9e4c\u9878\u9eef", "ang": "\u80ae\u6602\u76ce", "ao": "\u51f9\u6556\u71ac\u7ff1\u8884\u50b2\u5965\u61ca\u6fb3\u5773\u62d7\u55f7\u5662\u5c99\u5ed2\u9068\u5aaa\u9a9c\u8071\u87af\u93ca\u9ccc\u93d6", "ba": "\u82ad\u634c\u6252\u53ed\u5427\u7b06\u516b\u75a4\u5df4\u62d4\u8dcb\u9776\u628a\u8019\u575d\u9738\u7f62\u7238\u8307\u83dd\u8406\u636d\u5c9c\u705e\u6777\u94af\u7c91\u9c85\u9b43", "bai": "\u767d\u67cf\u767e\u6446\u4f70\u8d25\u62dc\u7a17\u859c\u63b0\u97b4", "ban": "\u6591\u73ed\u642c\u6273\u822c\u9881\u677f\u7248\u626e\u62cc\u4f34\u74e3\u534a\u529e\u7eca\u962a\u5742\u8c73\u94a3\u7622\u764d\u8228", "bang": "\u90a6\u5e2e\u6886\u699c\u8180\u7ed1\u68d2\u78c5\u868c\u9551\u508d\u8c24\u84a1\u8783", "bao": "\u82de\u80de\u5305\u8912\u96f9\u4fdd\u5821\u9971\u5b9d\u62b1\u62a5\u66b4\u8c79\u9c8d\u7206\u52f9\u8446\u5b80\u5b62\u7172\u9e28\u8913\u8db5\u9f85", "bo": "\u5265\u8584\u73bb\u83e0\u64ad\u62e8\u94b5\u6ce2\u535a\u52c3\u640f\u94c2\u7b94\u4f2f\u5e1b\u8236\u8116\u818a\u6e24\u6cca\u9a73\u4eb3\u8543\u5575\u997d\u6a97\u64d8\u7934\u94b9\u9e41\u7c38\u8ddb", "bei": "\u676f\u7891\u60b2\u5351\u5317\u8f88\u80cc\u8d1d\u94a1\u500d\u72c8\u5907\u60eb\u7119\u88ab\u5b5b\u9642\u90b6\u57e4\u84d3\u5457\u602b\u6096\u789a\u9e4e\u8919\u943e", "ben": "\u5954\u82ef\u672c\u7b28\u755a\u574c\u951b", "beng": "\u5d29\u7ef7\u752d\u6cf5\u8e66\u8ff8\u552a\u5623\u750f", "bi": "\u903c\u9f3b\u6bd4\u9119\u7b14\u5f7c\u78a7\u84d6\u853d\u6bd5\u6bd9\u6bd6\u5e01\u5e87\u75f9\u95ed\u655d\u5f0a\u5fc5\u8f9f\u58c1\u81c2\u907f\u965b\u5315\u4ef3\u4ffe\u8298\u835c\u8378\u5421\u54d4\u72f4\u5eb3\u610e\u6ed7\u6fde\u5f3c\u59a3\u5a62\u5b16\u74a7\u8d32\u7540\u94cb\u79d5\u88e8\u7b5a\u7b85\u7be6\u822d\u895e\u8df8\u9ac0", "bian": "\u97ad\u8fb9\u7f16\u8d2c\u6241\u4fbf\u53d8\u535e\u8fa8\u8fa9\u8fab\u904d\u533e\u5f01\u82c4\u5fed\u6c74\u7f0f\u7178\u782d\u78a5\u7a39\u7a86\u8759\u7b3e\u9cca", "biao": "\u6807\u5f6a\u8198\u8868\u5a4a\u9aa0\u98d1\u98d9\u98da\u706c\u9556\u9573\u762d\u88f1\u9cd4", "bie": "\u9cd6\u618b\u522b\u762a\u8e69\u9cd8", "bin": "\u5f6c\u658c\u6fd2\u6ee8\u5bbe\u6448\u50a7\u6d5c\u7f24\u73a2\u6ba1\u8191\u9554\u9acc\u9b13", "bing": "\u5175\u51b0\u67c4\u4e19\u79c9\u997c\u70b3\u75c5\u5e76\u7980\u90b4\u6452\u7ee0\u678b\u69df\u71f9", "bu": "\u6355\u535c\u54fa\u8865\u57e0\u4e0d\u5e03\u6b65\u7c3f\u90e8\u6016\u62ca\u535f\u900b\u74ff\u6661\u949a\u91ad", "ca": "\u64e6\u5693\u7924", "cai": "\u731c\u88c1\u6750\u624d\u8d22\u776c\u8e29\u91c7\u5f69\u83dc\u8521", "can": "\u9910\u53c2\u8695\u6b8b\u60ed\u60e8\u707f\u9a96\u74a8\u7cb2\u9eea", "cang": "\u82cd\u8231\u4ed3\u6ca7\u85cf\u4f27", "cao": "\u64cd\u7cd9\u69fd\u66f9\u8349\u8279\u5608\u6f15\u87ac\u825a", "ce": "\u5395\u7b56\u4fa7\u518c\u6d4b\u5202\u5e3b\u607b", "ceng": "\u5c42\u8e6d\u564c", "cha": "\u63d2\u53c9\u832c\u8336\u67e5\u78b4\u643d\u5bdf\u5c94\u5dee\u8be7\u7339\u9987\u6c4a\u59f9\u6748\u6942\u69ce\u6aab\u9497\u9538\u9572\u8869", "chai": "\u62c6\u67f4\u8c7a\u4faa\u8308\u7625\u867f\u9f87", "chan": "\u6400\u63ba\u8749\u998b\u8c17\u7f20\u94f2\u4ea7\u9610\u98a4\u5181\u8c04\u8c36\u8487\u5edb\u5fcf\u6f7a\u6fb6\u5b71\u7fbc\u5a75\u5b17\u9aa3\u89c7\u7985\u9561\u88e3\u87fe\u8e94", "chang": "\u660c\u7316\u573a\u5c1d\u5e38\u957f\u507f\u80a0\u5382\u655e\u7545\u5531\u5021\u4f25\u9b2f\u82cc\u83d6\u5f9c\u6005\u60dd\u960a\u5a3c\u5ae6\u6636\u6c05\u9cb3", "chao": "\u8d85\u6284\u949e\u671d\u5632\u6f6e\u5de2\u5435\u7092\u600a\u7ec9\u6641\u8016", "che": "\u8f66\u626f\u64a4\u63a3\u5f7b\u6f88\u577c\u5c6e\u7817", "chen": "\u90f4\u81e3\u8fb0\u5c18\u6668\u5ff1\u6c89\u9648\u8d81\u886c\u79f0\u8c0c\u62bb\u55d4\u5bb8\u741b\u6987\u809c\u80c2\u789c\u9f80", "cheng": "\u6491\u57ce\u6a59\u6210\u5448\u4e58\u7a0b\u60e9\u6f84\u8bda\u627f\u901e\u9a8b\u79e4\u57d5\u5d4a\u5fb5\u6d48\u67a8\u67fd\u6a18\u665f\u584d\u77a0\u94d6\u88ce\u86cf\u9172", "chi": "\u5403\u75f4\u6301\u5319\u6c60\u8fdf\u5f1b\u9a70\u803b\u9f7f\u4f88\u5c3a\u8d64\u7fc5\u65a5\u70bd\u50ba\u5880\u82aa\u830c\u640b\u53f1\u54e7\u557b\u55e4\u5f73\u996c\u6cb2\u5ab8\u6555\u80dd\u7719\u7735\u9e31\u761b\u892b\u86a9\u87ad\u7b1e\u7bea\u8c49\u8e05\u8e1f\u9b51", "chong": "\u5145\u51b2\u866b\u5d07\u5ba0\u833a\u5fe1\u61a7\u94f3\u825f", "chou": "\u62bd\u916c\u7574\u8e0c\u7a20\u6101\u7b79\u4ec7\u7ef8\u7785\u4e11\u4fe6\u5733\u5e31\u60c6\u6eb4\u59af\u7633\u96e0\u9c8b", "chu": "\u81ed\u521d\u51fa\u6a71\u53a8\u8e87\u9504\u96cf\u6ec1\u9664\u695a\u7840\u50a8\u77d7\u6410\u89e6\u5904\u4e8d\u520d\u61b7\u7ecc\u6775\u696e\u6a17\u870d\u8e70\u9edc", "chuan": "\u63e3\u5ddd\u7a7f\u693d\u4f20\u8239\u5598\u4e32\u63be\u821b\u60f4\u9044\u5ddb\u6c1a\u948f\u9569\u8221", "chuang": "\u75ae\u7a97\u5e62\u5e8a\u95ef\u521b\u6006", "chui": "\u5439\u708a\u6376\u9524\u5782\u9672\u68f0\u69cc", "chun": "\u6625\u693f\u9187\u5507\u6df3\u7eaf\u8822\u4fc3\u83bc\u6c8c\u80ab\u6710\u9e51\u877d", "chuo": "\u6233\u7ef0\u851f\u8fb6\u8f8d\u955e\u8e14\u9f8a", "ci": "\u75b5\u8328\u78c1\u96cc\u8f9e\u6148\u74f7\u8bcd\u6b64\u523a\u8d50\u6b21\u8360\u5472\u5d6f\u9e5a\u8785\u7ccd\u8d91", "cong": "\u806a\u8471\u56f1\u5306\u4ece\u4e1b\u506c\u82c1\u6dd9\u9aa2\u742e\u7481\u679e", "cu": "\u51d1\u7c97\u918b\u7c07\u731d\u6b82\u8e59", "cuan": "\u8e7f\u7be1\u7a9c\u6c46\u64ba\u6615\u7228", "cui": "\u6467\u5d14\u50ac\u8106\u7601\u7cb9\u6dec\u7fe0\u8403\u60b4\u7480\u69b1\u96b9", "cun": "\u6751\u5b58\u5bf8\u78cb\u5fd6\u76b4", "cuo": "\u64ae\u6413\u63aa\u632b\u9519\u539d\u811e\u9509\u77ec\u75e4\u9e7e\u8e49\u8e9c", "da": "\u642d\u8fbe\u7b54\u7629\u6253\u5927\u8037\u54d2\u55d2\u601b\u59b2\u75b8\u8921\u7b2a\u977c\u9791", "dai": "\u5446\u6b79\u50a3\u6234\u5e26\u6b86\u4ee3\u8d37\u888b\u5f85\u902e\u6020\u57ed\u7519\u5454\u5cb1\u8fe8\u902f\u9a80\u7ed0\u73b3\u9edb", "dan": "\u803d\u62c5\u4e39\u5355\u90f8\u63b8\u80c6\u65e6\u6c2e\u4f46\u60ee\u6de1\u8bde\u5f39\u86cb\u4ebb\u510b\u5369\u840f\u5556\u6fb9\u6a90\u6b9a\u8d55\u7708\u7605\u8043\u7baa", "dang": "\u5f53\u6321\u515a\u8361\u6863\u8c20\u51fc\u83ea\u5b95\u7800\u94db\u88c6", "dao": "\u5200\u6363\u8e48\u5012\u5c9b\u7977\u5bfc\u5230\u7a3b\u60bc\u9053\u76d7\u53e8\u5541\u5fc9\u6d2e\u6c18\u7118\u5fd1\u7e9b", "de": "\u5fb7\u5f97\u7684\u951d", "deng": "\u8e6c\u706f\u767b\u7b49\u77aa\u51f3\u9093\u5654\u5d9d\u6225\u78f4\u956b\u7c26", "di": "\u5824\u4f4e\u6ef4\u8fea\u654c\u7b1b\u72c4\u6da4\u7fdf\u5ae1\u62b5\u5e95\u5730\u8482\u7b2c\u5e1d\u5f1f\u9012\u7f14\u6c10\u7c74\u8bcb\u8c1b\u90b8\u577b\u839c\u837b\u5600\u5a23\u67e2\u68e3\u89cc\u7825\u78b2\u7747\u955d\u7f9d\u9ab6", "dian": "\u98a0\u6382\u6ec7\u7898\u70b9\u5178\u975b\u57ab\u7535\u4f43\u7538\u5e97\u60e6\u5960\u6dc0\u6bbf\u4e36\u963d\u576b\u57dd\u5dc5\u73b7\u765c\u766b\u7c1f\u8e2e", "diao": "\u7889\u53fc\u96d5\u51cb\u5201\u6389\u540a\u9493\u8c03\u8f7a\u94de\u8729\u7c9c\u8c82", "die": "\u8dcc\u7239\u789f\u8776\u8fed\u8c0d\u53e0\u4f5a\u57a4\u581e\u63f2\u558b\u6e2b\u8f76\u7252\u74de\u8936\u800b\u8e40\u9cbd\u9cce", "ding": "\u4e01\u76ef\u53ee\u9489\u9876\u9f0e\u952d\u5b9a\u8ba2\u4e22\u4ec3\u5576\u738e\u815a\u7887\u753a\u94e4\u7594\u8035\u914a", "dong": "\u4e1c\u51ac\u8463\u61c2\u52a8\u680b\u4f97\u606b\u51bb\u6d1e\u578c\u549a\u5cbd\u5cd2\u5902\u6c21\u80e8\u80f4\u7850\u9e2b", "dou": "\u515c\u6296\u6597\u9661\u8c46\u9017\u75d8\u8538\u94ad\u7aa6\u7aac\u86aa\u7bfc\u9161", "du": "\u90fd\u7763\u6bd2\u728a\u72ec\u8bfb\u5835\u7779\u8d4c\u675c\u9540\u809a\u5ea6\u6e21\u5992\u828f\u561f\u6e0e\u691f\u6a50\u724d\u8839\u7b03\u9ad1\u9ee9", "duan": "\u7aef\u77ed\u953b\u6bb5\u65ad\u7f0e\u5f56\u6934\u7145\u7c16", "dui": "\u5806\u5151\u961f\u5bf9\u603c\u619d\u7893", "dun": "\u58a9\u5428\u8e72\u6566\u987f\u56e4\u949d\u76fe\u9041\u7096\u7818\u7905\u76f9\u9566\u8db8", "duo": "\u6387\u54c6\u591a\u593a\u579b\u8eb2\u6735\u8dfa\u8235\u5241\u60f0\u5815\u5484\u54da\u7f0d\u67c1\u94ce\u88f0\u8e31", "e": "\u86fe\u5ce8\u9e45\u4fc4\u989d\u8bb9\u5a25\u6076\u5384\u627c\u904f\u9102\u997f\u5669\u8c14\u57a9\u57ad\u82ca\u83aa\u843c\u5443\u6115\u5c59\u5a40\u8f6d\u66f7\u816d\u786a\u9507\u9537\u9e57\u989a\u9cc4", "en": "\u6069\u84bd\u6441\u5514\u55ef", "er": "\u800c\u513f\u8033\u5c14\u9975\u6d31\u4e8c\u8d30\u8fe9\u73e5\u94d2\u9e38\u9c95", "fa": "\u53d1\u7f5a\u7b4f\u4f10\u4e4f\u9600\u6cd5\u73d0\u57a1\u781d", "fan": "\u85e9\u5e06\u756a\u7ffb\u6a0a\u77fe\u9492\u7e41\u51e1\u70e6\u53cd\u8fd4\u8303\u8d29\u72af\u996d\u6cdb\u8629\u5e61\u72ad\u68b5\u6535\u71d4\u7548\u8e6f", "fang": "\u574a\u82b3\u65b9\u80aa\u623f\u9632\u59a8\u4eff\u8bbf\u7eba\u653e\u531a\u90a1\u5f77\u94ab\u822b\u9c82", "fei": "\u83f2\u975e\u5561\u98de\u80a5\u532a\u8bfd\u5420\u80ba\u5e9f\u6cb8\u8d39\u82be\u72d2\u60b1\u6ddd\u5983\u7ecb\u7eef\u69a7\u8153\u6590\u6249\u7953\u7829\u9544\u75f1\u871a\u7bda\u7fe1\u970f\u9cb1", "fen": "\u82ac\u915a\u5429\u6c1b\u5206\u7eb7\u575f\u711a\u6c7e\u7c89\u594b\u4efd\u5fff\u6124\u7caa\u507e\u7035\u68fc\u610d\u9cbc\u9f22", "feng": "\u4e30\u5c01\u67ab\u8702\u5cf0\u950b\u98ce\u75af\u70fd\u9022\u51af\u7f1d\u8bbd\u5949\u51e4\u4ff8\u9146\u8451\u6ca3\u781c", "fu": "\u4f5b\u5426\u592b\u6577\u80a4\u5b75\u6276\u62c2\u8f90\u5e45\u6c1f\u7b26\u4f0f\u4fd8\u670d\u6d6e\u6daa\u798f\u88b1\u5f17\u752b\u629a\u8f85\u4fef\u91dc\u65a7\u812f\u8151\u5e9c\u8150\u8d74\u526f\u8986\u8d4b\u590d\u5085\u4ed8\u961c\u7236\u8179\u8d1f\u5bcc\u8ba3\u9644\u5987\u7f1a\u5490\u5310\u51eb\u90db\u8299\u82fb\u832f\u83a9\u83d4\u544b\u5e5e\u6ecf\u8274\u5b5a\u9a78\u7ec2\u6874\u8d59\u9efb\u9efc\u7f58\u7a03\u99a5\u864d\u86a8\u8709\u8760\u876e\u9eb8\u8dba\u8dd7\u9cc6", "ga": "\u5676\u560e\u86e4\u5c2c\u5477\u5c15\u5c1c\u65ee\u9486", "gai": "\u8be5\u6539\u6982\u9499\u76d6\u6e89\u4e10\u9654\u5793\u6224\u8d45\u80f2", "gan": "\u5e72\u7518\u6746\u67d1\u7aff\u809d\u8d76\u611f\u79c6\u6562\u8d63\u5769\u82f7\u5c34\u64c0\u6cd4\u6de6\u6f89\u7ec0\u6a44\u65f0\u77f8\u75b3\u9150", "gang": "\u5188\u521a\u94a2\u7f38\u809b\u7eb2\u5c97\u6e2f\u6206\u7f61\u9883\u7b7b", "gong": "\u6760\u5de5\u653b\u529f\u606d\u9f9a\u4f9b\u8eac\u516c\u5bab\u5f13\u5de9\u6c5e\u62f1\u8d21\u5171\u857b\u5efe\u54a3\u73d9\u80b1\u86a3\u86e9\u89e5", "gao": "\u7bd9\u768b\u9ad8\u818f\u7f94\u7cd5\u641e\u9550\u7a3f\u544a\u777e\u8bf0\u90dc\u84bf\u85c1\u7f1f\u69d4\u69c1\u6772\u9506", "ge": "\u54e5\u6b4c\u6401\u6208\u9e3d\u80f3\u7599\u5272\u9769\u845b\u683c\u9601\u9694\u94ec\u4e2a\u5404\u9b32\u4ee1\u54ff\u5865\u55dd\u7ea5\u643f\u8188\u784c\u94ea\u9549\u88bc\u988c\u867c\u8238\u9abc\u9ac2", "gei": "\u7ed9", "gen": "\u6839\u8ddf\u4e98\u831b\u54cf\u826e", "geng": "\u8015\u66f4\u5e9a\u7fb9\u57c2\u803f\u6897\u54fd\u8d53\u9ca0", "gou": "\u94a9\u52fe\u6c9f\u82df\u72d7\u57a2\u6784\u8d2d\u591f\u4f5d\u8bdf\u5ca3\u9058\u5abe\u7f11\u89cf\u5f40\u9e32\u7b31\u7bdd\u97b2", "gu": "\u8f9c\u83c7\u5495\u7b8d\u4f30\u6cbd\u5b64\u59d1\u9f13\u53e4\u86ca\u9aa8\u8c37\u80a1\u6545\u987e\u56fa\u96c7\u560f\u8bc2\u83f0\u54cc\u5d2e\u6c69\u688f\u8f71\u726f\u727f\u80cd\u81cc\u6bc2\u77bd\u7f5f\u94b4\u9522\u74e0\u9e2a\u9e44\u75fc\u86c4\u9164\u89da\u9cb4\u9ab0\u9e58", "gua": "\u522e\u74dc\u5250\u5be1\u6302\u8902\u5366\u8bd6\u5471\u681d\u9e39", "guai": "\u4e56\u62d0\u602a\u54d9", "guan": "\u68fa\u5173\u5b98\u51a0\u89c2\u7ba1\u9986\u7f50\u60ef\u704c\u8d2f\u500c\u839e\u63bc\u6dab\u76e5\u9e73\u9ccf", "guang": "\u5149\u5e7f\u901b\u72b7\u6844\u80f1\u7592", "gui": "\u7470\u89c4\u572d\u7845\u5f52\u9f9f\u95fa\u8f68\u9b3c\u8be1\u7678\u6842\u67dc\u8dea\u8d35\u523d\u5326\u523f\u5e8b\u5b84\u59ab\u6867\u7085\u6677\u7688\u7c0b\u9c91\u9cdc", "gun": "\u8f8a\u6eda\u68cd\u4e28\u886e\u7ef2\u78d9\u9ca7", "guo": "\u9505\u90ed\u56fd\u679c\u88f9\u8fc7\u9998\u8803\u57da\u63b4\u5459\u56d7\u5e3c\u5d1e\u7313\u6901\u8662\u951e\u8052\u872e\u873e\u8748", "ha": "\u54c8", "hai": "\u9ab8\u5b69\u6d77\u6c26\u4ea5\u5bb3\u9a87\u54b4\u55e8\u988f\u91a2", "han": "\u9163\u61a8\u90af\u97e9\u542b\u6db5\u5bd2\u51fd\u558a\u7f55\u7ff0\u64bc\u634d\u65f1\u61be\u608d\u710a\u6c57\u6c49\u9097\u83e1\u6496\u961a\u701a\u6657\u7113\u9894\u86b6\u9f3e", "hen": "\u592f\u75d5\u5f88\u72e0\u6068", "hang": "\u676d\u822a\u6c86\u7ed7\u73e9\u6841", "hao": "\u58d5\u568e\u8c6a\u6beb\u90dd\u597d\u8017\u53f7\u6d69\u8585\u55e5\u5686\u6fe0\u704f\u660a\u7693\u98a2\u869d", "he": "\u5475\u559d\u8377\u83cf\u6838\u79be\u548c\u4f55\u5408\u76d2\u8c89\u9602\u6cb3\u6db8\u8d6b\u8910\u9e64\u8d3a\u8bc3\u52be\u58d1\u85ff\u55d1\u55ec\u9616\u76cd\u86b5\u7fee", "hei": "\u563f\u9ed1", "heng": "\u54fc\u4ea8\u6a2a\u8861\u6052\u8a07\u8605", "hong": "\u8f70\u54c4\u70d8\u8679\u9e3f\u6d2a\u5b8f\u5f18\u7ea2\u9ec9\u8ba7\u836d\u85a8\u95f3\u6cd3", "hou": "\u5589\u4faf\u7334\u543c\u539a\u5019\u540e\u5820\u5f8c\u9005\u760a\u7bcc\u7cc7\u9c8e\u9aba", "hu": "\u547c\u4e4e\u5ffd\u745a\u58f6\u846b\u80e1\u8774\u72d0\u7cca\u6e56\u5f27\u864e\u552c\u62a4\u4e92\u6caa\u6237\u51b1\u553f\u56eb\u5cb5\u7322\u6019\u60da\u6d52\u6ef9\u7425\u69f2\u8f77\u89f3\u70c0\u7173\u623d\u6248\u795c\u9e55\u9e71\u7b0f\u9190\u659b", "hua": "\u82b1\u54d7\u534e\u733e\u6ed1\u753b\u5212\u5316\u8bdd\u5290\u6d4d\u9a85\u6866\u94e7\u7a1e", "huai": "\u69d0\u5f8a\u6000\u6dee\u574f\u8fd8\u8e1d", "huan": "\u6b22\u73af\u6853\u7f13\u6362\u60a3\u5524\u75ea\u8c62\u7115\u6da3\u5ba6\u5e7b\u90c7\u5942\u57b8\u64d0\u571c\u6d39\u6d63\u6f36\u5bf0\u902d\u7f33\u953e\u9ca9\u9b1f", "huang": "\u8352\u614c\u9ec4\u78fa\u8757\u7c27\u7687\u51f0\u60f6\u714c\u6643\u5e4c\u604d\u8c0e\u968d\u5fa8\u6e5f\u6f62\u9051\u749c\u8093\u7640\u87e5\u7bc1\u9cc7", "hui": "\u7070\u6325\u8f89\u5fbd\u6062\u86d4\u56de\u6bc1\u6094\u6167\u5349\u60e0\u6666\u8d3f\u79fd\u4f1a\u70e9\u6c47\u8bb3\u8bf2\u7ed8\u8bd9\u8334\u835f\u8559\u54d5\u5599\u96b3\u6d04\u5f57\u7f0b\u73f2\u6656\u605a\u867a\u87ea\u9ebe", "hun": "\u8364\u660f\u5a5a\u9b42\u6d51\u6df7\u8be8\u9984\u960d\u6eb7\u7f17", "huo": "\u8c41\u6d3b\u4f19\u706b\u83b7\u6216\u60d1\u970d\u8d27\u7978\u6509\u56af\u5925\u94ac\u952a\u956c\u8020\u8816", "ji": "\u51fb\u573e\u57fa\u673a\u7578\u7a3d\u79ef\u7b95\u808c\u9965\u8ff9\u6fc0\u8ba5\u9e21\u59ec\u7ee9\u7f09\u5409\u6781\u68d8\u8f91\u7c4d\u96c6\u53ca\u6025\u75be\u6c72\u5373\u5ac9\u7ea7\u6324\u51e0\u810a\u5df1\u84df\u6280\u5180\u5b63\u4f0e\u796d\u5242\u60b8\u6d4e\u5bc4\u5bc2\u8ba1\u8bb0\u65e2\u5fcc\u9645\u5993\u7ee7\u7eaa\u5c45\u4e0c\u4e69\u525e\u4f76\u4f74\u8114\u58bc\u82a8\u82b0\u8401\u84ba\u857a\u638e\u53fd\u54ad\u54dc\u5527\u5c8c\u5d74\u6d0e\u5f50\u5c50\u9aa5\u757f\u7391\u696b\u6b9b\u621f\u6222\u8d4d\u89ca\u7284\u9f51\u77f6\u7f81\u5d47\u7a37\u7620\u7635\u866e\u7b08\u7b04\u66a8\u8dfb\u8dfd\u9701\u9c9a\u9cab\u9afb\u9e82", "jia": "\u5609\u67b7\u5939\u4f73\u5bb6\u52a0\u835a\u988a\u8d3e\u7532\u94be\u5047\u7a3c\u4ef7\u67b6\u9a7e\u5ac1\u4f3d\u90cf\u62ee\u5cac\u6d43\u8fe6\u73c8\u621b\u80db\u605d\u94d7\u9553\u75c2\u86f1\u7b33\u8888\u8dcf", "jian": "\u6b7c\u76d1\u575a\u5c16\u7b3a\u95f4\u714e\u517c\u80a9\u8270\u5978\u7f04\u8327\u68c0\u67ec\u78b1\u7877\u62e3\u6361\u7b80\u4fed\u526a\u51cf\u8350\u69db\u9274\u8df5\u8d31\u89c1\u952e\u7bad\u4ef6\u5065\u8230\u5251\u996f\u6e10\u6e85\u6da7\u5efa\u50ed\u8c0f\u8c2b\u83c5\u84b9\u641b\u56dd\u6e54\u8e47\u8b07\u7f23\u67a7\u67d9\u6957\u620b\u622c\u726e\u728d\u6bfd\u8171\u7751\u950f\u9e63\u88e5\u7b15\u7bb4\u7fe6\u8dbc\u8e3a\u9ca3\u97af", "jiang": "\u50f5\u59dc\u5c06\u6d46\u6c5f\u7586\u848b\u6868\u5956\u8bb2\u5320\u9171\u964d\u8333\u6d1a\u7edb\u7f30\u729f\u7913\u8029\u7ce8\u8c47", "jiao": "\u8549\u6912\u7901\u7126\u80f6\u4ea4\u90ca\u6d47\u9a84\u5a07\u56bc\u6405\u94f0\u77eb\u4fa5\u811a\u72e1\u89d2\u997a\u7f34\u7ede\u527f\u6559\u9175\u8f7f\u8f83\u53eb\u4f7c\u50ec\u832d\u6322\u564d\u5ce4\u5fbc\u59e3\u7e9f\u656b\u768e\u9e6a\u86df\u91ae\u8de4\u9c9b", "jie": "\u7a96\u63ed\u63a5\u7686\u79f8\u8857\u9636\u622a\u52ab\u8282\u6854\u6770\u6377\u776b\u7aed\u6d01\u7ed3\u89e3\u59d0\u6212\u85c9\u82a5\u754c\u501f\u4ecb\u75a5\u8beb\u5c4a\u5048\u8ba6\u8bd8\u5588\u55df\u736c\u5a55\u5b51\u6840\u7352\u78a3\u9534\u7596\u88b7\u9889\u86a7\u7faf\u9c92\u9ab1\u9aeb", "jin": "\u5dfe\u7b4b\u65a4\u91d1\u4eca\u6d25\u895f\u7d27\u9526\u4ec5\u8c28\u8fdb\u9773\u664b\u7981\u8fd1\u70ec\u6d78\u5c3d\u537a\u8369\u5807\u5664\u9991\u5ed1\u5997\u7f19\u747e\u69ff\u8d46\u89d0\u9485\u9513\u887f\u77dc", "jing": "\u52b2\u8346\u5162\u830e\u775b\u6676\u9cb8\u4eac\u60ca\u7cbe\u7cb3\u7ecf\u4e95\u8b66\u666f\u9888\u9759\u5883\u656c\u955c\u5f84\u75c9\u9756\u7adf\u7ade\u51c0\u522d\u5106\u9631\u83c1\u734d\u61ac\u6cfe\u8ff3\u5f2a\u5a67\u80bc\u80eb\u8148\u65cc", "jiong": "\u70af\u7a98\u5182\u8fe5\u6243", "jiu": "\u63ea\u7a76\u7ea0\u7396\u97ed\u4e45\u7078\u4e5d\u9152\u53a9\u6551\u65e7\u81fc\u8205\u548e\u5c31\u759a\u50e6\u557e\u9604\u67e9\u6855\u9e6b\u8d73\u9b0f", "ju": "\u97a0\u62d8\u72d9\u75bd\u9a79\u83ca\u5c40\u5480\u77e9\u4e3e\u6cae\u805a\u62d2\u636e\u5de8\u5177\u8ddd\u8e1e\u952f\u4ff1\u53e5\u60e7\u70ac\u5267\u5028\u8bb5\u82e3\u82f4\u8392\u63ac\u907d\u5c66\u741a\u67b8\u6910\u6998\u6989\u6a58\u728b\u98d3\u949c\u9514\u7aad\u88fe\u8d84\u91b5\u8e3d\u9f83\u96ce\u97ab", "juan": "\u6350\u9e43\u5a1f\u5026\u7737\u5377\u7ee2\u9104\u72f7\u6d93\u684a\u8832\u9529\u954c\u96bd", "jue": "\u6485\u652b\u6289\u6398\u5014\u7235\u89c9\u51b3\u8bc0\u7edd\u53a5\u5282\u8c32\u77cd\u8568\u5658\u5d1b\u7357\u5b53\u73cf\u6877\u6a5b\u721d\u9562\u8e76\u89d6", "jun": "\u5747\u83cc\u94a7\u519b\u541b\u5cfb\u4fca\u7ae3\u6d5a\u90e1\u9a8f\u6343\u72fb\u76b2\u7b60\u9e87", "ka": "\u5580\u5496\u5361\u4f67\u5494\u80e9", "ke": "\u54af\u5777\u82db\u67ef\u68f5\u78d5\u9897\u79d1\u58f3\u54b3\u53ef\u6e34\u514b\u523b\u5ba2\u8bfe\u5ca2\u606a\u6e98\u9a92\u7f02\u73c2\u8f72\u6c2a\u778c\u94b6\u75b4\u7aa0\u874c\u9ac1", "kai": "\u5f00\u63e9\u6977\u51ef\u6168\u5240\u57b2\u8488\u5ffe\u607a\u94e0\u950e", "kan": "\u520a\u582a\u52d8\u574e\u780d\u770b\u4f83\u51f5\u83b0\u83b6\u6221\u9f9b\u77b0", "kang": "\u5eb7\u6177\u7ce0\u625b\u6297\u4ea2\u7095\u5751\u4f09\u95f6\u94aa", "kao": "\u8003\u62f7\u70e4\u9760\u5c3b\u6832\u7292\u94d0", "ken": "\u80af\u5543\u57a6\u6073\u57a0\u88c9\u9880", "keng": "\u542d\u5fd0\u94ff", "kong": "\u7a7a\u6050\u5b54\u63a7\u5025\u5d06\u7b9c", "kou": "\u62a0\u53e3\u6263\u5bc7\u82a4\u853b\u53e9\u770d\u7b58", "ku": "\u67af\u54ed\u7a9f\u82e6\u9177\u5e93\u88e4\u5233\u5800\u55be\u7ed4\u9ab7", "kua": "\u5938\u57ae\u630e\u8de8\u80ef\u4f89", "kuai": "\u5757\u7b77\u4fa9\u5feb\u84af\u90d0\u8489\u72ef\u810d", "kuan": "\u5bbd\u6b3e\u9acb", "kuang": "\u5321\u7b50\u72c2\u6846\u77ff\u7736\u65f7\u51b5\u8bd3\u8bf3\u909d\u5739\u593c\u54d0\u7ea9\u8d36", "kui": "\u4e8f\u76d4\u5cbf\u7aa5\u8475\u594e\u9b41\u5080\u9988\u6127\u6e83\u9997\u532e\u5914\u9697\u63c6\u55b9\u559f\u609d\u6126\u9615\u9035\u668c\u777d\u8069\u8770\u7bd1\u81fe\u8dec", "kun": "\u5764\u6606\u6346\u56f0\u6083\u9603\u7428\u951f\u918c\u9cb2\u9ae1", "kuo": "\u62ec\u6269\u5ed3\u9614\u86de", "la": "\u5783\u62c9\u5587\u8721\u814a\u8fa3\u5566\u524c\u647a\u908b\u65ef\u782c\u760c", "lai": "\u83b1\u6765\u8d56\u5d03\u5f95\u6d9e\u6fd1\u8d49\u7750\u94fc\u765e\u7c41", "lan": "\u84dd\u5a6a\u680f\u62e6\u7bee\u9611\u5170\u6f9c\u8c30\u63fd\u89c8\u61d2\u7f06\u70c2\u6ee5\u5549\u5c9a\u61d4\u6f24\u6984\u6593\u7f71\u9567\u8934", "lang": "\u7405\u6994\u72fc\u5eca\u90ce\u6717\u6d6a\u83a8\u8497\u5577\u9606\u9512\u7a02\u8782", "lao": "\u635e\u52b3\u7262\u8001\u4f6c\u59e5\u916a\u70d9\u6d9d\u5520\u5d02\u6833\u94d1\u94f9\u75e8\u91aa", "le": "\u52d2\u4e50\u808b\u4ec2\u53fb\u561e\u6cd0\u9cd3", "lei": "\u96f7\u956d\u857e\u78ca\u7d2f\u5121\u5792\u64c2\u7c7b\u6cea\u7fb8\u8bd4\u837d\u54a7\u6f2f\u5ad8\u7f27\u6a91\u8012\u9179", "ling": "\u68f1\u51b7\u62ce\u73b2\u83f1\u96f6\u9f84\u94c3\u4f36\u7f9a\u51cc\u7075\u9675\u5cad\u9886\u53e6\u4ee4\u9143\u5844\u82d3\u5464\u56f9\u6ce0\u7eeb\u67c3\u68c2\u74f4\u8046\u86c9\u7fce\u9cae", "leng": "\u695e\u6123", "li": "\u5398\u68a8\u7281\u9ece\u7bf1\u72f8\u79bb\u6f13\u7406\u674e\u91cc\u9ca4\u793c\u8389\u8354\u540f\u6817\u4e3d\u5389\u52b1\u783e\u5386\u5229\u5088\u4f8b\u4fd0\u75e2\u7acb\u7c92\u6ca5\u96b6\u529b\u7483\u54e9\u4fea\u4fda\u90e6\u575c\u82c8\u8385\u84e0\u85dc\u6369\u5456\u5533\u55b1\u7301\u6ea7\u6fa7\u9026\u5a0c\u5ae0\u9a8a\u7f21\u73de\u67a5\u680e\u8f79\u623e\u783a\u8a48\u7f79\u9502\u9e42\u75a0\u75ac\u86ce\u870a\u8821\u7b20\u7be5\u7c9d\u91b4\u8dde\u96f3\u9ca1\u9ce2\u9ee7", "lian": "\u4fe9\u8054\u83b2\u8fde\u9570\u5ec9\u601c\u6d9f\u5e18\u655b\u8138\u94fe\u604b\u70bc\u7ec3\u631b\u8539\u5941\u6f4b\u6fc2\u5a08\u740f\u695d\u6b93\u81c1\u81a6\u88e2\u880a\u9ca2", "liang": "\u7cae\u51c9\u6881\u7cb1\u826f\u4e24\u8f86\u91cf\u667e\u4eae\u8c05\u589a\u690b\u8e09\u9753\u9b49", "liao": "\u64a9\u804a\u50da\u7597\u71ce\u5be5\u8fbd\u6f66\u4e86\u6482\u9563\u5ed6\u6599\u84fc\u5c25\u5639\u7360\u5bee\u7f2d\u948c\u9e69\u8022", "lie": "\u5217\u88c2\u70c8\u52a3\u730e\u51bd\u57d2\u6d0c\u8d94\u8e90\u9b23", "lin": "\u7433\u6797\u78f7\u9716\u4e34\u90bb\u9cde\u6dcb\u51db\u8d41\u541d\u853a\u5d99\u5eea\u9074\u6aa9\u8f9a\u77b5\u7cbc\u8e8f\u9e9f", "liu": "\u6e9c\u7409\u69b4\u786b\u998f\u7559\u5218\u7624\u6d41\u67f3\u516d\u62a1\u507b\u848c\u6cd6\u6d4f\u905b\u9a9d\u7efa\u65d2\u7198\u950d\u954f\u9e68\u938f", "long": "\u9f99\u804b\u5499\u7b3c\u7abf\u9686\u5784\u62e2\u9647\u5f04\u5785\u830f\u6cf7\u73d1\u680a\u80e7\u783b\u7643", "lou": "\u697c\u5a04\u6402\u7bd3\u6f0f\u964b\u55bd\u5d5d\u9542\u7618\u8027\u877c\u9ac5", "lu": "\u82a6\u5362\u9885\u5e90\u7089\u63b3\u5364\u864f\u9c81\u9e93\u788c\u9732\u8def\u8d42\u9e7f\u6f5e\u7984\u5f55\u9646\u622e\u5786\u6445\u64b8\u565c\u6cf8\u6e0c\u6f09\u7490\u680c\u6a79\u8f73\u8f82\u8f98\u6c07\u80ea\u9565\u9e2c\u9e6d\u7c0f\u823b\u9c88", "lv": "\u9a74\u5415\u94dd\u4fa3\u65c5\u5c65\u5c61\u7f15\u8651\u6c2f\u5f8b\u7387\u6ee4\u7eff\u634b\u95fe\u6988\u8182\u7a06\u891b", "luan": "\u5ce6\u5b6a\u6ee6\u5375\u4e71\u683e\u9e3e\u92ae", "lue": "\u63a0\u7565\u950a", "lun": "\u8f6e\u4f26\u4ed1\u6ca6\u7eb6\u8bba\u56f5", "luo": "\u841d\u87ba\u7f57\u903b\u9523\u7ba9\u9aa1\u88f8\u843d\u6d1b\u9a86\u7edc\u502e\u8366\u645e\u7321\u6cfa\u6924\u8136\u9559\u7630\u96d2", "ma": "\u5988\u9ebb\u739b\u7801\u8682\u9a6c\u9a82\u561b\u5417\u551b\u72b8\u5b37\u6769\u9ebd", "mai": "\u57cb\u4e70\u9ea6\u5356\u8fc8\u8109\u52a2\u836c\u54aa\u973e", "man": "\u7792\u9992\u86ee\u6ee1\u8513\u66fc\u6162\u6f2b\u8c29\u5881\u5e54\u7f26\u71b3\u9558\u989f\u87a8\u9cd7\u9794", "mang": "\u8292\u832b\u76f2\u5fd9\u83bd\u9099\u6f2d\u6726\u786d\u87d2", "meng": "\u6c13\u840c\u8499\u6aac\u76df\u9530\u731b\u68a6\u5b5f\u52d0\u750d\u77a2\u61f5\u791e\u867b\u8722\u8813\u824b\u8268\u9efe", "miao": "\u732b\u82d7\u63cf\u7784\u85d0\u79d2\u6e3a\u5e99\u5999\u55b5\u9088\u7f08\u7f2a\u676a\u6dfc\u7707\u9e4b\u8731", "mao": "\u8305\u951a\u6bdb\u77db\u94c6\u536f\u8302\u5192\u5e3d\u8c8c\u8d38\u4f94\u88a4\u52d6\u8306\u5cc1\u7441\u6634\u7266\u8004\u65c4\u61cb\u7780\u86d1\u8765\u87ca\u9ae6", "me": "\u4e48", "mei": "\u73ab\u679a\u6885\u9176\u9709\u7164\u6ca1\u7709\u5a92\u9541\u6bcf\u7f8e\u6627\u5bd0\u59b9\u5a9a\u5776\u8393\u5d4b\u7338\u6d7c\u6e44\u6963\u9545\u9e5b\u8882\u9b45", "men": "\u95e8\u95f7\u4eec\u626a\u739f\u7116\u61d1\u9494", "mi": "\u772f\u919a\u9761\u7cdc\u8ff7\u8c1c\u5f25\u7c73\u79d8\u89c5\u6ccc\u871c\u5bc6\u5e42\u8288\u5196\u8c27\u863c\u5627\u7315\u736f\u6c68\u5b93\u5f2d\u8112\u6549\u7cf8\u7e3b\u9e8b", "mian": "\u68c9\u7720\u7ef5\u5195\u514d\u52c9\u5a29\u7f05\u9762\u6c94\u6e4e\u817c\u7704", "mie": "\u8511\u706d\u54a9\u881b\u7bfe", "min": "\u6c11\u62bf\u76bf\u654f\u60af\u95fd\u82e0\u5cb7\u95f5\u6cef\u73c9", "ming": "\u660e\u879f\u9e23\u94ed\u540d\u547d\u51a5\u8317\u6e9f\u669d\u7791\u9169", "miu": "\u8c2c", "mo": "\u6478\u6479\u8611\u6a21\u819c\u78e8\u6469\u9b54\u62b9\u672b\u83ab\u58a8\u9ed8\u6cab\u6f20\u5bde\u964c\u8c1f\u8309\u84e6\u998d\u5aeb\u9546\u79e3\u763c\u8031\u87c6\u8c8a\u8c98", "mou": "\u8c0b\u725f\u67d0\u53b6\u54de\u5a7a\u7738\u936a", "mu": "\u62c7\u7261\u4ea9\u59c6\u6bcd\u5893\u66ae\u5e55\u52df\u6155\u6728\u76ee\u7766\u7267\u7a46\u4eeb\u82dc\u5452\u6c90\u6bea\u94bc", "na": "\u62ff\u54ea\u5450\u94a0\u90a3\u5a1c\u7eb3\u5185\u637a\u80ad\u954e\u8872\u7bac", "nai": "\u6c16\u4e43\u5976\u8010\u5948\u9f10\u827f\u8418\u67f0", "nan": "\u5357\u7537\u96be\u56ca\u5583\u56e1\u6960\u8169\u877b\u8d67", "nao": "\u6320\u8111\u607c\u95f9\u5b6c\u57b4\u7331\u7459\u7847\u94d9\u86f2", "ne": "\u6dd6\u5462\u8bb7", "nei": "\u9981", "nen": "\u5ae9\u80fd\u6798\u6041", "ni": "\u59ae\u9713\u502a\u6ce5\u5c3c\u62df\u4f60\u533f\u817b\u9006\u6eba\u4f32\u576d\u730a\u6029\u6ee0\u6635\u65ce\u7962\u615d\u7768\u94cc\u9cb5", "nian": "\u852b\u62c8\u5e74\u78be\u64b5\u637b\u5ff5\u5eff\u8f87\u9ecf\u9c87\u9cb6", "niang": "\u5a18\u917f", "niao": "\u9e1f\u5c3f\u8311\u5b32\u8132\u8885", "nie": "\u634f\u8042\u5b7d\u556e\u954a\u954d\u6d85\u4e5c\u9667\u8616\u55eb\u8080\u989e\u81ec\u8e51", "nin": "\u60a8\u67e0", "ning": "\u72de\u51dd\u5b81\u62e7\u6cde\u4f5e\u84e5\u549b\u752f\u804d", "niu": "\u725b\u626d\u94ae\u7ebd\u72c3\u5ff8\u599e\u86b4", "nong": "\u8113\u6d53\u519c\u4fac", "nu": "\u5974\u52aa\u6012\u5476\u5e11\u5f29\u80ec\u5b65\u9a7d", "nv": "\u5973\u6067\u9495\u8844", "nuan": "\u6696", "nuenue": "\u8650", "nue": "\u759f\u8c11", "nuo": "\u632a\u61e6\u7cef\u8bfa\u50a9\u6426\u558f\u9518", "ou": "\u54e6\u6b27\u9e25\u6bb4\u85d5\u5455\u5076\u6ca4\u6004\u74ef\u8026", "pa": "\u556a\u8db4\u722c\u5e15\u6015\u7436\u8469\u7b62", "pai": "\u62cd\u6392\u724c\u5f98\u6e43\u6d3e\u4ff3\u848e", "pan": "\u6500\u6f58\u76d8\u78d0\u76fc\u7554\u5224\u53db\u723f\u6cee\u88a2\u897b\u87e0\u8e52", "pang": "\u4e53\u5e9e\u65c1\u802a\u80d6\u6ec2\u9004", "pao": "\u629b\u5486\u5228\u70ae\u888d\u8dd1\u6ce1\u530f\u72cd\u5e96\u812c\u75b1", "pei": "\u5478\u80da\u57f9\u88f4\u8d54\u966a\u914d\u4f69\u6c9b\u638a\u8f94\u5e14\u6de0\u65c6\u952b\u9185\u9708", "pen": "\u55b7\u76c6\u6e53", "peng": "\u7830\u62a8\u70f9\u6f8e\u5f6d\u84ec\u68da\u787c\u7bf7\u81a8\u670b\u9e4f\u6367\u78b0\u576f\u580b\u562d\u6026\u87db", "pi": "\u7812\u9739\u6279\u62ab\u5288\u7435\u6bd7\u5564\u813e\u75b2\u76ae\u5339\u75de\u50fb\u5c41\u8b6c\u4e15\u9674\u90b3\u90eb\u572e\u9f19\u64d7\u567c\u5e80\u5ab2\u7eb0\u6787\u7513\u7765\u7f74\u94cd\u75e6\u7656\u758b\u868d\u8c94", "pian": "\u7bc7\u504f\u7247\u9a97\u8c1d\u9a88\u728f\u80fc\u890a\u7fe9\u8e41", "piao": "\u98d8\u6f02\u74e2\u7968\u527d\u560c\u5ad6\u7f25\u6b8d\u779f\u87b5", "pie": "\u6487\u77a5\u4e3f\u82e4\u6c15", "pin": "\u62fc\u9891\u8d2b\u54c1\u8058\u62da\u59d8\u5ad4\u6980\u725d\u98a6", "ping": "\u4e52\u576a\u82f9\u840d\u5e73\u51ed\u74f6\u8bc4\u5c4f\u4fdc\u5a09\u67b0\u9c86", "po": "\u5761\u6cfc\u9887\u5a46\u7834\u9b44\u8feb\u7c95\u53f5\u9131\u6ea5\u73c0\u948b\u94b7\u76a4\u7b38", "pou": "\u5256\u88d2\u8e23", "pu": "\u6251\u94fa\u4ec6\u8386\u8461\u83e9\u84b2\u57d4\u6734\u5703\u666e\u6d66\u8c31\u66dd\u7011\u530d\u5657\u6fee\u749e\u6c06\u9564\u9568\u8e7c", "qi": "\u671f\u6b3a\u6816\u621a\u59bb\u4e03\u51c4\u6f06\u67d2\u6c8f\u5176\u68cb\u5947\u6b67\u7566\u5d0e\u8110\u9f50\u65d7\u7948\u7941\u9a91\u8d77\u5c82\u4e5e\u4f01\u542f\u5951\u780c\u5668\u6c14\u8fc4\u5f03\u6c7d\u6ce3\u8bab\u4e9f\u4e93\u573b\u8291\u840b\u847a\u5601\u5c7a\u5c90\u6c54\u6dc7\u9a90\u7eee\u742a\u7426\u675e\u6864\u69ed\u6b39\u797a\u61a9\u789b\u86f4\u871e\u7da6\u7dae\u8dbf\u8e4a\u9ccd\u9e92", "qia": "\u6390\u6070\u6d3d\u845c", "qian": "\u7275\u6266\u948e\u94c5\u5343\u8fc1\u7b7e\u4edf\u8c26\u4e7e\u9ed4\u94b1\u94b3\u524d\u6f5c\u9063\u6d45\u8c34\u5811\u5d4c\u6b20\u6b49\u4f65\u9621\u828a\u82a1\u8368\u63ae\u5c8d\u60ad\u614a\u9a9e\u6434\u8930\u7f31\u6920\u80b7\u6106\u94a4\u8654\u7b9d", "qiang": "\u67aa\u545b\u8154\u7f8c\u5899\u8537\u5f3a\u62a2\u5af1\u6a2f\u6217\u709d\u9516\u9535\u956a\u8941\u8723\u7f9f\u8deb\u8dc4", "qiao": "\u6a47\u9539\u6572\u6084\u6865\u77a7\u4e54\u4fa8\u5de7\u9798\u64ac\u7fd8\u5ced\u4fcf\u7a8d\u5281\u8bee\u8c2f\u835e\u6100\u6194\u7f32\u6a35\u6bf3\u7857\u8df7\u9792", "qie": "\u5207\u8304\u4e14\u602f\u7a83\u90c4\u553c\u60ec\u59be\u6308\u9532\u7ba7", "qin": "\u94a6\u4fb5\u4eb2\u79e6\u7434\u52e4\u82b9\u64d2\u79bd\u5bdd\u6c81\u82a9\u84c1\u8572\u63ff\u5423\u55ea\u5659\u6eb1\u6a8e\u8793\u887e", "qing": "\u9752\u8f7b\u6c22\u503e\u537f\u6e05\u64ce\u6674\u6c30\u60c5\u9877\u8bf7\u5e86\u5029\u82d8\u570a\u6aa0\u78ec\u873b\u7f44\u7b90\u8b26\u9cad\u9ee5", "qiong": "\u743c\u7a77\u909b\u8315\u7a79\u7b47\u928e", "qiu": "\u79cb\u4e18\u90b1\u7403\u6c42\u56da\u914b\u6cc5\u4fc5\u6c3d\u5def\u827d\u72b0\u6e6b\u9011\u9052\u6978\u8d47\u9e20\u866c\u86af\u8764\u88d8\u7cd7\u9cc5\u9f3d", "qu": "\u8d8b\u533a\u86c6\u66f2\u8eaf\u5c48\u9a71\u6e20\u53d6\u5a36\u9f8b\u8da3\u53bb\u8bce\u52ac\u8556\u8627\u5c96\u8862\u9612\u74a9\u89d1\u6c0d\u795b\u78f2\u766f\u86d0\u883c\u9eb4\u77bf\u9ee2", "quan": "\u5708\u98a7\u6743\u919b\u6cc9\u5168\u75ca\u62f3\u72ac\u5238\u529d\u8be0\u8343\u737e\u609b\u7efb\u8f81\u754e\u94e8\u8737\u7b4c\u9b08", "que": "\u7f3a\u7094\u7638\u5374\u9e4a\u69b7\u786e\u96c0\u9619\u60ab", "qun": "\u88d9\u7fa4\u9021", "ran": "\u7136\u71c3\u5189\u67d3\u82d2\u9aef", "rang": "\u74e4\u58e4\u6518\u56b7\u8ba9\u79b3\u7a70", "rao": "\u9976\u6270\u7ed5\u835b\u5a06\u6861", "ruo": "\u60f9\u82e5\u5f31", "re": "\u70ed\u504c", "ren": "\u58ec\u4ec1\u4eba\u5fcd\u97e7\u4efb\u8ba4\u5203\u598a\u7eab\u4ede\u834f\u845a\u996a\u8f6b\u7a14\u887d", "reng": "\u6254\u4ecd", "ri": "\u65e5", "rong": "\u620e\u8338\u84c9\u8363\u878d\u7194\u6eb6\u5bb9\u7ed2\u5197\u5d58\u72e8\u7f1b\u6995\u877e", "rou": "\u63c9\u67d4\u8089\u7cc5\u8e42\u97a3", "ru": "\u8339\u8815\u5112\u5b7a\u5982\u8fb1\u4e73\u6c5d\u5165\u8925\u84d0\u85b7\u5685\u6d33\u6ebd\u6fe1\u94f7\u8966\u98a5", "ruan": "\u8f6f\u962e\u670a", "rui": "\u854a\u745e\u9510\u82ae\u8564\u777f\u868b", "run": "\u95f0\u6da6", "sa": "\u6492\u6d12\u8428\u5345\u4ee8\u6332\u98d2", "sai": "\u816e\u9cc3\u585e\u8d5b\u567b", "san": "\u4e09\u53c1\u4f1e\u6563\u5f61\u9993\u6c35\u6bf5\u7cc1\u9730", "sang": "\u6851\u55d3\u4e27\u6421\u78c9\u98a1", "sao": "\u6414\u9a9a\u626b\u5ac2\u57fd\u81ca\u7619\u9ccb", "se": "\u745f\u8272\u6da9\u556c\u94e9\u94ef\u7a51", "sen": "\u68ee", "seng": "\u50e7", "sha": "\u838e\u7802\u6740\u5239\u6c99\u7eb1\u50bb\u5565\u715e\u810e\u6b43\u75e7\u88df\u970e\u9ca8", "shai": "\u7b5b\u6652\u917e", "shan": "\u73ca\u82eb\u6749\u5c71\u5220\u717d\u886b\u95ea\u9655\u64c5\u8d61\u81b3\u5584\u6c55\u6247\u7f2e\u5261\u8baa\u912f\u57cf\u829f\u6f78\u59d7\u9a9f\u81bb\u9490\u759d\u87ee\u8222\u8dda\u9cdd", "shang": "\u5892\u4f24\u5546\u8d4f\u664c\u4e0a\u5c1a\u88f3\u57a7\u7ef1\u6b87\u71b5\u89de", "shao": "\u68a2\u634e\u7a0d\u70e7\u828d\u52fa\u97f6\u5c11\u54e8\u90b5\u7ecd\u52ad\u82d5\u6f72\u86f8\u7b24\u7b72\u8244", "she": "\u5962\u8d4a\u86c7\u820c\u820d\u8d66\u6444\u5c04\u6151\u6d89\u793e\u8bbe\u538d\u4f58\u731e\u7572\u9e9d", "shen": "\u7837\u7533\u547b\u4f38\u8eab\u6df1\u5a20\u7ec5\u795e\u6c88\u5ba1\u5a76\u751a\u80be\u614e\u6e17\u8bdc\u8c02\u5432\u54c2\u6e16\u6939\u77e7\u8703", "sheng": "\u58f0\u751f\u7525\u7272\u5347\u7ef3\u7701\u76db\u5269\u80dc\u5723\u4e1e\u6e11\u5ab5\u771a\u7b19", "shi": "\u5e08\u5931\u72ee\u65bd\u6e7f\u8bd7\u5c38\u8671\u5341\u77f3\u62fe\u65f6\u4ec0\u98df\u8680\u5b9e\u8bc6\u53f2\u77e2\u4f7f\u5c4e\u9a76\u59cb\u5f0f\u793a\u58eb\u4e16\u67ff\u4e8b\u62ed\u8a93\u901d\u52bf\u662f\u55dc\u566c\u9002\u4ed5\u4f8d\u91ca\u9970\u6c0f\u5e02\u6043\u5ba4\u89c6\u8bd5\u8c25\u57d8\u83b3\u84cd\u5f11\u5511\u9963\u8f7c\u8006\u8d33\u70bb\u793b\u94c8\u94ca\u87ab\u8210\u7b6e\u8c55\u9ca5\u9cba", "shou": "\u6536\u624b\u9996\u5b88\u5bff\u6388\u552e\u53d7\u7626\u517d\u624c\u72e9\u7ef6\u824f", "shu": "\u852c\u67a2\u68b3\u6b8a\u6292\u8f93\u53d4\u8212\u6dd1\u758f\u4e66\u8d4e\u5b70\u719f\u85af\u6691\u66d9\u7f72\u8700\u9ecd\u9f20\u5c5e\u672f\u8ff0\u6811\u675f\u620d\u7ad6\u5885\u5eb6\u6570\u6f31\u6055\u500f\u587e\u83fd\u5fc4\u6cad\u6d91\u6f8d\u59dd\u7ebe\u6bf9\u8167\u6bb3\u956f\u79eb\u9e6c", "shua": "\u5237\u800d\u5530\u6dae", "shuai": "\u6454\u8870\u7529\u5e05\u87c0", "shuan": "\u6813\u62f4\u95e9", "shuang": "\u971c\u53cc\u723d\u5b40", "shui": "\u8c01\u6c34\u7761\u7a0e", "shun": "\u542e\u77ac\u987a\u821c\u6042", "shuo": "\u8bf4\u7855\u6714\u70c1\u84b4\u6420\u55cd\u6fef\u5981\u69ca\u94c4", "si": "\u65af\u6495\u5636\u601d\u79c1\u53f8\u4e1d\u6b7b\u8086\u5bfa\u55e3\u56db\u4f3a\u4f3c\u9972\u5df3\u53ae\u4fdf\u5155\u83e5\u549d\u6c5c\u6cd7\u6f8c\u59d2\u9a77\u7f0c\u7940\u7960\u9536\u9e36\u801c\u86f3\u7b25", "song": "\u677e\u8038\u6002\u9882\u9001\u5b8b\u8bbc\u8bf5\u51c7\u83d8\u5d27\u5d69\u5fea\u609a\u6dde\u7ae6", "sou": "\u641c\u8258\u64de\u55fd\u53df\u55d6\u55fe\u998a\u6eb2\u98d5\u778d\u953c\u878b", "su": "\u82cf\u9165\u4fd7\u7d20\u901f\u7c9f\u50f3\u5851\u6eaf\u5bbf\u8bc9\u8083\u5919\u8c21\u850c\u55c9\u612b\u7c0c\u89eb\u7a23", "suan": "\u9178\u849c\u7b97", "sui": "\u867d\u968b\u968f\u7ee5\u9ad3\u788e\u5c81\u7a57\u9042\u96a7\u795f\u84d1\u51ab\u8c07\u6fc9\u9083\u71e7\u772d\u7762", "sun": "\u5b59\u635f\u7b0b\u836a\u72f2\u98e7\u69ab\u8de3\u96bc", "suo": "\u68ad\u5506\u7f29\u7410\u7d22\u9501\u6240\u5522\u55e6\u5a11\u686b\u7743\u7fa7", "ta": "\u584c\u4ed6\u5b83\u5979\u5854\u736d\u631e\u8e4b\u8e0f\u95fc\u6ebb\u9062\u69bb\u6c93", "tai": "\u80ce\u82d4\u62ac\u53f0\u6cf0\u915e\u592a\u6001\u6c70\u90b0\u85b9\u80bd\u70b1\u949b\u8dc6\u9c90", "tan": "\u574d\u644a\u8d2a\u762b\u6ee9\u575b\u6a80\u75f0\u6f6d\u8c2d\u8c08\u5766\u6bef\u8892\u78b3\u63a2\u53f9\u70ad\u90ef\u8548\u6619\u94bd\u952c\u8983", "tang": "\u6c64\u5858\u642a\u5802\u68e0\u819b\u5510\u7cd6\u50a5\u9967\u6e8f\u746d\u94f4\u9557\u8025\u8797\u87b3\u7fb0\u91a3", "thang": "\u5018\u8eba\u6dcc", "theng": "\u8d9f\u70eb", "tao": "\u638f\u6d9b\u6ed4\u7ee6\u8404\u6843\u9003\u6dd8\u9676\u8ba8\u5957\u6311\u9f17\u5555\u97ec\u9955", "te": "\u7279", "teng": "\u85e4\u817e\u75bc\u8a8a\u6ed5", "ti": "\u68af\u5254\u8e22\u9511\u63d0\u9898\u8e44\u557c\u4f53\u66ff\u568f\u60d5\u6d95\u5243\u5c49\u8351\u608c\u9016\u7ee8\u7f07\u9e48\u88fc\u918d", "tian": "\u5929\u6dfb\u586b\u7530\u751c\u606c\u8214\u8146\u63ad\u5fdd\u9617\u6b84\u754b\u94bf\u86ba", "tiao": "\u6761\u8fe2\u773a\u8df3\u4f7b\u7967\u94eb\u7a95\u9f86\u9ca6", "tie": "\u8d34\u94c1\u5e16\u841c\u992e", "ting": "\u5385\u542c\u70c3\u6c40\u5ef7\u505c\u4ead\u5ead\u633a\u8247\u839b\u8476\u5a77\u6883\u8713\u9706", "tong": "\u901a\u6850\u916e\u77b3\u540c\u94dc\u5f64\u7ae5\u6876\u6345\u7b52\u7edf\u75db\u4f5f\u50ee\u4edd\u833c\u55f5\u6078\u6f7c\u783c", "tou": "\u5077\u6295\u5934\u900f\u4ea0", "tu": "\u51f8\u79c3\u7a81\u56fe\u5f92\u9014\u6d82\u5c60\u571f\u5410\u5154\u580d\u837c\u83df\u948d\u9174", "tuan": "\u6e4d\u56e2\u7583", "tui": "\u63a8\u9893\u817f\u8715\u892a\u9000\u5fd2\u717a", "tun": "\u541e\u5c6f\u81c0\u9968\u66be\u8c5a\u7a80", "tuo": "\u62d6\u6258\u8131\u9e35\u9640\u9a6e\u9a7c\u692d\u59a5\u62d3\u553e\u4e47\u4f57\u5768\u5eb9\u6cb1\u67dd\u7823\u7ba8\u8204\u8dce\u9f0d", "wa": "\u6316\u54c7\u86d9\u6d3c\u5a03\u74e6\u889c\u4f64\u5a32\u817d", "wai": "\u6b6a\u5916", "wan": "\u8c4c\u5f2f\u6e7e\u73a9\u987d\u4e38\u70f7\u5b8c\u7897\u633d\u665a\u7696\u60cb\u5b9b\u5a49\u4e07\u8155\u525c\u8284\u82cb\u83c0\u7ea8\u7efe\u742c\u8118\u7579\u873f\u7ba2", "wang": "\u6c6a\u738b\u4ea1\u6789\u7f51\u5f80\u65fa\u671b\u5fd8\u5984\u7f54\u5c22\u60d8\u8f8b\u9b4d", "wei": "\u5a01\u5dcd\u5fae\u5371\u97e6\u8fdd\u6845\u56f4\u552f\u60df\u4e3a\u6f4d\u7ef4\u82c7\u840e\u59d4\u4f1f\u4f2a\u5c3e\u7eac\u672a\u851a\u5473\u754f\u80c3\u5582\u9b4f\u4f4d\u6e2d\u8c13\u5c09\u6170\u536b\u502d\u504e\u8bff\u9688\u8473\u8587\u5e0f\u5e37\u5d34\u5d6c\u7325\u732c\u95f1\u6ca9\u6d27\u6da0\u9036\u5a13\u73ae\u97ea\u8ece\u709c\u7168\u71a8\u75ff\u8249\u9c94", "wen": "\u761f\u6e29\u868a\u6587\u95fb\u7eb9\u543b\u7a33\u7d0a\u95ee\u520e\u6120\u960c\u6c76\u74ba\u97eb\u6b81\u96ef", "weng": "\u55e1\u7fc1\u74ee\u84ca\u8579", "wo": "\u631d\u8717\u6da1\u7a9d\u6211\u65a1\u5367\u63e1\u6c83\u83b4\u5e44\u6e25\u674c\u809f\u9f8c", "wu": "\u5deb\u545c\u94a8\u4e4c\u6c61\u8bec\u5c4b\u65e0\u829c\u68a7\u543e\u5434\u6bcb\u6b66\u4e94\u6342\u5348\u821e\u4f0d\u4fae\u575e\u620a\u96fe\u6664\u7269\u52ff\u52a1\u609f\u8bef\u5140\u4ef5\u9622\u90ac\u572c\u82b4\u5e91\u6003\u5fe4\u6d6f\u5be4\u8fd5\u59a9\u9a9b\u727e\u7110\u9e49\u9e5c\u8708\u92c8\u9f2f", "xi": "\u6614\u7199\u6790\u897f\u7852\u77fd\u6670\u563b\u5438\u9521\u727a\u7a00\u606f\u5e0c\u6089\u819d\u5915\u60dc\u7184\u70ef\u6eaa\u6c50\u7280\u6a84\u88ad\u5e2d\u4e60\u5ab3\u559c\u94e3\u6d17\u7cfb\u9699\u620f\u7ec6\u50d6\u516e\u96b0\u90d7\u831c\u8478\u84f0\u595a\u550f\u5f99\u9969\u960b\u6d60\u6dc5\u5c63\u5b09\u73ba\u6a28\u66e6\u89cb\u6b37\u71b9\u798a\u79a7\u94b8\u7699\u7a78\u8725\u87cb\u823e\u7fb2\u7c9e\u7fd5\u91af\u9f37", "xia": "\u778e\u867e\u5323\u971e\u8f96\u6687\u5ce1\u4fa0\u72ed\u4e0b\u53a6\u590f\u5413\u6380\u846d\u55c4\u72ce\u9050\u7455\u7856\u7615\u7f45\u9ee0", "xian": "\u9528\u5148\u4ed9\u9c9c\u7ea4\u54b8\u8d24\u8854\u8237\u95f2\u6d8e\u5f26\u5acc\u663e\u9669\u73b0\u732e\u53bf\u817a\u9985\u7fa1\u5baa\u9677\u9650\u7ebf\u51bc\u85d3\u5c98\u7303\u66b9\u5a34\u6c19\u7946\u9e47\u75eb\u86ac\u7b45\u7c7c\u9170\u8df9", "xiang": "\u76f8\u53a2\u9576\u9999\u7bb1\u8944\u6e58\u4e61\u7fd4\u7965\u8be6\u60f3\u54cd\u4eab\u9879\u5df7\u6a61\u50cf\u5411\u8c61\u8297\u8459\u9977\u5ea0\u9aa7\u7f03\u87d3\u9c9e\u98e8", "xiao": "\u8427\u785d\u9704\u524a\u54ee\u56a3\u9500\u6d88\u5bb5\u6dc6\u6653\u5c0f\u5b5d\u6821\u8096\u5578\u7b11\u6548\u54d3\u54bb\u5d24\u6f47\u900d\u9a81\u7ee1\u67ad\u67b5\u7b71\u7bab\u9b48", "xie": "\u6954\u4e9b\u6b47\u874e\u978b\u534f\u631f\u643a\u90aa\u659c\u80c1\u8c10\u5199\u68b0\u5378\u87f9\u61c8\u6cc4\u6cfb\u8c22\u5c51\u5055\u4eb5\u52f0\u71ee\u85a4\u64b7\u5ee8\u7023\u9082\u7ec1\u7f2c\u69ad\u698d\u6b59\u8e9e", "xin": "\u85aa\u82af\u950c\u6b23\u8f9b\u65b0\u5ffb\u5fc3\u4fe1\u8845\u56df\u99a8\u8398\u6b46\u94fd\u946b", "xing": "\u661f\u8165\u7329\u60fa\u5174\u5211\u578b\u5f62\u90a2\u884c\u9192\u5e78\u674f\u6027\u59d3\u9649\u8347\u8365\u64e4\u60bb\u784e", "xiong": "\u5144\u51f6\u80f8\u5308\u6c79\u96c4\u718a\u828e", "xiu": "\u4f11\u4fee\u7f9e\u673d\u55c5\u9508\u79c0\u8896\u7ee3\u83a0\u5cab\u9990\u5ea5\u9e3a\u8c85\u9af9", "xu": "\u589f\u620c\u9700\u865a\u5618\u987b\u5f90\u8bb8\u84c4\u9157\u53d9\u65ed\u5e8f\u755c\u6064\u7d6e\u5a7f\u7eea\u7eed\u8bb4\u8be9\u5729\u84ff\u6035\u6d2b\u6e86\u987c\u6829\u7166\u7809\u76f1\u80e5\u7cc8\u9191", "xuan": "\u8f69\u55a7\u5ba3\u60ac\u65cb\u7384\u9009\u7663\u7729\u7eda\u5107\u8c16\u8431\u63ce\u9994\u6ceb\u6d35\u6e32\u6f29\u7487\u6966\u6684\u70ab\u714a\u78b9\u94c9\u955f\u75c3", "xue": "\u9774\u859b\u5b66\u7a74\u96ea\u8840\u5671\u6cf6\u9cd5", "xun": "\u52cb\u718f\u5faa\u65ec\u8be2\u5bfb\u9a6f\u5de1\u6b89\u6c5b\u8bad\u8baf\u900a\u8fc5\u5dfd\u57d9\u8340\u85b0\u5ccb\u5f87\u6d54\u66db\u7aa8\u91ba\u9c9f", "ya": "\u538b\u62bc\u9e26\u9e2d\u5440\u4e2b\u82bd\u7259\u869c\u5d16\u8859\u6daf\u96c5\u54d1\u4e9a\u8bb6\u4f22\u63e0\u5416\u5c88\u8fd3\u5a05\u740a\u6860\u6c29\u7811\u775a\u75d6", "yan": "\u7109\u54bd\u9609\u70df\u6df9\u76d0\u4e25\u7814\u8712\u5ca9\u5ef6\u8a00\u989c\u960e\u708e\u6cbf\u5944\u63a9\u773c\u884d\u6f14\u8273\u5830\u71d5\u538c\u781a\u96c1\u5501\u5f66\u7130\u5bb4\u8c1a\u9a8c\u53a3\u9765\u8d5d\u4fe8\u5043\u5156\u8ba0\u8c33\u90fe\u9122\u82ab\u83f8\u5d26\u6079\u95eb\u960f\u6d07\u6e6e\u6edf\u598d\u5ae3\u7430\u664f\u80ed\u814c\u7131\u7f68\u7b75\u917d\u9b47\u990d\u9f39", "yang": "\u6b83\u592e\u9e2f\u79e7\u6768\u626c\u4f6f\u75a1\u7f8a\u6d0b\u9633\u6c27\u4ef0\u75d2\u517b\u6837\u6f3e\u5f89\u600f\u6cf1\u7080\u70ca\u6059\u86d8\u9785", "yao": "\u9080\u8170\u5996\u7476\u6447\u5c27\u9065\u7a91\u8c23\u59da\u54ac\u8200\u836f\u8981\u8000\u592d\u723b\u5406\u5d3e\u5fad\u7039\u5e7a\u73e7\u6773\u66dc\u80b4\u9e5e\u7a88\u7e47\u9cd0", "ye": "\u6930\u564e\u8036\u7237\u91ce\u51b6\u4e5f\u9875\u6396\u4e1a\u53f6\u66f3\u814b\u591c\u6db2\u8c12\u90ba\u63f6\u9980\u6654\u70e8\u94d8", "yi": "\u4e00\u58f9\u533b\u63d6\u94f1\u4f9d\u4f0a\u8863\u9890\u5937\u9057\u79fb\u4eea\u80f0\u7591\u6c82\u5b9c\u59e8\u5f5d\u6905\u8681\u501a\u5df2\u4e59\u77e3\u4ee5\u827a\u6291\u6613\u9091\u5c79\u4ebf\u5f79\u81c6\u9038\u8084\u75ab\u4ea6\u88d4\u610f\u6bc5\u5fc6\u4e49\u76ca\u6ea2\u8be3\u8bae\u8c0a\u8bd1\u5f02\u7ffc\u7fcc\u7ece\u5208\u5293\u4f7e\u8bd2\u572a\u572f\u57f8\u61ff\u82e1\u858f\u5f08\u5955\u6339\u5f0b\u5453\u54a6\u54bf\u566b\u5cc4\u5db7\u7317\u9974\u603f\u6021\u6092\u6f2a\u8fe4\u9a7f\u7f22\u6baa\u8d3b\u65d6\u71a0\u9487\u9552\u9571\u75cd\u7617\u7654\u7fca\u8864\u8734\u8223\u7fbf\u7ff3\u914f\u9edf", "yin": "\u8335\u836b\u56e0\u6bb7\u97f3\u9634\u59fb\u541f\u94f6\u6deb\u5bc5\u996e\u5c39\u5f15\u9690\u5370\u80e4\u911e\u5819\u831a\u5591\u72fa\u5924\u6c24\u94df\u763e\u8693\u972a\u9f88", "ying": "\u82f1\u6a31\u5a74\u9e70\u5e94\u7f28\u83b9\u8424\u8425\u8367\u8747\u8fce\u8d62\u76c8\u5f71\u9896\u786c\u6620\u5b34\u90e2\u8314\u83ba\u8426\u6484\u5624\u81ba\u6ee2\u6f46\u701b\u745b\u748e\u6979\u9e66\u763f\u988d\u7f42", "yo": "\u54df\u5537", "yong": "\u62e5\u4f63\u81c3\u75c8\u5eb8\u96cd\u8e0a\u86f9\u548f\u6cf3\u6d8c\u6c38\u607f\u52c7\u7528\u4fd1\u58c5\u5889\u6175\u9095\u955b\u752c\u9cd9\u9954", "you": "\u5e7d\u4f18\u60a0\u5fe7\u5c24\u7531\u90ae\u94c0\u72b9\u6cb9\u6e38\u9149\u6709\u53cb\u53f3\u4f51\u91c9\u8bf1\u53c8\u5e7c\u5363\u6538\u4f91\u83b8\u5466\u56ff\u5ba5\u67da\u7337\u7256\u94d5\u75a3\u8763\u9c7f\u9edd\u9f2c", "yu": "\u8fc2\u6de4\u4e8e\u76c2\u6986\u865e\u611a\u8206\u4f59\u4fde\u903e\u9c7c\u6109\u6e1d\u6e14\u9685\u4e88\u5a31\u96e8\u4e0e\u5c7f\u79b9\u5b87\u8bed\u7fbd\u7389\u57df\u828b\u90c1\u5401\u9047\u55bb\u5cea\u5fa1\u6108\u6b32\u72f1\u80b2\u8a89\u6d74\u5bd3\u88d5\u9884\u8c6b\u9a6d\u79ba\u6bd3\u4f1b\u4fe3\u8c00\u8c15\u8438\u84e3\u63c4\u5581\u5704\u5709\u5d5b\u72f3\u996b\u5ebe\u9608\u59aa\u59a4\u7ea1\u745c\u6631\u89ce\u8174\u6b24\u65bc\u715c\u71e0\u807f\u94b0\u9e46\u7610\u7600\u7ab3\u8753\u7afd\u8201\u96e9\u9f89", "yuan": "\u9e33\u6e0a\u51a4\u5143\u57a3\u8881\u539f\u63f4\u8f95\u56ed\u5458\u5706\u733f\u6e90\u7f18\u8fdc\u82d1\u613f\u6028\u9662\u586c\u6c85\u5a9b\u7457\u6a7c\u7230\u7722\u9e22\u8788\u9f0b", "yue": "\u66f0\u7ea6\u8d8a\u8dc3\u94a5\u5cb3\u7ca4\u6708\u60a6\u9605\u9fa0\u6a3e\u5216\u94ba", "yun": "\u8018\u4e91\u90e7\u5300\u9668\u5141\u8fd0\u8574\u915d\u6655\u97f5\u5b55\u90d3\u82b8\u72c1\u607d\u7ead\u6b92\u6600\u6c32", "za": "\u531d\u7838\u6742\u62f6\u5482", "zai": "\u683d\u54c9\u707e\u5bb0\u8f7d\u518d\u5728\u54b1\u5d3d\u753e", "zan": "\u6512\u6682\u8d5e\u74d2\u661d\u7c2a\u7ccc\u8db1\u933e", "zang": "\u8d43\u810f\u846c\u5958\u6215\u81e7", "zao": "\u906d\u7cdf\u51ff\u85fb\u67a3\u65e9\u6fa1\u86a4\u8e81\u566a\u9020\u7682\u7076\u71e5\u5523\u7f2b", "ze": "\u8d23\u62e9\u5219\u6cfd\u4ec4\u8d5c\u5567\u8fee\u6603\u7b2e\u7ba6\u8234", "zei": "\u8d3c", "zen": "\u600e\u8c2e", "zeng": "\u589e\u618e\u66fe\u8d60\u7f2f\u7511\u7f7e\u9503", "zha": "\u624e\u55b3\u6e23\u672d\u8f67\u94e1\u95f8\u7728\u6805\u69a8\u548b\u4e4d\u70b8\u8bc8\u63f8\u5412\u54a4\u54f3\u600d\u781f\u75c4\u86b1\u9f44", "zhai": "\u6458\u658b\u5b85\u7a84\u503a\u5be8\u7826", "zhan": "\u77bb\u6be1\u8a79\u7c98\u6cbe\u76cf\u65a9\u8f97\u5d2d\u5c55\u8638\u6808\u5360\u6218\u7ad9\u6e5b\u7efd\u8c35\u640c\u65c3", "zhang": "\u6a1f\u7ae0\u5f70\u6f33\u5f20\u638c\u6da8\u6756\u4e08\u5e10\u8d26\u4ed7\u80c0\u7634\u969c\u4ec9\u9123\u5e5b\u5d82\u7350\u5adc\u748b\u87d1", "zhao": "\u62db\u662d\u627e\u6cbc\u8d75\u7167\u7f69\u5146\u8087\u53ec\u722a\u8bcf\u68f9\u948a\u7b0a", "zhe": "\u906e\u6298\u54f2\u86f0\u8f99\u8005\u9517\u8517\u8fd9\u6d59\u8c2a\u966c\u67d8\u8f84\u78d4\u9e67\u891a\u8707\u8d6d", "zhen": "\u73cd\u659f\u771f\u7504\u7827\u81fb\u8d1e\u9488\u4fa6\u6795\u75b9\u8bca\u9707\u632f\u9547\u9635\u7f1c\u6862\u699b\u8f78\u8d48\u80d7\u6715\u796f\u755b\u9e29", "zheng": "\u84b8\u6323\u7741\u5f81\u72f0\u4e89\u6014\u6574\u62ef\u6b63\u653f\u5e27\u75c7\u90d1\u8bc1\u8be4\u5ce5\u94b2\u94ee\u7b5d", "zhi": "\u829d\u679d\u652f\u5431\u8718\u77e5\u80a2\u8102\u6c41\u4e4b\u7ec7\u804c\u76f4\u690d\u6b96\u6267\u503c\u4f84\u5740\u6307\u6b62\u8dbe\u53ea\u65e8\u7eb8\u5fd7\u631a\u63b7\u81f3\u81f4\u7f6e\u5e1c\u5cd9\u5236\u667a\u79e9\u7a1a\u8d28\u7099\u75d4\u6ede\u6cbb\u7a92\u536e\u965f\u90c5\u57f4\u82b7\u646d\u5e19\u5fee\u5f58\u54ab\u9a98\u6809\u67b3\u6800\u684e\u8f75\u8f7e\u6534\u8d3d\u81a3\u7949\u7957\u9ef9\u96c9\u9e37\u75e3\u86ed\u7d77\u916f\u8dd6\u8e2c\u8e2f\u8c78\u89ef", "zhong": "\u4e2d\u76c5\u5fe0\u949f\u8877\u7ec8\u79cd\u80bf\u91cd\u4ef2\u4f17\u51a2\u953a\u87bd\u8202\u822f\u8e35", "zhou": "\u821f\u5468\u5dde\u6d32\u8bcc\u7ca5\u8f74\u8098\u5e1a\u5492\u76b1\u5b99\u663c\u9aa4\u5544\u7740\u501c\u8bf9\u836e\u9b3b\u7ea3\u80c4\u78a1\u7c40\u8233\u914e\u9cb7", "zhu": "\u73e0\u682a\u86db\u6731\u732a\u8bf8\u8bdb\u9010\u7af9\u70db\u716e\u62c4\u77a9\u5631\u4e3b\u8457\u67f1\u52a9\u86c0\u8d2e\u94f8\u7b51\u4f4f\u6ce8\u795d\u9a7b\u4f2b\u4f8f\u90be\u82ce\u8331\u6d19\u6e1a\u6f74\u9a7a\u677c\u69e0\u6a65\u70b7\u94e2\u75b0\u7603\u86b0\u7afa\u7bb8\u7fe5\u8e85\u9e88", "zhua": "\u6293", "zhuai": "\u62fd", "zhuan": "\u4e13\u7816\u8f6c\u64b0\u8d5a\u7bc6\u629f\u556d\u989b", "zhuang": "\u6869\u5e84\u88c5\u5986\u649e\u58ee\u72b6\u4e2c", "zhui": "\u690e\u9525\u8ffd\u8d58\u5760\u7f00\u8411\u9a93\u7f12", "zhun": "\u8c06\u51c6", "zhuo": "\u6349\u62d9\u5353\u684c\u7422\u8301\u914c\u707c\u6d4a\u502c\u8bfc\u5ef4\u855e\u64e2\u555c\u6d5e\u6dbf\u6753\u712f\u799a\u65ab", "zi": "\u5179\u54a8\u8d44\u59ff\u6ecb\u6dc4\u5b5c\u7d2b\u4ed4\u7c7d\u6ed3\u5b50\u81ea\u6e0d\u5b57\u8c18\u5d6b\u59ca\u5b73\u7f01\u6893\u8f8e\u8d40\u6063\u7726\u9531\u79ed\u8014\u7b2b\u7ca2\u89dc\u8a3e\u9cbb\u9aed", "zong": "\u9b03\u68d5\u8e2a\u5b97\u7efc\u603b\u7eb5\u8159\u7cbd", "zou": "\u90b9\u8d70\u594f\u63cd\u9139\u9cb0", "zu": "\u79df\u8db3\u5352\u65cf\u7956\u8bc5\u963b\u7ec4\u4fce\u83f9\u5550\u5f82\u9a75\u8e74", "zuan": "\u94bb\u7e82\u6525\u7f35", "zui": "\u5634\u9189\u6700\u7f6a", "zun": "\u5c0a\u9075\u6499\u6a3d\u9cdf", "zuo": "\u6628\u5de6\u4f50\u67de\u505a\u4f5c\u5750\u5ea7\u961d\u963c\u80d9\u795a\u9162", "cou": "\u85ae\u6971\u8f8f\u8160", "nang": "\u652e\u54dd\u56d4\u9995\u66e9", "o": "\u5594", "dia": "\u55f2", "chuai": "\u562c\u81aa\u8e39", "cen": "\u5c91\u6d94", "diu": "\u94e5", "nou": "\u8028", "fou": "\u7f36", "bia": "\u9adf"&#125;;function ConvertPinyin(l1) &#123; var l2 = l1.length; var I1 = ""; var reg = new RegExp('[a-zA-Z0-9\- ]'); for (var i = 0; i &lt; l2; i++) &#123; var val = l1.substr(i, 1); var name = arraySearch(val, PinYin); if (reg.test(val)) &#123; I1 += val; &#125; else if (name !== false) &#123; I1 += name; &#125; &#125; I1 = I1.replace(/ /g, '-'); while (I1.indexOf('--') &gt; 0) &#123; I1 = I1.replace('--', '-'); &#125; return I1;&#125;function arraySearch(l1) &#123; for (var name in PinYin) &#123; if (PinYin[name].indexOf(l1) != -1) &#123; return name; break; &#125; &#125; return false;&#125;function checkName(name1,name2) &#123; let checkName ; let name ; let s = name1; let sp = name2; let re = new RegExp("^[a-zA-Z]+$"); let flag = re.test(s); let flagp = re.test(sp); if(flag)&#123; checkName = s; &#125;else&#123; checkName = ConvertPinyin(s); &#125; if(flagp)&#123; name = sp; &#125;else&#123; name = ConvertPinyin(sp); &#125; //判断是否匹配 let pipei = new RegExp(checkName); let page = pipei.test(name); return page&#125;export &#123; checkName&#125;]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node中的next()用法]]></title>
    <url>%2Fpost%2F2971356.html</url>
    <content type="text"><![CDATA[next()函数是用来调用下一个中间件的。 什么是中间件：位于中间，为两侧提供服务的软件 举个例子 12345678910111213app.use((ctx,next)=&gt;&#123; ctx.name = 'yixns', next();&#125;)app.use((ctx,next)=&gt;&#123; ctx.age = '24', next();&#125;)app.use((ctx,next)=&gt;&#123; console.log(`$&#123;ctx.name) is $&#123;ctx.age&#125; years old.`) next();&#125;)app.go(&#123;&#125;); ctx 参数就是 app.go 接受的对象。调用 app.go 其实会调用目标函数 app.callback，但是调用 app.callback 之前我们可以先让参数 ctx 通过一系列的中间件，最后才会传递给 app.callback。 使用 app.use 插入任意中间件，中间件是一个函数，可以被传入一个 ctx 和 next；调用 next 的时候会执行下一个中间件。如果不调用 next 会阻止接下来所有的中间件的执行，也不会执行 app.callback。 简单的来说，中间件就是流水线，流水线徐亚统一接口进行工序对接，而这个借接口，就是next koa2中间件]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node 和 模板引擎（jade）]]></title>
    <url>%2Fpost%2F34655c0e.html</url>
    <content type="text"><![CDATA[express 框架里内嵌了Jade模板引擎。 安装 npm install jade –global 执行 创建一个 index.jade 的文件，然后执行 jade index.jade 这样做就会将jade文件转换为html文件 jade还有一些参数 jade -P index.jade 这样编辑出来的index.html文件是没有进行过压缩的 jade -P -w index.jade -w 只要保存就自动编辑 jade -P -w sample.jade -O sample.json -O 用来给jade文件传递对象或JSON文件，用来替换模板内的变量 语法编辑前12345doctype htmlhtml head body h1.titleClass#titleID My First Jade Page 编辑后1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;h1 id="titleID" class="titleClass"&gt;My First Jade Page&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node 和 模板引擎（jade）]]></title>
    <url>%2Fpost%2F34655c0e.html</url>
    <content type="text"><![CDATA[注意：在node中假如同一路径有两个方法来对其进行处理，那么只有匹配到的第一个方法会被执行，剩余的略过 为了解决这一问题，node使用了 next 具体用法 index.js 1234router.get('/base/pageA', function (req, res, next) &#123; res.send('index.js.'); next(); &#125;); base.js 1234router.get('/pageA', function (req, res) &#123; //res.send('base.js!'); console.log("base.js") &#125;) 优点 轻易的实现中间件 由 12graph LR; A--&gt;c; 变为 123graph LR; A--&gt;B; B--&gt;c; 提高代码的复用性]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node--require（）为什么是同步的]]></title>
    <url>%2Fpost%2F82a3d2fb.html</url>
    <content type="text"><![CDATA[1、因为使用的是CommonJS标准 2、作为公共依赖的模块，自然要异步加载到位 3、模块的个数往往有限制，Node会自动缓存已经加载的模块，再加上访问的都是本地文件，产生的IO开销可以忽略不计 4、Node运行在服务器端，很少遇见需要频繁重启服务的情况。服务启动时候画上几秒也没有关系]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达基础]]></title>
    <url>%2Fpost%2Fbf9483c3.html</url>
    <content type="text"><![CDATA[案例以*开始 “^The”：表示所有以”The”开始的字符串（”There”，”The cat”等）； 以*结束 “of despair$”：表示所以以”of despair”结尾的字符串； 严格匹配 “^abc$”：严格匹配，只有abc自己 包含（可以在中间位置） “notice”：表示任何包含”notice”的字符串。 重复 （无限制）（*）（代表0到无限个） “ab*”：表示一个字符串有一个a后面跟着零个或若干个b。（”a”, “ab”, “abbb”,……）； 重复（至少一个）（+）（代表1到无限个） “ab+”：表示一个字符串有一个a后面跟着至少一个b或者更多； 重复（0或者一个）（？）（代表0到一个） “ab?”：表示一个字符串有一个a后面跟着零个或者一个b； 重复（综合） “a?b+$”：表示在字符串的末尾有零个或一个a跟着一个或几个b。 可以利用{}表示重复的范围 “ab{2}”：表示一个字符串有一个a跟着2个b（”abb”）； “ab{2,}”：表示一个字符串有一个a跟着至少2个b； “ab{3,5}”：表示一个字符串有一个a跟着3到5个b。 ‘*’，’+’和’?’相当于”{0,}”，”{1,}”和”{0,1}”。 “|”表示或‘.’可以替代任何字符：[] 表示任意一个 “a.[0-9]”：表示一个字符串有一个”a”后面跟着一个任意字符和一个数字； “^.{3}$”：表示有任意三个字符的字符串（长度为3个字符）； “[ab]”：表示一个字符串有一个”a”或”b”（相当于”a¦b”）； “[a-d]”：表示一个字符串包含小写的’a’到’d’中的一个（相当于”a¦b¦c¦d”或者”[abcd]”）； “^[a-zA-Z]”：表示一个以字母开头的字符串； “[0-9]%”：表示一个百分号前有一位的数字； “,[a-zA-Z0-9]$”：表示一个字符串以一个逗号后面跟着一个字母或数字结束。]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua语言简介]]></title>
    <url>%2Fpost%2F1f21691d.html</url>
    <content type="text"><![CDATA[简介Lua是一门小巧的脚本语言，由巴西里约热内卢天主教大学的Roberto Ierusalimschy等人于1993年开发，在现代企业开发中Lua通常被作为胶水语言，在游戏领域应用尤为频繁。 Lua中的数据类型Lua中定义以下几种数据类型 1、Nilnil是一个特殊的数据类型，它只有一个值，就是nil，他的作用就是为了区别其他的值 2、Boolean和其他语言一样，布尔值只用true和false两个值 3、Number用来表示实数的类型，包含整数和浮点数，Lua中number类型可以表示32位整数 4、Stringstring类型用来表示一个字符串，Lua中的字符串是不可变类型，此外Lua也存在数字和字符串之间的隐式转换12print('10'+1) //11 5、tabletable类型实现了一种特殊的数组，特殊之处在于该数字的索引方式，传统的数组索引是通过数组下标来实现的，二table不仅能以整数来索引，还可以使用字符串和其他类型的值进行索引。table没有固定的大小，可以在里面放入任意数量的元素，下面的例子简单展示了table的用法 123456a = &#123;&#125; //声明一个tablea[1] = 10a["name"] = "yinxs"print(a[1])//10print(a["name"])//yinxs Lua定义一个函数Lua没有使用大括号来规定函数的作用域，而是使用end关键字来作为结束的标记 eg： 1234567function add(a) local sun = 0 for i,v in ipairs(a) do sum = sum + v end return sumend es6中有关于函数的新特性和Lua中的函数有一些相似之处： 多重返回值 变长参数 一个Lua函数可以返回多个值，值需要在return后面列出需要返回的值即可，用逗号隔开 eg： 123funcion foo() return "a","b"end 尝试使用print语句来打印foo函数的执行结果，会输出“a”，“b”。如果使用表达书的形式来调用foo函数，会依照解构赋值额原则来赋值 123x = foo() //x = "a","b"被丢掉x,y = foo() //x = "a",y = "b"x,y,z = foo() //x = "a",y = "b",z = nil 可变参数，这个特性即为es6中的spread运算符，函数可以接收任意长度的参数。 123456789function add(...)local s = 0 for i,v in ipirs &#123;...&#125; do s = s+v endreturn sendprint(add(3,4,10,25,12) //54 Lua中的协程Lua设计之初就提供了对协程的支持，跟同时期的其他编程语言相比无疑是超前的，Lua将所有协程相关的函数放在一个名为coroutine的table中，一个协程其实就是一个特殊线程，它可以由用户控制状态的切换。 1、coroutine.create()创建一个coroutine 并返回，参数是一个函数。eg: 12345function log(i) print(i); end co = coroutine.create(log) 我们声明了一个log方法，并用其作为参数创建一个协程，这代表print方法的执行可以被用户终端或恢复。 2、coroutine.resume()重启coroutine，和create配合使用上面的diamante新建了一个协程之后并不会直接运行，而是要靠resume方法来启动。 1coroutine.resume(c0,1) --1 3、coroutine.yield()将coroutine设置为挂起状态，可以由resume来恢复执行 1234567891011121314151617function log(i) for i=1,10 do print(i) coroutine.yielld() endendco = coroutine.create(log)coroutine.resume(co) //1coroutine.resume(co) //2coroutine.resume(co) //3print(coroutine.status(co) //suspendedprint(coroutine.running()) // thread:0x7fd637c02940 true coroutine.status()为查看coroutine的状态 一个协程可以有三种不同的状态 suspended running dead 当创建一个协程后，协程默认处于suspended状态，使用yield挂起后状态同样转换为suspended。 4、coroutine.running()返回当前协程的线程号]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一个自己的Node Web框架]]></title>
    <url>%2Fpost%2Fe7d607e7.html</url>
    <content type="text"><![CDATA[前言学习一下怎么开发框架，对express和koa2的使用会让你更加得心应手。本文借鉴李锴的文章 框架的雏形首先构建一个application.js，主要的方法都会在这里声明，构建大致的代码框架 application.js 123456789101112131415161718192021222324const Emitter = require('events');const http = require("http");module.exports = class Loa extends Emitter &#123; constructor()&#123; super(); this.middleware= []; &#125; use(fn)&#123; &#125; //middle 是中间件的例子 middle(req,res) &#123; res.end("server start"); &#125; listen(port) &#123; console.log(port+" port is start") const server = http.createServer((req,res) =&gt; &#123; this.middle(req,res); &#125;); return server.listen(port); &#125;&#125;; main.js中引用 1234const Loa = require("./application");const app = new Loa();app.listen(8000); 框架的完善写不下去了，我在代码中把注释写的非常明白。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node（koa2）快速创建项目]]></title>
    <url>%2Fpost%2Fbde7ce9f.html</url>
    <content type="text"><![CDATA[创建项目（但是不支持热加载）1npm install -g koa-generator //全局安装 一键创建项目12345koa2 koa2-testcd koa2-testnpm i 执行1npm run dev 这里可能报错，原因是因为需要安装bable 1npm install --save-dev babel-core babel-polyfill babel-preset-es2015 babel-preset-stage-3 然后在bin/www中使用bable 1234require("babel-polyfill");require('babel-core/register')(&#123; presets: ['es2015', 'stage-3']&#125;); 如何写接口在routes文件夹下创建一个js文件，我们可以起一个yinxs,代码如下，我写了三个关于get的接口,以及一个post接口12345678910111213141516171819202122const router = require('koa-router')()router.prefix('/yinxs')router.get('/yinxs', function (ctx, next) &#123; ctx.body = 'I am yinxs!'&#125;)router.get('/father', function (ctx, next) &#123; ctx.body = 'I am father'&#125;)router.get('/son', function (ctx, next) &#123; ctx.body = 'I am son'&#125;)router.post('/getname', function(ctx, next) &#123; console.log(JSON.stringify(ctx.request)); ctx.body = 'I am yinxs post'&#125;)module.exports = router 在app.js将新写的接口关联进去 12const yinxs = require('./routes/yinxs')app.use(yinxs.routes(), yinxs.allowedMethods()) 执行npm run start访问 /yinxs/yinxs /yinxs/son /yinxs/father 可以获取到数据 注：项目启动的是bin目录下面的www，而不是app.js koa2跨域]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用sass]]></title>
    <url>%2Fpost%2Fe10abc6.html</url>
    <content type="text"><![CDATA[安装12npm install node-sass --save-devnpm install sass-loader --save-dev 配置 打开webpack.base.config.js在loaders里面加上 module – rules 123456789101112131415161718192021222324252627282930313233rules: [ &#123; test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; test: /\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test')] &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', query: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.scss$/, loaders: ["style", "css", "sass"] &#125;,//这里这里看这里，主要引入这一段 &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', query: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中自定义指令]]></title>
    <url>%2Fpost%2Fed2c1c4a.html</url>
    <content type="text"><![CDATA[12345678// 注册一个全局自定义指令 `v-focus`Vue.directive('focus', &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125;&#125; 1&lt;input v-focus&gt; 这里举一个高深的例子 1&lt;div id="hook-arguments-example" v-demo:foo.a.b="message"&gt;&lt;/div&gt; 12345678910111213141516171819Vue.directive('demo', &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') &#125;&#125;)new Vue(&#123; el: '#hook-arguments-example', data: &#123; message: 'hello!' &#125;&#125;) 简写模式 1234Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 接收数据 1&lt;div v-demo="&#123; color: 'white', text: 'hello!' &#125;"&gt;&lt;/div&gt; 1234Vue.directive('demo', function (el, binding) &#123; console.log(binding.value.color) // =&gt; "white" console.log(binding.value.text) // =&gt; "hello!"&#125;)]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在vue中引入jquery]]></title>
    <url>%2Fpost%2Ff35d3e0b.html</url>
    <content type="text"><![CDATA[安装 在package.json里的dependencies加入”jquery” : “^2.2.3”，然后install 或者直接安装也可以 12345678910111213141516在webpack.base.conf.js里加入var webpack = require("webpack")在module.exports的最后加入plugins: [new webpack.ProvidePlugin(&#123;jQuery: "jquery",$: "jquery"&#125;)]然后一定要重新 run dev在main.js 引入就ok了import $ from 'jquery']]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue中使用less]]></title>
    <url>%2Fpost%2F16c97c20.html</url>
    <content type="text"><![CDATA[安装 cnpm install less less-loader –save 在webpack.base.config.js在loaders里面加上 12345678&#123;test: /\.less$/,loader: "style-loader!css-loader!less-loader",&#125;,]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue中使用Echarts（vue）]]></title>
    <url>%2Fpost%2F303944b.html</url>
    <content type="text"><![CDATA[安装 cnpm install echarts –save 引入 import echarts from ‘echarts’ Vue.prototype.$echarts = echarts]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中使用富文本编辑器]]></title>
    <url>%2Fpost%2F8e3fdc01.html</url>
    <content type="text"><![CDATA[安装 cnpm install vue-quill-editor –save 引入 import { quillEditor } from ‘vue-quill-editor’]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vue中创建局部组件]]></title>
    <url>%2Fpost%2Fa29b86a7.html</url>
    <content type="text"><![CDATA[在main.js中写入12import sideBar from './components/public/sideBar.vue';Vue.component('side-bar', sideBar); 在使用的时候直接写入]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的路由（route）]]></title>
    <url>%2Fpost%2Fd41be5a0.html</url>
    <content type="text"><![CDATA[vue的路由 注意： component后面的值不要有引号，父级不要有名字name属性 12345678910111213141516[ &#123; path: '/', component: Bigdata, children: [ &#123; path: '', redirect: &#123; name: 'Table' &#125; &#125;,&#123; path: 'table', name: 'Table' , component: Table &#125; ] &#125; ]]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue全局拦截前端错误（前端异常监控系统+ng4）]]></title>
    <url>%2Fpost%2Fbe8a39c8.html</url>
    <content type="text"><![CDATA[errorHandler 一般来讲，前端的异常处理使用的是try catch 和window.onerror 但是在框架中就不可以了，三大前端框架只有react可以这么使用，vue中有自己的errorHandler，ng也有自己的属性可以这么用 这里面我们用errorHandler来进行错误拦截 12345Vue.config.errorHandler = function (err, vm, info) &#123; // handle error // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 // 只在 2.2.0+ 可用&#125; 123456789101112131415161718//具体报错信息ReferenceError: i is not defined //err at VueComponent.created (bigdata.vue?1536:26) at callHook (vue.esm.js?5425:2895) at VueComponent.Vue._init (vue.esm.js?5425:4560) at new VueComponent (vue.esm.js?5425:4728) at createComponentInstanceForVnode (vue.esm.js?5425:4242) at init (vue.esm.js?5425:4059) at createComponent (vue.esm.js?5425:5512) at createElm (vue.esm.js?5425:5460) at createChildren (vue.esm.js?5425:5586) at createElm (vue.esm.js?5425:5488)VueComponent &#123;_uid: 4, _isVue: true, $options: &#123;…&#125;, //vm _renderProxy: Proxy, _self: VueComponent, …&#125;created hook //info vue2.0参考这里 ng4参考这里 接口形式同埋点上传（利用一个gif的形式传递数据）这是我以前写的关于如何进行埋点上传的文章(代码不是我写的)]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中操作DOM]]></title>
    <url>%2Fpost%2Fe7f1df7b.html</url>
    <content type="text"><![CDATA[方案1 可以在mounted中挂载12345mounted:function()&#123; this.$nextTick(function()&#123; //this.$nextTick是在下次DOM更新循环结束时调用延迟回调函数。异步函数 this.loadData(); //DOM加载就绪，后调用loadData方法进行数据更新&lt;br&gt; //想要更新后的获取dom //此时若获取更新后dom数据将会报错，数据为undefined； &#125;) &#125; 方案2123456789101112if(document.addEventListener)&#123; document.addEventListener('DOMMouseScroll',()=&gt;&#123; &#125;,false); &#125;//W3C window.onmousewheel=document.onmousewheel=()=&gt;&#123; let top = document.getElementById("bottoms").scrollTop; console.log(top); this.$refs.add.style.marginTop = top + 10 + "px"; // document.getElementById("rights").style.marginTop = top+"px"; console.log(this.$refs.add.style); &#125;;//IE/Opera/Chrome]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex（关于vue的状态管理模式）]]></title>
    <url>%2Fpost%2F2fe08ed3.html</url>
    <content type="text"><![CDATA[介绍vuex vuex是一个为了vue开发的状态管理模式，它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化， 这篇文章不错 状态管理模式123456789101112131415161718new Vue(&#123; // state data () &#123; return &#123; count: 0 &#125; &#125;, // view template: ` &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; `, // actions methods: &#123; increment () &#123; this.count++ &#125; &#125;&#125;) 如上所示 state为驱动应用的数据源，view以声明的方式将state映射到视图，actions为响应在view上的用户输入导致的状态变化 单向数据流 1234graph LR; Actions--&gt;State; State--&gt;View; View--&gt;Actions; 如上所示为单向数据流，但是当我们有多个组件共享状态时，单向数据流的简洁性很容易被破坏。 这时会有两个需求多个视图依赖于同一状态，来自不同视图的行为需要变更同一状态。 为了方便我们把组件的共享状态抽取出来，以一个全局单例模式管理（Vuex） 安装1npm i vuex --save 引入1234import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex) 使用]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目移植报错]]></title>
    <url>%2Fpost%2F4f392df3.html</url>
    <content type="text"><![CDATA[按照这个文章解决的 npm intall sass-loader –save; npm install node-sass –save; 然后运行npm run start就可以 关于vueTreeDrag这个项目vueTreeDrag 使用的node版本是v8.8.1 删除当前的node_modules 然后cnpm i重新下载]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
</search>
